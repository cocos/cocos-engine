// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.1.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static 
#endif



#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_cocos_auto.h"
#include "bindings/auto/jsb_gfx_auto.h"


#define cc_ICanvasRenderingContext2D_width_set(self_, val_) self_->setWidth(val_)
  

#define cc_ICanvasRenderingContext2D_height_set(self_, val_) self_->setHeight(val_)
  

#define cc_ICanvasRenderingContext2D_lineWidth_set(self_, val_) self_->setLineWidth(val_)
  

#define cc_ICanvasRenderingContext2D_fillStyle_set(self_, val_) self_->setFillStyle(val_)
  

#define cc_ICanvasRenderingContext2D_font_set(self_, val_) self_->setFont(val_)
  

#define cc_ICanvasRenderingContext2D_globalCompositeOperation_set(self_, val_) self_->setGlobalCompositeOperation(val_)
  

#define cc_ICanvasRenderingContext2D_lineCap_set(self_, val_) self_->setLineCap(val_)
  

#define cc_ICanvasRenderingContext2D_strokeStyle_set(self_, val_) self_->setStrokeStyle(val_)
  

#define cc_ICanvasRenderingContext2D_lineJoin_set(self_, val_) self_->setLineJoin(val_)
  

#define cc_ICanvasRenderingContext2D_textAlign_set(self_, val_) self_->setTextAlign(val_)
  

#define cc_ICanvasRenderingContext2D_textBaseline_set(self_, val_) self_->setTextBaseline(val_)
  

#define cc_CCObject_name_get(self_) self_->getName()
#define cc_CCObject_name_set(self_, val_) self_->setName(val_)
  

#define cc_CCObject_hideFlags_get(self_) self_->getHideFlags()
#define cc_CCObject_hideFlags_set(self_, val_) self_->setHideFlags(val_)
  

#define cc_CCObject_replicated_get(self_) self_->isReplicated()
#define cc_CCObject_replicated_set(self_, val_) self_->setReplicated(val_)
  

#define cc_CCObject_isValid_get(self_) self_->isValid()
  


se::Class* __jsb_cc_CCObject_class = nullptr;
se::Object* __jsb_cc_CCObject_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_CCObject) 

static bool js_cc_CCObject_deferredDestroy_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    cc::CCObject::deferredDestroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_CCObject_deferredDestroy_static) 

static bool js_cc_CCObject__objFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "CCObject__objFlags_set,2,SWIGTYPE_cc__CCObject__Flags");
    arg1->_objFlags = (cc::CCObject::Flags)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CCObject__objFlags_set) 

static bool js_cc_CCObject__objFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->_objFlags));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CCObject__objFlags_get) 

static bool js_cc_CCObject__name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_name, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCObject__name_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CCObject__name_set) 

static bool js_cc_CCObject__name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_name, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCObject__name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_name, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CCObject__name_get) 

static bool js_new_cc_CCObject__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    ccstd::string arg1 ;
    cc::CCObject *result;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_CCObject,1,SWIGTYPE_ccstd__string"); 
    
    result = (cc::CCObject *)new cc::CCObject(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_CCObject__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::CCObject *result;
    result = (cc::CCObject *)new cc::CCObject();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_CCObject(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_CCObject__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_CCObject__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of CCObject");
    return false;
}
SE_BIND_CTOR(js_new_CCObject, __jsb_cc_CCObject_class, js_delete_cc_CCObject)

static bool js_delete_cc_CCObject(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_CCObject) 

static bool js_cc_CCObject__destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)(arg1)->destroy();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_CCObject__destroy) 

static bool js_cc_CCObject__destroyImmediate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroyImmediate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_CCObject__destroyImmediate) 

static bool js_cc_CCObject_toString(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    ccstd::string result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::CCObject const *)arg1)->toString();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCObject_toString, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_CCObject_toString) 

static bool js_cc_CCObject_name_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "CCObject_name_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_CCObject_name_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CCObject_name_set) 

static bool js_cc_CCObject_name_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    ccstd::string *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &cc_CCObject_name_get(arg1);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CCObject_name_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CCObject_name_get) 

static bool js_cc_CCObject_hideFlags_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    cc::CCObject::Flags arg2 ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "CCObject_hideFlags_set,2,SWIGTYPE_cc__CCObject__Flags");
    arg2 = (cc::CCObject::Flags)temp2;
    cc_CCObject_hideFlags_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CCObject_hideFlags_set) 

static bool js_cc_CCObject_hideFlags_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    cc::CCObject::Flags result;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::CCObject::Flags)cc_CCObject_hideFlags_get(arg1);
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CCObject_hideFlags_get) 

static bool js_cc_CCObject_replicated_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "CCObject_replicated_set,2,SWIGTYPE_bool"); 
    cc_CCObject_replicated_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CCObject_replicated_set) 

static bool js_cc_CCObject_replicated_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_CCObject_replicated_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CCObject_replicated_get) 

static bool js_cc_CCObject_isValid_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::CCObject>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)cc_CCObject_isValid_get(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CCObject_isValid_get) 

bool js_register_cc_CCObject(se::Object* obj) {
    auto* cls = se::Class::create("CCObject", obj, nullptr, _SE(js_new_CCObject)); 
    
    cls->defineProperty("_objFlags", _SE(js_cc_CCObject__objFlags_get), _SE(js_cc_CCObject__objFlags_set)); 
    cls->defineProperty("_name", _SE(js_cc_CCObject__name_get), _SE(js_cc_CCObject__name_set)); 
    cls->defineProperty("name", _SE(js_cc_CCObject_name_get), _SE(js_cc_CCObject_name_set)); 
    cls->defineProperty("hideFlags", _SE(js_cc_CCObject_hideFlags_get), _SE(js_cc_CCObject_hideFlags_set)); 
    cls->defineProperty("replicated", _SE(js_cc_CCObject_replicated_get), _SE(js_cc_CCObject_replicated_set)); 
    cls->defineProperty("isValid", _SE(js_cc_CCObject_isValid_get), nullptr); 
    
    cls->defineFunction("_destroy", _SE(js_cc_CCObject__destroy)); 
    cls->defineFunction("_destroyImmediate", _SE(js_cc_CCObject__destroyImmediate)); 
    cls->defineFunction("toString", _SE(js_cc_CCObject_toString)); 
    
    
    cls->defineStaticFunction("deferredDestroy", _SE(js_cc_CCObject_deferredDestroy_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_CCObject));
    
    
    cls->install();
    JSBClassType::registerClass<cc::CCObject>(cls);
    
    __jsb_cc_CCObject_proto = cls->getProto();
    __jsb_cc_CCObject_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_isObjectValid__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    bool arg2 ;
    bool result;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "isObjectValid,1,SWIGTYPE_p_cc__CCObject"); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg2);
    SE_PRECONDITION2(ok, false, "isObjectValid,2,SWIGTYPE_bool"); 
    result = (bool)cc::isObjectValid(arg1,arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_isObjectValid__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::CCObject *arg1 = (cc::CCObject *) NULL ;
    bool result;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "isObjectValid,1,SWIGTYPE_p_cc__CCObject"); 
    result = (bool)cc::isObjectValid(arg1);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_isObjectValid(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_isObjectValid__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_isObjectValid__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_isObjectValid) 

se::Class* __jsb_cc_JSBNativeDataHolder_class = nullptr;
se::Object* __jsb_cc_JSBNativeDataHolder_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_JSBNativeDataHolder) 

static bool js_new_cc_JSBNativeDataHolder__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::JSBNativeDataHolder *result;
    result = (cc::JSBNativeDataHolder *)new cc::JSBNativeDataHolder();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_JSBNativeDataHolder__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    uint8_t *arg1 = (uint8_t *) NULL ;
    cc::JSBNativeDataHolder *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_JSBNativeDataHolder,1,SWIGTYPE_p_uint8_t"); 
    result = (cc::JSBNativeDataHolder *)new cc::JSBNativeDataHolder(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_JSBNativeDataHolder(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_JSBNativeDataHolder__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_JSBNativeDataHolder__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of JSBNativeDataHolder");
    return false;
}
SE_BIND_CTOR(js_new_JSBNativeDataHolder, __jsb_cc_JSBNativeDataHolder_class, js_delete_cc_JSBNativeDataHolder)

static bool js_delete_cc_JSBNativeDataHolder(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_JSBNativeDataHolder) 

static bool js_cc_JSBNativeDataHolder_destroy(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::JSBNativeDataHolder *arg1 = (cc::JSBNativeDataHolder *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::JSBNativeDataHolder>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_JSBNativeDataHolder_destroy) 

bool js_register_cc_JSBNativeDataHolder(se::Object* obj) {
    auto* cls = se::Class::create("JSBNativeDataHolder", obj, nullptr, _SE(js_new_JSBNativeDataHolder)); 
    
    
    cls->defineFunction("destroy", _SE(js_cc_JSBNativeDataHolder_destroy)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_JSBNativeDataHolder));
    
    
    cls->install();
    JSBClassType::registerClass<cc::JSBNativeDataHolder>(cls);
    
    __jsb_cc_JSBNativeDataHolder_proto = cls->getProto();
    __jsb_cc_JSBNativeDataHolder_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ICanvasGradient_class = nullptr;
se::Object* __jsb_cc_ICanvasGradient_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ICanvasGradient) 

static bool js_delete_cc_ICanvasGradient(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ICanvasGradient) 

static bool js_cc_ICanvasGradient_addColorStop(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasGradient *arg1 = (cc::ICanvasGradient *) NULL ;
    float arg2 ;
    ccstd::string *arg3 = 0 ;
    ccstd::string temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasGradient>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasGradient_addColorStop,2,SWIGTYPE_float"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasGradient_addColorStop,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    (arg1)->addColorStop(arg2,(ccstd::string const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasGradient_addColorStop) 

bool js_register_cc_ICanvasGradient(se::Object* obj) {
    auto* cls = se::Class::create("ICanvasGradient", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("addColorStop", _SE(js_cc_ICanvasGradient_addColorStop)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ICanvasGradient));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ICanvasGradient>(cls);
    
    __jsb_cc_ICanvasGradient_proto = cls->getProto();
    __jsb_cc_ICanvasGradient_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_ICanvasRenderingContext2D_class = nullptr;
se::Object* __jsb_cc_ICanvasRenderingContext2D_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_ICanvasRenderingContext2D) 

static bool js_cc_ICanvasRenderingContext2D_rect(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_rect,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_rect,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_rect,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_rect,5,SWIGTYPE_float"); 
    (arg1)->rect(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_rect) 

static bool js_cc_ICanvasRenderingContext2D_clearRect(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_clearRect,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_clearRect,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_clearRect,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_clearRect,5,SWIGTYPE_float"); 
    (arg1)->clearRect(arg2,arg3,arg4,arg5);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_clearRect) 

static bool js_cc_ICanvasRenderingContext2D_createLinearGradient(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::ICanvasGradient *result = 0 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_createLinearGradient,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_createLinearGradient,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_createLinearGradient,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_createLinearGradient,5,SWIGTYPE_float"); 
    result = (cc::ICanvasGradient *)(arg1)->createLinearGradient(arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_createLinearGradient, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_createLinearGradient) 

static bool js_cc_ICanvasRenderingContext2D_save(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->save();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_save) 

static bool js_cc_ICanvasRenderingContext2D_beginPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->beginPath();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_beginPath) 

static bool js_cc_ICanvasRenderingContext2D_closePath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->closePath();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_closePath) 

static bool js_cc_ICanvasRenderingContext2D_moveTo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_moveTo,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_moveTo,3,SWIGTYPE_float"); 
    (arg1)->moveTo(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_moveTo) 

static bool js_cc_ICanvasRenderingContext2D_lineTo(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_lineTo,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_lineTo,3,SWIGTYPE_float"); 
    (arg1)->lineTo(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_lineTo) 

static bool js_cc_ICanvasRenderingContext2D_fill(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->fill();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_fill) 

static bool js_cc_ICanvasRenderingContext2D_stroke(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->stroke();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_stroke) 

static bool js_cc_ICanvasRenderingContext2D_restore(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->restore();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_restore) 

static bool js_cc_ICanvasRenderingContext2D_setShadowBlur(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setShadowBlur,2,SWIGTYPE_float"); 
    (arg1)->setShadowBlur(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_setShadowBlur) 

static bool js_cc_ICanvasRenderingContext2D_setShadowColor(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setShadowColor,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    (arg1)->setShadowColor((ccstd::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_setShadowColor) 

static bool js_cc_ICanvasRenderingContext2D_setShadowOffsetX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setShadowOffsetX,2,SWIGTYPE_float"); 
    (arg1)->setShadowOffsetX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_setShadowOffsetX) 

static bool js_cc_ICanvasRenderingContext2D_setShadowOffsetY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setShadowOffsetY,2,SWIGTYPE_float"); 
    (arg1)->setShadowOffsetY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_setShadowOffsetY) 

static bool js_cc_ICanvasRenderingContext2D_fillImageData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    cc::Data *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::Data temp2 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_fillImageData,2,SWIGTYPE_p_cc__Data");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_fillImageData,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_fillImageData,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_fillImageData,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_fillImageData,6,SWIGTYPE_float"); 
    (arg1)->fillImageData((cc::Data const &)*arg2,arg3,arg4,arg5,arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_fillImageData) 

static bool js_cc_ICanvasRenderingContext2D_translate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_translate,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_translate,3,SWIGTYPE_float"); 
    (arg1)->translate(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_translate) 

static bool js_cc_ICanvasRenderingContext2D_scale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_scale,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_scale,3,SWIGTYPE_float"); 
    (arg1)->scale(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_scale) 

static bool js_cc_ICanvasRenderingContext2D_rotate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_rotate,2,SWIGTYPE_float"); 
    (arg1)->rotate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_rotate) 

static bool js_cc_ICanvasRenderingContext2D_transform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_transform,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_transform,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_transform,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_transform,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_transform,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_transform,7,SWIGTYPE_float"); 
    (arg1)->transform(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_transform) 

static bool js_cc_ICanvasRenderingContext2D_setTransform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setTransform,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setTransform,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setTransform,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setTransform,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setTransform,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_setTransform,7,SWIGTYPE_float"); 
    (arg1)->setTransform(arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_setTransform) 

static bool js_cc_ICanvasRenderingContext2D_fetchData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->fetchData();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_ICanvasRenderingContext2D_fetchData) 

static bool js_cc_ICanvasRenderingContext2D_width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_width_set,2,SWIGTYPE_float"); 
    cc_ICanvasRenderingContext2D_width_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_width_set) 

static bool js_cc_ICanvasRenderingContext2D_height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_height_set,2,SWIGTYPE_float"); 
    cc_ICanvasRenderingContext2D_height_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_height_set) 

static bool js_cc_ICanvasRenderingContext2D_lineWidth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_lineWidth_set,2,SWIGTYPE_float"); 
    cc_ICanvasRenderingContext2D_lineWidth_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_lineWidth_set) 

static bool js_cc_ICanvasRenderingContext2D_fillStyle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_fillStyle_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_ICanvasRenderingContext2D_fillStyle_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_fillStyle_set) 

static bool js_cc_ICanvasRenderingContext2D_font_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_font_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_ICanvasRenderingContext2D_font_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_font_set) 

static bool js_cc_ICanvasRenderingContext2D_globalCompositeOperation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_globalCompositeOperation_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_ICanvasRenderingContext2D_globalCompositeOperation_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_globalCompositeOperation_set) 

static bool js_cc_ICanvasRenderingContext2D_lineCap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_lineCap_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_ICanvasRenderingContext2D_lineCap_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_lineCap_set) 

static bool js_cc_ICanvasRenderingContext2D_strokeStyle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_strokeStyle_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_ICanvasRenderingContext2D_strokeStyle_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_strokeStyle_set) 

static bool js_cc_ICanvasRenderingContext2D_lineJoin_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_lineJoin_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_ICanvasRenderingContext2D_lineJoin_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_lineJoin_set) 

static bool js_cc_ICanvasRenderingContext2D_textAlign_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_textAlign_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_ICanvasRenderingContext2D_textAlign_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_textAlign_set) 

static bool js_cc_ICanvasRenderingContext2D_textBaseline_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::ICanvasRenderingContext2D *arg1 = (cc::ICanvasRenderingContext2D *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::ICanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "ICanvasRenderingContext2D_textBaseline_set,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    cc_ICanvasRenderingContext2D_textBaseline_set(arg1,*arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_ICanvasRenderingContext2D_textBaseline_set) 

static bool js_delete_cc_ICanvasRenderingContext2D(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_ICanvasRenderingContext2D) 

bool js_register_cc_ICanvasRenderingContext2D(se::Object* obj) {
    auto* cls = se::Class::create("ICanvasRenderingContext2D", obj, nullptr, nullptr); 
    
    cls->defineProperty("width", nullptr, _SE(js_cc_ICanvasRenderingContext2D_width_set)); 
    cls->defineProperty("height", nullptr, _SE(js_cc_ICanvasRenderingContext2D_height_set)); 
    cls->defineProperty("lineWidth", nullptr, _SE(js_cc_ICanvasRenderingContext2D_lineWidth_set)); 
    cls->defineProperty("fillStyle", nullptr, _SE(js_cc_ICanvasRenderingContext2D_fillStyle_set)); 
    cls->defineProperty("font", nullptr, _SE(js_cc_ICanvasRenderingContext2D_font_set)); 
    cls->defineProperty("globalCompositeOperation", nullptr, _SE(js_cc_ICanvasRenderingContext2D_globalCompositeOperation_set)); 
    cls->defineProperty("lineCap", nullptr, _SE(js_cc_ICanvasRenderingContext2D_lineCap_set)); 
    cls->defineProperty("strokeStyle", nullptr, _SE(js_cc_ICanvasRenderingContext2D_strokeStyle_set)); 
    cls->defineProperty("lineJoin", nullptr, _SE(js_cc_ICanvasRenderingContext2D_lineJoin_set)); 
    cls->defineProperty("textAlign", nullptr, _SE(js_cc_ICanvasRenderingContext2D_textAlign_set)); 
    cls->defineProperty("textBaseline", nullptr, _SE(js_cc_ICanvasRenderingContext2D_textBaseline_set)); 
    
    cls->defineFunction("rect", _SE(js_cc_ICanvasRenderingContext2D_rect)); 
    cls->defineFunction("clearRect", _SE(js_cc_ICanvasRenderingContext2D_clearRect)); 
    cls->defineFunction("createLinearGradient", _SE(js_cc_ICanvasRenderingContext2D_createLinearGradient)); 
    cls->defineFunction("save", _SE(js_cc_ICanvasRenderingContext2D_save)); 
    cls->defineFunction("beginPath", _SE(js_cc_ICanvasRenderingContext2D_beginPath)); 
    cls->defineFunction("closePath", _SE(js_cc_ICanvasRenderingContext2D_closePath)); 
    cls->defineFunction("moveTo", _SE(js_cc_ICanvasRenderingContext2D_moveTo)); 
    cls->defineFunction("lineTo", _SE(js_cc_ICanvasRenderingContext2D_lineTo)); 
    cls->defineFunction("fill", _SE(js_cc_ICanvasRenderingContext2D_fill)); 
    cls->defineFunction("stroke", _SE(js_cc_ICanvasRenderingContext2D_stroke)); 
    cls->defineFunction("restore", _SE(js_cc_ICanvasRenderingContext2D_restore)); 
    cls->defineFunction("setShadowBlur", _SE(js_cc_ICanvasRenderingContext2D_setShadowBlur)); 
    cls->defineFunction("setShadowColor", _SE(js_cc_ICanvasRenderingContext2D_setShadowColor)); 
    cls->defineFunction("setShadowOffsetX", _SE(js_cc_ICanvasRenderingContext2D_setShadowOffsetX)); 
    cls->defineFunction("setShadowOffsetY", _SE(js_cc_ICanvasRenderingContext2D_setShadowOffsetY)); 
    cls->defineFunction("fillImageData", _SE(js_cc_ICanvasRenderingContext2D_fillImageData)); 
    cls->defineFunction("translate", _SE(js_cc_ICanvasRenderingContext2D_translate)); 
    cls->defineFunction("scale", _SE(js_cc_ICanvasRenderingContext2D_scale)); 
    cls->defineFunction("rotate", _SE(js_cc_ICanvasRenderingContext2D_rotate)); 
    cls->defineFunction("transform", _SE(js_cc_ICanvasRenderingContext2D_transform)); 
    cls->defineFunction("setTransform", _SE(js_cc_ICanvasRenderingContext2D_setTransform)); 
    cls->defineFunction("fetchData", _SE(js_cc_ICanvasRenderingContext2D_fetchData)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_ICanvasRenderingContext2D));
    
    
    cls->install();
    JSBClassType::registerClass<cc::ICanvasRenderingContext2D>(cls);
    
    __jsb_cc_ICanvasRenderingContext2D_proto = cls->getProto();
    __jsb_cc_ICanvasRenderingContext2D_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_CanvasGradient_class = nullptr;
se::Object* __jsb_cc_CanvasGradient_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_CanvasGradient) 

// js_ctor
static bool js_new_cc_CanvasGradient(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::CanvasGradient *result;
    result = (cc::CanvasGradient *)new cc::CanvasGradient();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_CanvasGradient, __jsb_cc_CanvasGradient_class, js_delete_cc_CanvasGradient)

static bool js_delete_cc_CanvasGradient(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_CanvasGradient) 

bool js_register_cc_CanvasGradient(se::Object* obj) {
    auto* cls = se::Class::create("CanvasGradient", obj, __jsb_cc_ICanvasGradient_proto, _SE(js_new_cc_CanvasGradient)); 
    
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_CanvasGradient));
    
    
    cls->install();
    JSBClassType::registerClass<cc::CanvasGradient>(cls);
    
    __jsb_cc_CanvasGradient_proto = cls->getProto();
    __jsb_cc_CanvasGradient_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_CanvasRenderingContext2D_class = nullptr;
se::Object* __jsb_cc_CanvasRenderingContext2D_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_CanvasRenderingContext2D) 

// js_ctor
static bool js_new_cc_CanvasRenderingContext2D(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 2) {
        SE_REPORT_ERROR("js_new_cc_CanvasRenderingContext2D: wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    float arg1 ;
    float arg2 ;
    cc::CanvasRenderingContext2D *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_CanvasRenderingContext2D,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_CanvasRenderingContext2D,2,SWIGTYPE_float"); 
    result = (cc::CanvasRenderingContext2D *)new cc::CanvasRenderingContext2D(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_CanvasRenderingContext2D, __jsb_cc_CanvasRenderingContext2D_class, js_delete_cc_CanvasRenderingContext2D)

static bool js_delete_cc_CanvasRenderingContext2D(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_CanvasRenderingContext2D) 

static bool js_cc_CanvasRenderingContext2D__width_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_width, nullptr);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__width_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__width_set) 

static bool js_cc_CanvasRenderingContext2D__width_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_width, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__width_get) 

static bool js_cc_CanvasRenderingContext2D__height_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_height, nullptr);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__height_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__height_set) 

static bool js_cc_CanvasRenderingContext2D__height_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_height, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__height_get) 

static bool js_cc_CanvasRenderingContext2D__lineWidth_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->_lineWidth, nullptr);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__lineWidth_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__lineWidth_set) 

static bool js_cc_CanvasRenderingContext2D__lineWidth_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->_lineWidth, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__lineWidth_get) 

static bool js_cc_CanvasRenderingContext2D__lineJoin_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_lineJoin, s.thisObject());
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__lineJoin_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__lineJoin_set) 

static bool js_cc_CanvasRenderingContext2D__lineJoin_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_lineJoin, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__lineJoin_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_lineJoin, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__lineJoin_get) 

static bool js_cc_CanvasRenderingContext2D__lineCap_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_lineCap, s.thisObject());
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__lineCap_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__lineCap_set) 

static bool js_cc_CanvasRenderingContext2D__lineCap_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_lineCap, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__lineCap_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_lineCap, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__lineCap_get) 

static bool js_cc_CanvasRenderingContext2D__font_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_font, s.thisObject());
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__font_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__font_set) 

static bool js_cc_CanvasRenderingContext2D__font_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_font, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__font_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_font, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__font_get) 

static bool js_cc_CanvasRenderingContext2D__textAlign_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_textAlign, s.thisObject());
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__textAlign_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__textAlign_set) 

static bool js_cc_CanvasRenderingContext2D__textAlign_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_textAlign, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__textAlign_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_textAlign, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__textAlign_get) 

static bool js_cc_CanvasRenderingContext2D__textBaseline_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_textBaseline, s.thisObject());
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__textBaseline_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__textBaseline_set) 

static bool js_cc_CanvasRenderingContext2D__textBaseline_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_textBaseline, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__textBaseline_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_textBaseline, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__textBaseline_get) 

static bool js_cc_CanvasRenderingContext2D__fillStyle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_fillStyle, s.thisObject());
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__fillStyle_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__fillStyle_set) 

static bool js_cc_CanvasRenderingContext2D__fillStyle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_fillStyle, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__fillStyle_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_fillStyle, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__fillStyle_get) 

static bool js_cc_CanvasRenderingContext2D__strokeStyle_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_strokeStyle, s.thisObject());
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__strokeStyle_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__strokeStyle_set) 

static bool js_cc_CanvasRenderingContext2D__strokeStyle_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_strokeStyle, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__strokeStyle_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_strokeStyle, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__strokeStyle_get) 

static bool js_cc_CanvasRenderingContext2D__globalCompositeOperation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->_globalCompositeOperation, s.thisObject());
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__globalCompositeOperation_set,2,SWIGTYPE_ccstd__string"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_CanvasRenderingContext2D__globalCompositeOperation_set) 

static bool js_cc_CanvasRenderingContext2D__globalCompositeOperation_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::CanvasRenderingContext2D *arg1 = (cc::CanvasRenderingContext2D *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::CanvasRenderingContext2D>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->_globalCompositeOperation, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "CanvasRenderingContext2D__globalCompositeOperation_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_globalCompositeOperation, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_CanvasRenderingContext2D__globalCompositeOperation_get) 

bool js_register_cc_CanvasRenderingContext2D(se::Object* obj) {
    auto* cls = se::Class::create("CanvasRenderingContext2D", obj, __jsb_cc_ICanvasRenderingContext2D_proto, _SE(js_new_cc_CanvasRenderingContext2D)); 
    
    cls->defineProperty("_width", _SE(js_cc_CanvasRenderingContext2D__width_get), _SE(js_cc_CanvasRenderingContext2D__width_set)); 
    cls->defineProperty("_height", _SE(js_cc_CanvasRenderingContext2D__height_get), _SE(js_cc_CanvasRenderingContext2D__height_set)); 
    cls->defineProperty("_lineWidth", _SE(js_cc_CanvasRenderingContext2D__lineWidth_get), _SE(js_cc_CanvasRenderingContext2D__lineWidth_set)); 
    cls->defineProperty("_lineJoin", _SE(js_cc_CanvasRenderingContext2D__lineJoin_get), _SE(js_cc_CanvasRenderingContext2D__lineJoin_set)); 
    cls->defineProperty("_lineCap", _SE(js_cc_CanvasRenderingContext2D__lineCap_get), _SE(js_cc_CanvasRenderingContext2D__lineCap_set)); 
    cls->defineProperty("_font", _SE(js_cc_CanvasRenderingContext2D__font_get), _SE(js_cc_CanvasRenderingContext2D__font_set)); 
    cls->defineProperty("_textAlign", _SE(js_cc_CanvasRenderingContext2D__textAlign_get), _SE(js_cc_CanvasRenderingContext2D__textAlign_set)); 
    cls->defineProperty("_textBaseline", _SE(js_cc_CanvasRenderingContext2D__textBaseline_get), _SE(js_cc_CanvasRenderingContext2D__textBaseline_set)); 
    cls->defineProperty("_fillStyle", _SE(js_cc_CanvasRenderingContext2D__fillStyle_get), _SE(js_cc_CanvasRenderingContext2D__fillStyle_set)); 
    cls->defineProperty("_strokeStyle", _SE(js_cc_CanvasRenderingContext2D__strokeStyle_get), _SE(js_cc_CanvasRenderingContext2D__strokeStyle_set)); 
    cls->defineProperty("_globalCompositeOperation", _SE(js_cc_CanvasRenderingContext2D__globalCompositeOperation_get), _SE(js_cc_CanvasRenderingContext2D__globalCompositeOperation_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_CanvasRenderingContext2D));
    
    
    cls->install();
    JSBClassType::registerClass<cc::CanvasRenderingContext2D>(cls);
    
    __jsb_cc_CanvasRenderingContext2D_proto = cls->getProto();
    __jsb_cc_CanvasRenderingContext2D_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Device_class = nullptr;
se::Object* __jsb_cc_Device_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Device) 

static bool js_cc_Device_getDPI_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    int result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (int)cc::Device::getDPI();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_getDPI_static) 

static bool js_cc_Device_getDevicePixelRatio_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (float)cc::Device::getDevicePixelRatio();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_getDevicePixelRatio_static) 

static bool js_cc_Device_setAccelerometerEnabled_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1);
    SE_PRECONDITION2(ok, false, "Device_setAccelerometerEnabled,1,SWIGTYPE_bool"); 
    cc::Device::setAccelerometerEnabled(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_setAccelerometerEnabled_static) 

static bool js_cc_Device_setAccelerometerInterval_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Device_setAccelerometerInterval,1,SWIGTYPE_float"); 
    cc::Device::setAccelerometerInterval(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_setAccelerometerInterval_static) 

static bool js_cc_Device_getDeviceOrientation_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::IScreen::Orientation result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::IScreen::Orientation)cc::Device::getDeviceOrientation();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_getDeviceOrientation_static) 

static bool js_cc_Device_getDeviceModel_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    ccstd::string result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = cc::Device::getDeviceModel();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_getDeviceModel, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_getDeviceModel_static) 

static bool js_cc_Device_setKeepScreenOn_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    bool arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1);
    SE_PRECONDITION2(ok, false, "Device_setKeepScreenOn,1,SWIGTYPE_bool"); 
    cc::Device::setKeepScreenOn(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_setKeepScreenOn_static) 

static bool js_cc_Device_vibrate_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Device_vibrate,1,SWIGTYPE_float"); 
    cc::Device::vibrate(arg1);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_vibrate_static) 

static bool js_cc_Device_getBatteryLevel_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (float)cc::Device::getBatteryLevel();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_getBatteryLevel_static) 

static bool js_cc_Device_getNetworkType_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::INetwork::NetworkType result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::INetwork::NetworkType)cc::Device::getNetworkType();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_getNetworkType_static) 

static bool js_cc_Device_getSafeAreaEdge_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec4 result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = cc::Device::getSafeAreaEdge();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Device_getSafeAreaEdge, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Device_getSafeAreaEdge_static) 

static bool js_delete_cc_Device(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Device) 

bool js_register_cc_Device(se::Object* obj) {
    auto* cls = se::Class::create("Device", obj, nullptr, nullptr); 
    
    
    
    
    cls->defineStaticFunction("getDPI", _SE(js_cc_Device_getDPI_static)); 
    cls->defineStaticFunction("getDevicePixelRatio", _SE(js_cc_Device_getDevicePixelRatio_static)); 
    cls->defineStaticFunction("setAccelerometerEnabled", _SE(js_cc_Device_setAccelerometerEnabled_static)); 
    cls->defineStaticFunction("setAccelerometerInterval", _SE(js_cc_Device_setAccelerometerInterval_static)); 
    cls->defineStaticFunction("getDeviceOrientation", _SE(js_cc_Device_getDeviceOrientation_static)); 
    cls->defineStaticFunction("getDeviceModel", _SE(js_cc_Device_getDeviceModel_static)); 
    cls->defineStaticFunction("setKeepScreenOn", _SE(js_cc_Device_setKeepScreenOn_static)); 
    cls->defineStaticFunction("vibrate", _SE(js_cc_Device_vibrate_static)); 
    cls->defineStaticFunction("getBatteryLevel", _SE(js_cc_Device_getBatteryLevel_static)); 
    cls->defineStaticFunction("getNetworkType", _SE(js_cc_Device_getNetworkType_static)); 
    cls->defineStaticFunction("getSafeAreaEdge", _SE(js_cc_Device_getSafeAreaEdge_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Device));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Device>(cls);
    
    __jsb_cc_Device_proto = cls->getProto();
    __jsb_cc_Device_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_FileUtils_class = nullptr;
se::Object* __jsb_cc_FileUtils_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_FileUtils) 

static bool js_cc_FileUtils_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::FileUtils *)cc::FileUtils::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getInstance_static) 

static bool js_delete_cc_FileUtils(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_FileUtils) 

static bool js_cc_FileUtils_purgeCachedEntries(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->purgeCachedEntries();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_purgeCachedEntries) 

static bool js_cc_FileUtils_getStringFromFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    ccstd::string result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getStringFromFile,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (arg1)->getStringFromFile((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getStringFromFile, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getStringFromFile) 

static bool js_cc_FileUtils_getDataFromFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::Data result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getDataFromFile,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (arg1)->getDataFromFile((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getDataFromFile, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getDataFromFile) 

static bool js_cc_FileUtils_getFileDataFromZip(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    uint32_t *arg4 = (uint32_t *) NULL ;
    ccstd::string temp2 ;
    ccstd::string temp3 ;
    unsigned char *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getFileDataFromZip,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getFileDataFromZip,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getFileDataFromZip,4,SWIGTYPE_p_uint32_t"); 
    result = (unsigned char *)(arg1)->getFileDataFromZip((ccstd::string const &)*arg2,(ccstd::string const &)*arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getFileDataFromZip, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getFileDataFromZip) 

static bool js_cc_FileUtils_fullPathForFilename(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    ccstd::string result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_fullPathForFilename,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = ((cc::FileUtils const *)arg1)->fullPathForFilename((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_fullPathForFilename, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_fullPathForFilename) 

static bool js_cc_FileUtils_fullPathFromRelativeFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::string temp3 ;
    ccstd::string result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_fullPathFromRelativeFile,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_fullPathFromRelativeFile,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    result = (arg1)->fullPathFromRelativeFile((ccstd::string const &)*arg2,(ccstd::string const &)*arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_fullPathFromRelativeFile, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_fullPathFromRelativeFile) 

static bool js_cc_FileUtils_setSearchPaths(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::vector< ccstd::string > *arg2 = 0 ;
    ccstd::vector< ccstd::string > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_setSearchPaths,2,SWIGTYPE_p_ccstd__vectorT_ccstd__string_t");
    arg2 = &temp2;
    
    (arg1)->setSearchPaths((ccstd::vector< ccstd::string > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_setSearchPaths) 

static bool js_cc_FileUtils_getDefaultResourceRootPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::string *) &((cc::FileUtils const *)arg1)->getDefaultResourceRootPath();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getDefaultResourceRootPath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getDefaultResourceRootPath) 

static bool js_cc_FileUtils_setDefaultResourceRootPath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_setDefaultResourceRootPath,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    (arg1)->setDefaultResourceRootPath((ccstd::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_setDefaultResourceRootPath) 

static bool js_cc_FileUtils_addSearchPath__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    bool arg3 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_addSearchPath,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) bool
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "FileUtils_addSearchPath,3,SWIGTYPE_bool"); 
    (arg1)->addSearchPath((ccstd::string const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_FileUtils_addSearchPath__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_addSearchPath,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    (arg1)->addSearchPath((ccstd::string const &)*arg2);
    
    
    return true;
}

static bool js_cc_FileUtils_addSearchPath(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_FileUtils_addSearchPath__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_FileUtils_addSearchPath__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_FileUtils_addSearchPath) 

static bool js_cc_FileUtils_getSearchPaths(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::vector< ccstd::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< ccstd::string > *) &((cc::FileUtils const *)arg1)->getSearchPaths();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getSearchPaths, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getSearchPaths) 

static bool js_cc_FileUtils_getOriginalSearchPaths(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::vector< ccstd::string > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< ccstd::string > *) &((cc::FileUtils const *)arg1)->getOriginalSearchPaths();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getOriginalSearchPaths, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getOriginalSearchPaths) 

static bool js_cc_FileUtils_getWritablePath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::FileUtils const *)arg1)->getWritablePath();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getWritablePath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getWritablePath) 

static bool js_cc_FileUtils_setWritablePath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_setWritablePath,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    (arg1)->setWritablePath((ccstd::string const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_setWritablePath) 

static bool js_cc_FileUtils_getValueMapFromFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::ValueMap result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getValueMapFromFile,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (arg1)->getValueMapFromFile((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getValueMapFromFile, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getValueMapFromFile) 

static bool js_cc_FileUtils_getValueMapFromData(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    char *arg2 = (char *) NULL ;
    int arg3 ;
    ccstd::string temp2 ;
    cc::ValueMap result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "FileUtils_getValueMapFromData,2,SWIGTYPE_p_char");
    arg2 = (char *) temp2.c_str(); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "FileUtils_getValueMapFromData,3,SWIGTYPE_int"); 
    result = (arg1)->getValueMapFromData((char const *)arg2,arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getValueMapFromData, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getValueMapFromData) 

static bool js_cc_FileUtils_writeToFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    cc::ValueMap *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    cc::ValueMap temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeToFile,2,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__Value_t");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeToFile,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    result = (bool)(arg1)->writeToFile((cc::ValueMap const &)*arg2,(ccstd::string const &)*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_writeToFile) 

static bool js_cc_FileUtils_writeStringToFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeStringToFile,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeStringToFile,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    result = (bool)(arg1)->writeStringToFile((ccstd::string const &)*arg2,(ccstd::string const &)*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_writeStringToFile) 

static bool js_cc_FileUtils_writeDataToFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    cc::Data *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    cc::Data temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeDataToFile,2,SWIGTYPE_p_cc__Data");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeDataToFile,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    result = (bool)(arg1)->writeDataToFile((cc::Data const &)*arg2,(ccstd::string const &)*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_writeDataToFile) 

static bool js_cc_FileUtils_writeValueMapToFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    cc::ValueMap *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    cc::ValueMap temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeValueMapToFile,2,SWIGTYPE_p_ccstd__unordered_mapT_ccstd__string_cc__Value_t");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeValueMapToFile,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    result = (bool)(arg1)->writeValueMapToFile((cc::ValueMap const &)*arg2,(ccstd::string const &)*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_writeValueMapToFile) 

static bool js_cc_FileUtils_writeValueVectorToFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    cc::ValueVector *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    cc::ValueVector temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeValueVectorToFile,2,SWIGTYPE_p_ccstd__vectorT_cc__Value_t");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_writeValueVectorToFile,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    result = (bool)(arg1)->writeValueVectorToFile((cc::ValueVector const &)*arg2,(ccstd::string const &)*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_writeValueVectorToFile) 

static bool js_cc_FileUtils_getSuitableFOpen(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    ccstd::string result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getSuitableFOpen,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = ((cc::FileUtils const *)arg1)->getSuitableFOpen((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getSuitableFOpen, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getSuitableFOpen) 

static bool js_cc_FileUtils_getValueVectorFromFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    cc::ValueVector result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getValueVectorFromFile,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (arg1)->getValueVectorFromFile((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getValueVectorFromFile, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getValueVectorFromFile) 

static bool js_cc_FileUtils_isFileExist(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_isFileExist,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (bool)((cc::FileUtils const *)arg1)->isFileExist((ccstd::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_isFileExist) 

static bool js_cc_FileUtils_getFileExtension(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    ccstd::string result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getFileExtension,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = ((cc::FileUtils const *)arg1)->getFileExtension((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getFileExtension, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getFileExtension) 

static bool js_cc_FileUtils_isAbsolutePath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_isAbsolutePath,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (bool)((cc::FileUtils const *)arg1)->isAbsolutePath((ccstd::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_isAbsolutePath) 

static bool js_cc_FileUtils_isDirectoryExist(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_isDirectoryExist,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (bool)((cc::FileUtils const *)arg1)->isDirectoryExist((ccstd::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_isDirectoryExist) 

static bool js_cc_FileUtils_listFiles(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    ccstd::vector< ccstd::string > result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_listFiles,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = ((cc::FileUtils const *)arg1)->listFiles((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_listFiles, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_listFiles) 

static bool js_cc_FileUtils_createDirectory(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_createDirectory,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (bool)(arg1)->createDirectory((ccstd::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_createDirectory) 

static bool js_cc_FileUtils_removeDirectory(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_removeDirectory,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (bool)(arg1)->removeDirectory((ccstd::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_removeDirectory) 

static bool js_cc_FileUtils_removeFile(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_removeFile,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (bool)(arg1)->removeFile((ccstd::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_removeFile) 

static bool js_cc_FileUtils_renameFile__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    ccstd::string *arg4 = 0 ;
    ccstd::string temp2 ;
    ccstd::string temp3 ;
    ccstd::string temp4 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_renameFile,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_renameFile,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_renameFile,4,SWIGTYPE_p_ccstd__string");
    arg4 = &temp4;
    
    result = (bool)(arg1)->renameFile((ccstd::string const &)*arg2,(ccstd::string const &)*arg3,(ccstd::string const &)*arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_FileUtils_renameFile__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string *arg3 = 0 ;
    ccstd::string temp2 ;
    ccstd::string temp3 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_renameFile,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_renameFile,3,SWIGTYPE_p_ccstd__string");
    arg3 = &temp3;
    
    result = (bool)(arg1)->renameFile((ccstd::string const &)*arg2,(ccstd::string const &)*arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_FileUtils_renameFile(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_FileUtils_renameFile__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_FileUtils_renameFile__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_FileUtils_renameFile) 

static bool js_cc_FileUtils_getFileSize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    long result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getFileSize,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (long)(arg1)->getFileSize((ccstd::string const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getFileSize) 

static bool js_cc_FileUtils_normalizePath(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    ccstd::string result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_normalizePath,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = ((cc::FileUtils const *)arg1)->normalizePath((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_normalizePath, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_normalizePath) 

static bool js_cc_FileUtils_getFileDir(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *arg1 = (cc::FileUtils *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    ccstd::string result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::FileUtils>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "FileUtils_getFileDir,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = ((cc::FileUtils const *)arg1)->getFileDir((ccstd::string const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "FileUtils_getFileDir, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_FileUtils_getFileDir) 

bool js_register_cc_FileUtils(se::Object* obj) {
    auto* cls = se::Class::create("FileUtils", obj, nullptr, nullptr); 
    
    
    cls->defineFunction("purgeCachedEntries", _SE(js_cc_FileUtils_purgeCachedEntries)); 
    cls->defineFunction("getStringFromFile", _SE(js_cc_FileUtils_getStringFromFile)); 
    cls->defineFunction("getDataFromFile", _SE(js_cc_FileUtils_getDataFromFile)); 
    cls->defineFunction("getFileDataFromZip", _SE(js_cc_FileUtils_getFileDataFromZip)); 
    cls->defineFunction("fullPathForFilename", _SE(js_cc_FileUtils_fullPathForFilename)); 
    cls->defineFunction("fullPathFromRelativeFile", _SE(js_cc_FileUtils_fullPathFromRelativeFile)); 
    cls->defineFunction("setSearchPaths", _SE(js_cc_FileUtils_setSearchPaths)); 
    cls->defineFunction("getDefaultResourceRootPath", _SE(js_cc_FileUtils_getDefaultResourceRootPath)); 
    cls->defineFunction("setDefaultResourceRootPath", _SE(js_cc_FileUtils_setDefaultResourceRootPath)); 
    cls->defineFunction("addSearchPath", _SE(js_cc_FileUtils_addSearchPath)); 
    cls->defineFunction("getSearchPaths", _SE(js_cc_FileUtils_getSearchPaths)); 
    cls->defineFunction("getOriginalSearchPaths", _SE(js_cc_FileUtils_getOriginalSearchPaths)); 
    cls->defineFunction("getWritablePath", _SE(js_cc_FileUtils_getWritablePath)); 
    cls->defineFunction("setWritablePath", _SE(js_cc_FileUtils_setWritablePath)); 
    cls->defineFunction("getValueMapFromFile", _SE(js_cc_FileUtils_getValueMapFromFile)); 
    cls->defineFunction("getValueMapFromData", _SE(js_cc_FileUtils_getValueMapFromData)); 
    cls->defineFunction("writeToFile", _SE(js_cc_FileUtils_writeToFile)); 
    cls->defineFunction("writeStringToFile", _SE(js_cc_FileUtils_writeStringToFile)); 
    cls->defineFunction("writeDataToFile", _SE(js_cc_FileUtils_writeDataToFile)); 
    cls->defineFunction("writeValueMapToFile", _SE(js_cc_FileUtils_writeValueMapToFile)); 
    cls->defineFunction("writeValueVectorToFile", _SE(js_cc_FileUtils_writeValueVectorToFile)); 
    cls->defineFunction("getSuitableFOpen", _SE(js_cc_FileUtils_getSuitableFOpen)); 
    cls->defineFunction("getValueVectorFromFile", _SE(js_cc_FileUtils_getValueVectorFromFile)); 
    cls->defineFunction("isFileExist", _SE(js_cc_FileUtils_isFileExist)); 
    cls->defineFunction("getFileExtension", _SE(js_cc_FileUtils_getFileExtension)); 
    cls->defineFunction("isAbsolutePath", _SE(js_cc_FileUtils_isAbsolutePath)); 
    cls->defineFunction("isDirectoryExist", _SE(js_cc_FileUtils_isDirectoryExist)); 
    cls->defineFunction("listFiles", _SE(js_cc_FileUtils_listFiles)); 
    cls->defineFunction("createDirectory", _SE(js_cc_FileUtils_createDirectory)); 
    cls->defineFunction("removeDirectory", _SE(js_cc_FileUtils_removeDirectory)); 
    cls->defineFunction("removeFile", _SE(js_cc_FileUtils_removeFile)); 
    cls->defineFunction("renameFile", _SE(js_cc_FileUtils_renameFile)); 
    cls->defineFunction("getFileSize", _SE(js_cc_FileUtils_getFileSize)); 
    cls->defineFunction("normalizePath", _SE(js_cc_FileUtils_normalizePath)); 
    cls->defineFunction("getFileDir", _SE(js_cc_FileUtils_getFileDir)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_FileUtils_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_FileUtils));
    
    
    cls->install();
    JSBClassType::registerClass<cc::FileUtils>(cls);
    
    __jsb_cc_FileUtils_proto = cls->getProto();
    __jsb_cc_FileUtils_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_createFileUtils(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::FileUtils *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::FileUtils *)cc::createFileUtils();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "createFileUtils, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_createFileUtils) 

se::Class* __jsb_cc_SAXParser_class = nullptr;
se::Object* __jsb_cc_SAXParser_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_SAXParser) 

// js_ctor
static bool js_new_cc_SAXParser(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::SAXParser *result;
    result = (cc::SAXParser *)new cc::SAXParser();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_SAXParser, __jsb_cc_SAXParser_class, js_delete_cc_SAXParser)

static bool js_delete_cc_SAXParser(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_SAXParser) 

static bool js_cc_PlistParser_init(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SAXParser *arg1 = (cc::SAXParser *) NULL ;
    char *arg2 = (char *) NULL ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SAXParser>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "PlistParser_init,2,SWIGTYPE_p_char");
    arg2 = (char *) temp2.c_str(); 
    result = (bool)(arg1)->init((char const *)arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_PlistParser_init) 

static bool js_cc_PlistParser_parse(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::SAXParser *arg1 = (cc::SAXParser *) NULL ;
    ccstd::string *arg2 = 0 ;
    ccstd::string temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::SAXParser>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "PlistParser_parse,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    result = (bool)(arg1)->parse((ccstd::string const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_PlistParser_parse) 

bool js_register_cc_SAXParser(se::Object* obj) {
    auto* cls = se::Class::create("PlistParser", obj, nullptr, _SE(js_new_cc_SAXParser)); 
    
    
    cls->defineFunction("init", _SE(js_cc_PlistParser_init)); 
    cls->defineFunction("parse", _SE(js_cc_PlistParser_parse)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_SAXParser));
    
    
    cls->install();
    JSBClassType::registerClass<cc::SAXParser>(cls);
    
    __jsb_cc_SAXParser_proto = cls->getProto();
    __jsb_cc_SAXParser_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


static bool js_cc_clampf(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float result;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "clampf,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "clampf,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "clampf,3,SWIGTYPE_float"); 
    result = (float)cc::clampf(arg1,arg2,arg3);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_clampf) 

se::Class* __jsb_cc_Vec2_class = nullptr;
se::Object* __jsb_cc_Vec2_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Vec2) 

static bool js_cc_Vec2_x_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->x, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_x_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Vec2_x_set) 

static bool js_cc_Vec2_x_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->x, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_x_get) 

static bool js_cc_Vec2_y_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->y, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_y_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Vec2_y_set) 

static bool js_cc_Vec2_y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->y, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_y_get) 

static bool js_new_cc_Vec2__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Vec2 *result;
    result = (cc::Vec2 *)new cc::Vec2();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Vec2__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::Vec2 *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Vec2,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Vec2,2,SWIGTYPE_float"); 
    result = (cc::Vec2 *)new cc::Vec2(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Vec2__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float *arg1 = (float *) NULL ;
    cc::Vec2 *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Vec2,1,SWIGTYPE_p_float"); 
    result = (cc::Vec2 *)new cc::Vec2((float const *)arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Vec2__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Vec2,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Vec2,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (cc::Vec2 *)new cc::Vec2((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Vec2__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Vec2,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    result = (cc::Vec2 *)new cc::Vec2((cc::Vec2 const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Vec2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_Vec2__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_Vec2__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_Vec2__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_Vec2__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_Vec2__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Vec2");
    return false;
}
SE_BIND_CTOR(js_new_Vec2, __jsb_cc_Vec2_class, js_delete_cc_Vec2)

static bool js_delete_cc_Vec2(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Vec2) 

static bool js_cc_Vec2_isZero(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::Vec2 const *)arg1)->isZero();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_isZero) 

static bool js_cc_Vec2_isOne(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (bool)((cc::Vec2 const *)arg1)->isOne();
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_isOne) 

static bool js_cc_Vec2_angle_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    float result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_angle,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_angle,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (float)cc::Vec2::angle((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_angle_static) 

static bool js_cc_Vec2_add__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_add,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    (arg1)->add((cc::Vec2 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Vec2_add_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = (cc::Vec2 *) NULL ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_add,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_add,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_add,3,SWIGTYPE_p_cc__Vec2"); 
    cc::Vec2::add((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Vec2_add_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Vec2_add__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Vec2_add_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_add_static) 

static bool js_cc_Vec2_clamp__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_clamp,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_clamp,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    (arg1)->clamp((cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Vec2_clamp_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = (cc::Vec2 *) NULL ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_clamp,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_clamp,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_clamp,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_clamp,4,SWIGTYPE_p_cc__Vec2"); 
    cc::Vec2::clamp((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,arg4);
    
    
    return true;
}

static bool js_cc_Vec2_clamp_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Vec2_clamp__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_Vec2_clamp_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_clamp_static) 

static bool js_cc_Vec2_distance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_distance,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (float)((cc::Vec2 const *)arg1)->distance((cc::Vec2 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_distance) 

static bool js_cc_Vec2_distanceSquared(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_distanceSquared,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (float)((cc::Vec2 const *)arg1)->distanceSquared((cc::Vec2 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_distanceSquared) 

static bool js_cc_Vec2_dot__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_dot,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (float)((cc::Vec2 const *)arg1)->dot((cc::Vec2 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}

static bool js_cc_Vec2_dot_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    float result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_dot,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_dot,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (float)cc::Vec2::dot((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}

static bool js_cc_Vec2_dot_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Vec2_dot__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Vec2_dot_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_dot_static) 

static bool js_cc_Vec2_length(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::Vec2 const *)arg1)->length();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_length) 

static bool js_cc_Vec2_lengthSquared(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::Vec2 const *)arg1)->lengthSquared();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_lengthSquared) 

static bool js_cc_Vec2_negate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->negate();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_negate) 

static bool js_cc_Vec2_normalize(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->normalize();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_normalize) 

static bool js_cc_Vec2_getNormalized(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Vec2 const *)arg1)->getNormalized();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_getNormalized, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getNormalized) 

static bool js_cc_Vec2_scale__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    float arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_scale,2,SWIGTYPE_float"); 
    (arg1)->scale(arg2);
    
    
    return true;
}

static bool js_cc_Vec2_scale__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_scale,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    (arg1)->scale((cc::Vec2 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Vec2_scale(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Vec2_scale__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Vec2_scale__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_scale) 

static bool js_cc_Vec2_rotate__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    float arg3 ;
    cc::Vec2 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_rotate,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_rotate,3,SWIGTYPE_float"); 
    (arg1)->rotate((cc::Vec2 const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Vec2_set__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    float arg2 ;
    float arg3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_set,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_set,3,SWIGTYPE_float"); 
    (arg1)->set(arg2,arg3);
    
    
    return true;
}

static bool js_cc_Vec2_set__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    float *arg2 = (float *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_set,2,SWIGTYPE_p_float"); 
    (arg1)->set((float const *)arg2);
    
    
    return true;
}

static bool js_cc_Vec2_set__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_set,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    (arg1)->set((cc::Vec2 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Vec2_set__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_set,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_set,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    (arg1)->set((cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3);
    
    
    return true;
}

static bool js_cc_Vec2_set(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Vec2_set__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Vec2_set__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Vec2_set__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Vec2_set__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_set) 

static bool js_cc_Vec2_setZero(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->setZero();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_setZero) 

static bool js_cc_Vec2_subtract__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_subtract,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    (arg1)->subtract((cc::Vec2 const &)*arg2);
    
    
    return true;
}

static bool js_cc_Vec2_subtract_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = (cc::Vec2 *) NULL ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_subtract,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_subtract,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_subtract,3,SWIGTYPE_p_cc__Vec2"); 
    cc::Vec2::subtract((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_Vec2_subtract_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Vec2_subtract__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_Vec2_subtract_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_subtract_static) 

static bool js_cc_Vec2_smooth(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    float arg3 ;
    float arg4 ;
    cc::Vec2 temp2 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_smooth,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_smooth,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_smooth,4,SWIGTYPE_float"); 
    (arg1)->smooth((cc::Vec2 const &)*arg2,arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_smooth) 

static bool js_cc_Vec2_setPoint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    float arg2 ;
    float arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_setPoint,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_setPoint,3,SWIGTYPE_float"); 
    (arg1)->setPoint(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_setPoint) 

static bool js_cc_Vec2_equals(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_equals,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (bool)((cc::Vec2 const *)arg1)->equals((cc::Vec2 const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_equals) 

static bool js_cc_Vec2_fuzzyEquals(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    float arg3 ;
    cc::Vec2 temp2 ;
    bool result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_fuzzyEquals,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_fuzzyEquals,3,SWIGTYPE_float"); 
    result = (bool)((cc::Vec2 const *)arg1)->fuzzyEquals((cc::Vec2 const &)*arg2,arg3);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_fuzzyEquals) 

static bool js_cc_Vec2_getLength(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::Vec2 const *)arg1)->getLength();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getLength) 

static bool js_cc_Vec2_getLengthSq(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::Vec2 const *)arg1)->getLengthSq();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getLengthSq) 

static bool js_cc_Vec2_getDistanceSq(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getDistanceSq,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (float)((cc::Vec2 const *)arg1)->getDistanceSq((cc::Vec2 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getDistanceSq) 

static bool js_cc_Vec2_getDistance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getDistance,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (float)((cc::Vec2 const *)arg1)->getDistance((cc::Vec2 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getDistance) 

static bool js_cc_Vec2_getAngle__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::Vec2 const *)arg1)->getAngle();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}

static bool js_cc_Vec2_getAngle__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    float result;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getAngle,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (float)((cc::Vec2 const *)arg1)->getAngle((cc::Vec2 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}

static bool js_cc_Vec2_getAngle(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_Vec2_getAngle__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Vec2_getAngle__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_getAngle) 

static bool js_cc_Vec2_cross(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_cross,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = (float)((cc::Vec2 const *)arg1)->cross((cc::Vec2 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_cross) 

static bool js_cc_Vec2_getPerp(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Vec2 const *)arg1)->getPerp();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_getPerp, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getPerp) 

static bool js_cc_Vec2_getMidpoint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    cc::Vec2 result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getMidpoint,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = ((cc::Vec2 const *)arg1)->getMidpoint((cc::Vec2 const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_getMidpoint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getMidpoint) 

static bool js_cc_Vec2_getClampPoint(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getClampPoint,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getClampPoint,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    result = ((cc::Vec2 const *)arg1)->getClampPoint((cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_getClampPoint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getClampPoint) 

static bool js_cc_Vec2_getRPerp(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Vec2 const *)arg1)->getRPerp();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_getRPerp, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getRPerp) 

static bool js_cc_Vec2_project(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    cc::Vec2 result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_project,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = ((cc::Vec2 const *)arg1)->project((cc::Vec2 const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_project, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_project) 

static bool js_cc_Vec2_rotate__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    cc::Vec2 result;
    
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_rotate,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = ((cc::Vec2 const *)arg1)->rotate((cc::Vec2 const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_rotate, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_Vec2_rotate(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Vec2_rotate__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Vec2_rotate__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_rotate) 

static bool js_cc_Vec2_unrotate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 temp2 ;
    cc::Vec2 result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_unrotate,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    result = ((cc::Vec2 const *)arg1)->unrotate((cc::Vec2 const &)*arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_unrotate, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_unrotate) 

static bool js_cc_Vec2_lerp(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    float arg3 ;
    cc::Vec2 temp2 ;
    cc::Vec2 result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_lerp,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_lerp,3,SWIGTYPE_float"); 
    result = ((cc::Vec2 const *)arg1)->lerp((cc::Vec2 const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_lerp, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_lerp) 

static bool js_cc_Vec2_rotateByAngle(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg2 = 0 ;
    float arg3 ;
    cc::Vec2 temp2 ;
    cc::Vec2 result;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Vec2>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_rotateByAngle,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_rotateByAngle,3,SWIGTYPE_float"); 
    result = ((cc::Vec2 const *)arg1)->rotateByAngle((cc::Vec2 const &)*arg2,arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_rotateByAngle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_rotateByAngle) 

static bool js_cc_Vec2_forAngle_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    cc::Vec2 result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Vec2_forAngle,1,SWIGTYPE_float"); 
    result = cc::Vec2::forAngle(arg1);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_forAngle, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_forAngle_static) 

static bool js_cc_Vec2_isLineIntersect_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    float *arg5 = (float *) NULL ;
    float *arg6 = (float *) NULL ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    bool result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,5,SWIGTYPE_p_float"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[5], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,6,SWIGTYPE_p_float"); 
    result = (bool)cc::Vec2::isLineIntersect((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4,arg5,arg6);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Vec2_isLineIntersect_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    float *arg5 = (float *) NULL ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    bool result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,5,SWIGTYPE_p_float"); 
    result = (bool)cc::Vec2::isLineIntersect((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4,arg5);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Vec2_isLineIntersect_static__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    bool result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineIntersect,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    result = (bool)cc::Vec2::isLineIntersect((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Vec2_isLineIntersect_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_Vec2_isLineIntersect_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_Vec2_isLineIntersect_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_Vec2_isLineIntersect_static__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_isLineIntersect_static) 

static bool js_cc_Vec2_isLineOverlap_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    bool result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineOverlap,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineOverlap,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineOverlap,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineOverlap,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    result = (bool)cc::Vec2::isLineOverlap((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_isLineOverlap_static) 

static bool js_cc_Vec2_isLineParallel_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    bool result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineParallel,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineParallel,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineParallel,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isLineParallel,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    result = (bool)cc::Vec2::isLineParallel((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_isLineParallel_static) 

static bool js_cc_Vec2_isSegmentOverlap_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    cc::Vec2 *arg5 = (cc::Vec2 *) NULL ;
    cc::Vec2 *arg6 = (cc::Vec2 *) NULL ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    bool result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,5,SWIGTYPE_p_cc__Vec2"); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[5], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,6,SWIGTYPE_p_cc__Vec2"); 
    result = (bool)cc::Vec2::isSegmentOverlap((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4,arg5,arg6);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Vec2_isSegmentOverlap_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    cc::Vec2 *arg5 = (cc::Vec2 *) NULL ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    bool result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,5,SWIGTYPE_p_cc__Vec2"); 
    result = (bool)cc::Vec2::isSegmentOverlap((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4,arg5);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Vec2_isSegmentOverlap_static__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    bool result;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentOverlap,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    result = (bool)cc::Vec2::isSegmentOverlap((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_Vec2_isSegmentOverlap_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_Vec2_isSegmentOverlap_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_Vec2_isSegmentOverlap_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_Vec2_isSegmentOverlap_static__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Vec2_isSegmentOverlap_static) 

static bool js_cc_Vec2_isSegmentIntersect_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    bool result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentIntersect,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentIntersect,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentIntersect,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_isSegmentIntersect,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    result = (bool)cc::Vec2::isSegmentIntersect((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_isSegmentIntersect_static) 

static bool js_cc_Vec2_getIntersectPoint_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Vec2 *arg1 = 0 ;
    cc::Vec2 *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::Vec2 *arg4 = 0 ;
    cc::Vec2 temp1 ;
    cc::Vec2 temp2 ;
    cc::Vec2 temp3 ;
    cc::Vec2 temp4 ;
    cc::Vec2 result;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getIntersectPoint,1,SWIGTYPE_p_cc__Vec2");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getIntersectPoint,2,SWIGTYPE_p_cc__Vec2");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getIntersectPoint,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Vec2_getIntersectPoint,4,SWIGTYPE_p_cc__Vec2");
    arg4 = &temp4;
    
    result = cc::Vec2::getIntersectPoint((cc::Vec2 const &)*arg1,(cc::Vec2 const &)*arg2,(cc::Vec2 const &)*arg3,(cc::Vec2 const &)*arg4);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_getIntersectPoint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Vec2_getIntersectPoint_static) 

static bool js_cc_Vec2_ZERO_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ZERO;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ZERO_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ZERO_get) 

static bool js_cc_Vec2_ONE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ONE;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ONE_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ONE_get) 

static bool js_cc_Vec2_UNIT_X_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::UNIT_X;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_UNIT_X_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_UNIT_X_get) 

static bool js_cc_Vec2_UNIT_Y_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::UNIT_Y;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_UNIT_Y_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_UNIT_Y_get) 

static bool js_cc_Vec2_ANCHOR_MIDDLE_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ANCHOR_MIDDLE;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ANCHOR_MIDDLE_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ANCHOR_MIDDLE_get) 

static bool js_cc_Vec2_ANCHOR_BOTTOM_LEFT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ANCHOR_BOTTOM_LEFT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ANCHOR_BOTTOM_LEFT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ANCHOR_BOTTOM_LEFT_get) 

static bool js_cc_Vec2_ANCHOR_TOP_LEFT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ANCHOR_TOP_LEFT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ANCHOR_TOP_LEFT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ANCHOR_TOP_LEFT_get) 

static bool js_cc_Vec2_ANCHOR_BOTTOM_RIGHT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ANCHOR_BOTTOM_RIGHT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ANCHOR_BOTTOM_RIGHT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ANCHOR_BOTTOM_RIGHT_get) 

static bool js_cc_Vec2_ANCHOR_TOP_RIGHT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ANCHOR_TOP_RIGHT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ANCHOR_TOP_RIGHT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ANCHOR_TOP_RIGHT_get) 

static bool js_cc_Vec2_ANCHOR_MIDDLE_RIGHT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ANCHOR_MIDDLE_RIGHT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ANCHOR_MIDDLE_RIGHT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ANCHOR_MIDDLE_RIGHT_get) 

static bool js_cc_Vec2_ANCHOR_MIDDLE_LEFT_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ANCHOR_MIDDLE_LEFT;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ANCHOR_MIDDLE_LEFT_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ANCHOR_MIDDLE_LEFT_get) 

static bool js_cc_Vec2_ANCHOR_MIDDLE_TOP_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ANCHOR_MIDDLE_TOP;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ANCHOR_MIDDLE_TOP_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ANCHOR_MIDDLE_TOP_get) 

static bool js_cc_Vec2_ANCHOR_MIDDLE_BOTTOM_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Vec2 result;
    
    result = cc::Vec2::ANCHOR_MIDDLE_BOTTOM;
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Vec2_ANCHOR_MIDDLE_BOTTOM_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Vec2_ANCHOR_MIDDLE_BOTTOM_get) 

bool js_register_cc_Vec2(se::Object* obj) {
    auto* cls = se::Class::create("Vec2", obj, nullptr, _SE(js_new_Vec2)); 
    
    cls->defineProperty("x", _SE(js_cc_Vec2_x_get), _SE(js_cc_Vec2_x_set)); 
    cls->defineProperty("y", _SE(js_cc_Vec2_y_get), _SE(js_cc_Vec2_y_set)); 
    
    cls->defineFunction("isZero", _SE(js_cc_Vec2_isZero)); 
    cls->defineFunction("isOne", _SE(js_cc_Vec2_isOne)); 
    cls->defineFunction("distance", _SE(js_cc_Vec2_distance)); 
    cls->defineFunction("distanceSquared", _SE(js_cc_Vec2_distanceSquared)); 
    cls->defineFunction("length", _SE(js_cc_Vec2_length)); 
    cls->defineFunction("lengthSquared", _SE(js_cc_Vec2_lengthSquared)); 
    cls->defineFunction("negate", _SE(js_cc_Vec2_negate)); 
    cls->defineFunction("normalize", _SE(js_cc_Vec2_normalize)); 
    cls->defineFunction("getNormalized", _SE(js_cc_Vec2_getNormalized)); 
    cls->defineFunction("scale", _SE(js_cc_Vec2_scale)); 
    cls->defineFunction("set", _SE(js_cc_Vec2_set)); 
    cls->defineFunction("setZero", _SE(js_cc_Vec2_setZero)); 
    cls->defineFunction("smooth", _SE(js_cc_Vec2_smooth)); 
    cls->defineFunction("setPoint", _SE(js_cc_Vec2_setPoint)); 
    cls->defineFunction("equals", _SE(js_cc_Vec2_equals)); 
    cls->defineFunction("fuzzyEquals", _SE(js_cc_Vec2_fuzzyEquals)); 
    cls->defineFunction("getLength", _SE(js_cc_Vec2_getLength)); 
    cls->defineFunction("getLengthSq", _SE(js_cc_Vec2_getLengthSq)); 
    cls->defineFunction("getDistanceSq", _SE(js_cc_Vec2_getDistanceSq)); 
    cls->defineFunction("getDistance", _SE(js_cc_Vec2_getDistance)); 
    cls->defineFunction("getAngle", _SE(js_cc_Vec2_getAngle)); 
    cls->defineFunction("cross", _SE(js_cc_Vec2_cross)); 
    cls->defineFunction("getPerp", _SE(js_cc_Vec2_getPerp)); 
    cls->defineFunction("getMidpoint", _SE(js_cc_Vec2_getMidpoint)); 
    cls->defineFunction("getClampPoint", _SE(js_cc_Vec2_getClampPoint)); 
    cls->defineFunction("getRPerp", _SE(js_cc_Vec2_getRPerp)); 
    cls->defineFunction("project", _SE(js_cc_Vec2_project)); 
    cls->defineFunction("rotate", _SE(js_cc_Vec2_rotate)); 
    cls->defineFunction("unrotate", _SE(js_cc_Vec2_unrotate)); 
    cls->defineFunction("lerp", _SE(js_cc_Vec2_lerp)); 
    cls->defineFunction("rotateByAngle", _SE(js_cc_Vec2_rotateByAngle)); 
    
    cls->defineStaticProperty("ZERO", _SE(js_cc_Vec2_ZERO_get), nullptr); 
    cls->defineStaticProperty("ONE", _SE(js_cc_Vec2_ONE_get), nullptr); 
    cls->defineStaticProperty("UNIT_X", _SE(js_cc_Vec2_UNIT_X_get), nullptr); 
    cls->defineStaticProperty("UNIT_Y", _SE(js_cc_Vec2_UNIT_Y_get), nullptr); 
    cls->defineStaticProperty("ANCHOR_MIDDLE", _SE(js_cc_Vec2_ANCHOR_MIDDLE_get), nullptr); 
    cls->defineStaticProperty("ANCHOR_BOTTOM_LEFT", _SE(js_cc_Vec2_ANCHOR_BOTTOM_LEFT_get), nullptr); 
    cls->defineStaticProperty("ANCHOR_TOP_LEFT", _SE(js_cc_Vec2_ANCHOR_TOP_LEFT_get), nullptr); 
    cls->defineStaticProperty("ANCHOR_BOTTOM_RIGHT", _SE(js_cc_Vec2_ANCHOR_BOTTOM_RIGHT_get), nullptr); 
    cls->defineStaticProperty("ANCHOR_TOP_RIGHT", _SE(js_cc_Vec2_ANCHOR_TOP_RIGHT_get), nullptr); 
    cls->defineStaticProperty("ANCHOR_MIDDLE_RIGHT", _SE(js_cc_Vec2_ANCHOR_MIDDLE_RIGHT_get), nullptr); 
    cls->defineStaticProperty("ANCHOR_MIDDLE_LEFT", _SE(js_cc_Vec2_ANCHOR_MIDDLE_LEFT_get), nullptr); 
    cls->defineStaticProperty("ANCHOR_MIDDLE_TOP", _SE(js_cc_Vec2_ANCHOR_MIDDLE_TOP_get), nullptr); 
    cls->defineStaticProperty("ANCHOR_MIDDLE_BOTTOM", _SE(js_cc_Vec2_ANCHOR_MIDDLE_BOTTOM_get), nullptr); 
    
    cls->defineStaticFunction("angle", _SE(js_cc_Vec2_angle_static)); 
    cls->defineStaticFunction("add", _SE(js_cc_Vec2_add_static)); 
    cls->defineStaticFunction("clamp", _SE(js_cc_Vec2_clamp_static)); 
    cls->defineStaticFunction("dot", _SE(js_cc_Vec2_dot_static)); 
    cls->defineStaticFunction("subtract", _SE(js_cc_Vec2_subtract_static)); 
    cls->defineStaticFunction("forAngle", _SE(js_cc_Vec2_forAngle_static)); 
    cls->defineStaticFunction("isLineIntersect", _SE(js_cc_Vec2_isLineIntersect_static)); 
    cls->defineStaticFunction("isLineOverlap", _SE(js_cc_Vec2_isLineOverlap_static)); 
    cls->defineStaticFunction("isLineParallel", _SE(js_cc_Vec2_isLineParallel_static)); 
    cls->defineStaticFunction("isSegmentOverlap", _SE(js_cc_Vec2_isSegmentOverlap_static)); 
    cls->defineStaticFunction("isSegmentIntersect", _SE(js_cc_Vec2_isSegmentIntersect_static)); 
    cls->defineStaticFunction("getIntersectPoint", _SE(js_cc_Vec2_getIntersectPoint_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Vec2));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Vec2>(cls);
    
    __jsb_cc_Vec2_proto = cls->getProto();
    __jsb_cc_Vec2_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Color_class = nullptr;
se::Object* __jsb_cc_Color_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Color) 

static bool js_cc_Color_r_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Color *arg1 = (cc::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->r, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_r_set,2,SWIGTYPE_uint8_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Color_r_set) 

static bool js_cc_Color_r_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Color *arg1 = (cc::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->r, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Color_r_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->r, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Color_r_get) 

static bool js_cc_Color_g_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Color *arg1 = (cc::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->g, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_g_set,2,SWIGTYPE_uint8_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Color_g_set) 

static bool js_cc_Color_g_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Color *arg1 = (cc::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->g, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Color_g_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->g, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Color_g_get) 

static bool js_cc_Color_b_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Color *arg1 = (cc::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->b, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_b_set,2,SWIGTYPE_uint8_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Color_b_set) 

static bool js_cc_Color_b_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Color *arg1 = (cc::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->b, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Color_b_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->b, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Color_b_get) 

static bool js_cc_Color_a_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Color *arg1 = (cc::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->a, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_a_set,2,SWIGTYPE_uint8_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Color_a_set) 

static bool js_cc_Color_a_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Color *arg1 = (cc::Color *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->a, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Color_a_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->a, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Color_a_get) 

static bool js_new_cc_Color__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Color *result;
    result = (cc::Color *)new cc::Color();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Color__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    uint8_t arg1 ;
    uint8_t arg2 ;
    uint8_t arg3 ;
    uint8_t arg4 ;
    cc::Color *result;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Color,1,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Color,2,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Color,3,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Color,4,SWIGTYPE_uint8_t"); 
    
    result = (cc::Color *)new cc::Color(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Color__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    uint8_t *arg1 = (uint8_t *) NULL ;
    cc::Color *result;
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Color,1,SWIGTYPE_p_uint8_t"); 
    result = (cc::Color *)new cc::Color((uint8_t const *)arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Color__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    uint32_t arg1 ;
    cc::Color *result;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Color,1,SWIGTYPE_uint32_t"); 
    
    result = (cc::Color *)new cc::Color(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Color__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Color *arg1 = 0 ;
    cc::Color *arg2 = 0 ;
    cc::Color temp1 ;
    cc::Color temp2 ;
    cc::Color *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Color,1,SWIGTYPE_p_cc__Color");
    arg1 = &temp1;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Color,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    result = (cc::Color *)new cc::Color((cc::Color const &)*arg1,(cc::Color const &)*arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Color__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Color *arg1 = 0 ;
    cc::Color temp1 ;
    cc::Color *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Color,1,SWIGTYPE_p_cc__Color");
    arg1 = &temp1;
    
    result = (cc::Color *)new cc::Color((cc::Color const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Color(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_Color__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 4) {
        ret = js_new_cc_Color__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_Color__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_Color__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_Color__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_Color__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Color");
    return false;
}
SE_BIND_CTOR(js_new_Color, __jsb_cc_Color_class, js_delete_cc_Color)

static bool js_cc_Color_set__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Color *arg1 = (cc::Color *) NULL ;
    uint8_t arg2 ;
    uint8_t arg3 ;
    uint8_t arg4 ;
    uint8_t arg5 ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_set,2,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_set,3,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_set,4,SWIGTYPE_uint8_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[3], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_set,5,SWIGTYPE_uint8_t"); 
    
    (arg1)->set(arg2,arg3,arg4,arg5);
    
    
    return true;
}

static bool js_cc_Color_set__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Color *arg1 = (cc::Color *) NULL ;
    uint8_t *arg2 = (uint8_t *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_set,2,SWIGTYPE_p_uint8_t"); 
    (arg1)->set((uint8_t const *)arg2);
    
    
    return true;
}

static bool js_cc_Color_set__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Color *arg1 = (cc::Color *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_set,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->set(arg2);
    
    
    return true;
}

static bool js_cc_Color_set__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Color *arg1 = (cc::Color *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_set,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    (arg1)->set((cc::Color const &)*arg2);
    
    
    return true;
}

static bool js_cc_Color_set__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::Color *arg1 = (cc::Color *) NULL ;
    cc::Color *arg2 = 0 ;
    cc::Color *arg3 = 0 ;
    cc::Color temp2 ;
    cc::Color temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_set,2,SWIGTYPE_p_cc__Color");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Color_set,3,SWIGTYPE_p_cc__Color");
    arg3 = &temp3;
    
    (arg1)->set((cc::Color const &)*arg2,(cc::Color const &)*arg3);
    
    
    return true;
}

static bool js_cc_Color_set(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_Color_set__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Color_set__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Color_set__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_Color_set__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_Color_set__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_Color_set) 

static bool js_cc_Color_toVec4(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Color *arg1 = (cc::Color *) NULL ;
    cc::Vec4 result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Color>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::Color const *)arg1)->toVec4();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Color_toVec4, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Color_toVec4) 

static bool js_delete_cc_Color(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Color) 

bool js_register_cc_Color(se::Object* obj) {
    auto* cls = se::Class::create("Color", obj, nullptr, _SE(js_new_Color)); 
    
    cls->defineProperty("r", _SE(js_cc_Color_r_get), _SE(js_cc_Color_r_set)); 
    cls->defineProperty("g", _SE(js_cc_Color_g_get), _SE(js_cc_Color_g_set)); 
    cls->defineProperty("b", _SE(js_cc_Color_b_get), _SE(js_cc_Color_b_set)); 
    cls->defineProperty("a", _SE(js_cc_Color_a_get), _SE(js_cc_Color_a_set)); 
    
    cls->defineFunction("set", _SE(js_cc_Color_set)); 
    cls->defineFunction("toVec4", _SE(js_cc_Color_toVec4)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Color));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Color>(cls);
    
    __jsb_cc_Color_proto = cls->getProto();
    __jsb_cc_Color_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

#if CC_USE_DEBUG_RENDERER

se::Class* __jsb_cc_DebugTextInfo_class = nullptr;
se::Object* __jsb_cc_DebugTextInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_DebugTextInfo) 

// js_ctor
static bool js_new_cc_DebugTextInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::DebugTextInfo *result;
    result = (cc::DebugTextInfo *)new cc::DebugTextInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_DebugTextInfo, __jsb_cc_DebugTextInfo_class, js_delete_cc_DebugTextInfo)

static bool js_cc_DebugTextInfo_color_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->color, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugTextInfo_color_set,2,SWIGTYPE_cc__Color"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugTextInfo_color_set) 

static bool js_cc_DebugTextInfo_color_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->color, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DebugTextInfo_color_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->color, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugTextInfo_color_get) 

static bool js_cc_DebugTextInfo_bold_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->bold);
    SE_PRECONDITION2(ok, false, "DebugTextInfo_bold_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugTextInfo_bold_set) 

static bool js_cc_DebugTextInfo_bold_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->bold, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugTextInfo_bold_get) 

static bool js_cc_DebugTextInfo_italic_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->italic);
    SE_PRECONDITION2(ok, false, "DebugTextInfo_italic_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugTextInfo_italic_set) 

static bool js_cc_DebugTextInfo_italic_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->italic, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugTextInfo_italic_get) 

static bool js_cc_DebugTextInfo_shadow_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg1->shadow);
    SE_PRECONDITION2(ok, false, "DebugTextInfo_shadow_set,2,SWIGTYPE_bool"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugTextInfo_shadow_set) 

static bool js_cc_DebugTextInfo_shadow_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 5
    ok &= nativevalue_to_se(arg1->shadow, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugTextInfo_shadow_get) 

static bool js_cc_DebugTextInfo_shadowThickness_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->shadowThickness, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugTextInfo_shadowThickness_set,2,SWIGTYPE_uint32_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugTextInfo_shadowThickness_set) 

static bool js_cc_DebugTextInfo_shadowThickness_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->shadowThickness, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DebugTextInfo_shadowThickness_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shadowThickness, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugTextInfo_shadowThickness_get) 

static bool js_cc_DebugTextInfo_shadowColor_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->shadowColor, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugTextInfo_shadowColor_set,2,SWIGTYPE_cc__Color"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugTextInfo_shadowColor_set) 

static bool js_cc_DebugTextInfo_shadowColor_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->shadowColor, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DebugTextInfo_shadowColor_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->shadowColor, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugTextInfo_shadowColor_get) 

static bool js_cc_DebugTextInfo_scale_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->scale, nullptr);
    SE_PRECONDITION2(ok, false, "DebugTextInfo_scale_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_DebugTextInfo_scale_set) 

static bool js_cc_DebugTextInfo_scale_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::DebugTextInfo *arg1 = (cc::DebugTextInfo *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugTextInfo>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->scale, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_DebugTextInfo_scale_get) 

static bool js_delete_cc_DebugTextInfo(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_DebugTextInfo) 

template<>
bool sevalue_to_native(const se::Value &from, cc::DebugTextInfo * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::DebugTextInfo*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("color", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->color), ctx);
    }
    
    
    json->getProperty("bold", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->bold), ctx);
    }
    
    
    json->getProperty("italic", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->italic), ctx);
    }
    
    
    json->getProperty("shadow", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shadow), ctx);
    }
    
    
    json->getProperty("shadowThickness", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shadowThickness), ctx);
    }
    
    
    json->getProperty("shadowColor", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->shadowColor), ctx);
    }
    
    
    json->getProperty("scale", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->scale), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_DebugTextInfo(se::Object* obj) {
    auto* cls = se::Class::create("DebugTextInfo", obj, nullptr, _SE(js_new_cc_DebugTextInfo)); 
    
    cls->defineProperty("color", _SE(js_cc_DebugTextInfo_color_get), _SE(js_cc_DebugTextInfo_color_set)); 
    cls->defineProperty("bold", _SE(js_cc_DebugTextInfo_bold_get), _SE(js_cc_DebugTextInfo_bold_set)); 
    cls->defineProperty("italic", _SE(js_cc_DebugTextInfo_italic_get), _SE(js_cc_DebugTextInfo_italic_set)); 
    cls->defineProperty("shadow", _SE(js_cc_DebugTextInfo_shadow_get), _SE(js_cc_DebugTextInfo_shadow_set)); 
    cls->defineProperty("shadowThickness", _SE(js_cc_DebugTextInfo_shadowThickness_get), _SE(js_cc_DebugTextInfo_shadowThickness_set)); 
    cls->defineProperty("shadowColor", _SE(js_cc_DebugTextInfo_shadowColor_get), _SE(js_cc_DebugTextInfo_shadowColor_set)); 
    cls->defineProperty("scale", _SE(js_cc_DebugTextInfo_scale_get), _SE(js_cc_DebugTextInfo_scale_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_DebugTextInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::DebugTextInfo>(cls);
    
    __jsb_cc_DebugTextInfo_proto = cls->getProto();
    __jsb_cc_DebugTextInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

#endif // CC_USE_DEBUG_RENDERER
#if CC_USE_DEBUG_RENDERER

se::Class* __jsb_cc_DebugRenderer_class = nullptr;
se::Object* __jsb_cc_DebugRenderer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_DebugRenderer) 

static bool js_cc_DebugRenderer_getInstance_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::DebugRenderer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::DebugRenderer *)cc::DebugRenderer::getInstance();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "DebugRenderer_getInstance, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_DebugRenderer_getInstance_static) 

// js_ctor
static bool js_new_cc_DebugRenderer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::DebugRenderer *result;
    result = (cc::DebugRenderer *)new cc::DebugRenderer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_DebugRenderer, __jsb_cc_DebugRenderer_class, js_delete_cc_DebugRenderer)

static bool js_delete_cc_DebugRenderer(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_DebugRenderer) 

static bool js_cc_DebugRenderer_addText__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::DebugRenderer *arg1 = (cc::DebugRenderer *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    ccstd::string temp2 ;
    cc::Vec2 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugRenderer_addText,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugRenderer_addText,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    (arg1)->addText((ccstd::string const &)*arg2,(cc::Vec2 const &)*arg3);
    
    
    return true;
}

static bool js_cc_DebugRenderer_addText__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::DebugRenderer *arg1 = (cc::DebugRenderer *) NULL ;
    ccstd::string *arg2 = 0 ;
    cc::Vec2 *arg3 = 0 ;
    cc::DebugTextInfo *arg4 = 0 ;
    ccstd::string temp2 ;
    cc::Vec2 temp3 ;
    cc::DebugTextInfo temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::DebugRenderer>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugRenderer_addText,2,SWIGTYPE_p_ccstd__string");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugRenderer_addText,3,SWIGTYPE_p_cc__Vec2");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "DebugRenderer_addText,4,SWIGTYPE_p_cc__DebugTextInfo");
    arg4 = &temp4;
    
    (arg1)->addText((ccstd::string const &)*arg2,(cc::Vec2 const &)*arg3,(cc::DebugTextInfo const &)*arg4);
    
    
    return true;
}

static bool js_cc_DebugRenderer_addText(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_DebugRenderer_addText__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_DebugRenderer_addText__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_DebugRenderer_addText) 

bool js_register_cc_DebugRenderer(se::Object* obj) {
    auto* cls = se::Class::create("DebugRenderer", obj, nullptr, _SE(js_new_cc_DebugRenderer)); 
    
    
    cls->defineFunction("addText", _SE(js_cc_DebugRenderer_addText)); 
    
    
    cls->defineStaticFunction("getInstance", _SE(js_cc_DebugRenderer_getInstance_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_DebugRenderer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::DebugRenderer>(cls);
    
    __jsb_cc_DebugRenderer_proto = cls->getProto();
    __jsb_cc_DebugRenderer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

#endif // CC_USE_DEBUG_RENDERER



bool register_all_engine(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("jsb", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("jsb", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_CCObject(ns); 
    js_register_cc_JSBNativeDataHolder(ns); 
    js_register_cc_ICanvasGradient(ns); 
    js_register_cc_ICanvasRenderingContext2D(ns); 
    js_register_cc_CanvasGradient(ns); 
    js_register_cc_CanvasRenderingContext2D(ns); 
    js_register_cc_Device(ns); 
    js_register_cc_FileUtils(ns); 
    js_register_cc_SAXParser(ns); 
    js_register_cc_Vec2(ns); 
    js_register_cc_Color(ns); 
#if CC_USE_DEBUG_RENDERER
    js_register_cc_DebugTextInfo(ns); 
#endif // CC_USE_DEBUG_RENDERER
#if CC_USE_DEBUG_RENDERER
    js_register_cc_DebugRenderer(ns); 
#endif // CC_USE_DEBUG_RENDERER
    
    /* Register global variables & global functions */
    
    
    
    return true;
}

// clang-format on
