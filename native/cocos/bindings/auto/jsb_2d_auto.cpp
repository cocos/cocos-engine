// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif


#define SWIG_STD_MOVE(OBJ) std::move(OBJ)


#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_2d_auto.h"
#include "bindings/auto/jsb_scene_auto.h"
#include "bindings/auto/jsb_gfx_auto.h"
#include "bindings/auto/jsb_assets_auto.h"


#define cc_UIMeshBuffer_vData_get(self_) self_->getVData()
#define cc_UIMeshBuffer_vData_set(self_, val_) self_->setVData(val_)
  

#define cc_UIMeshBuffer_iData_get(self_) self_->getIData()
#define cc_UIMeshBuffer_iData_set(self_, val_) self_->setIData(val_)
  

#define cc_RenderDrawInfo_bufferId_get(self_) self_->getBufferId()
#define cc_RenderDrawInfo_bufferId_set(self_, val_) self_->setBufferId(val_)
  

#define cc_RenderDrawInfo_accId_get(self_) self_->getAccId()
#define cc_RenderDrawInfo_accId_set(self_, val_) self_->setAccId(val_)
  

#define cc_RenderDrawInfo_vertexOffset_get(self_) self_->getVertexOffset()
#define cc_RenderDrawInfo_vertexOffset_set(self_, val_) self_->setVertexOffset(val_)
  

#define cc_RenderDrawInfo_indexOffset_get(self_) self_->getIndexOffset()
#define cc_RenderDrawInfo_indexOffset_set(self_, val_) self_->setIndexOffset(val_)
  

#define cc_RenderDrawInfo_vbCount_get(self_) self_->getVbCount()
#define cc_RenderDrawInfo_vbCount_set(self_, val_) self_->setVbCount(val_)
  

#define cc_RenderDrawInfo_ibCount_get(self_) self_->getIbCount()
#define cc_RenderDrawInfo_ibCount_set(self_, val_) self_->setIbCount(val_)
  

#define cc_RenderDrawInfo_vertDirty_get(self_) self_->getVertDirty()
#define cc_RenderDrawInfo_vertDirty_set(self_, val_) self_->setVertDirty(val_)
  

#define cc_RenderDrawInfo_dataHash_get(self_) self_->getDataHash()
#define cc_RenderDrawInfo_dataHash_set(self_, val_) self_->setDataHash(val_)
  

#define cc_RenderDrawInfo_isMeshBuffer_get(self_) self_->getIsMeshBuffer()
#define cc_RenderDrawInfo_isMeshBuffer_set(self_, val_) self_->setIsMeshBuffer(val_)
  

#define cc_RenderDrawInfo_vbBuffer_get(self_) self_->getVbBuffer()
#define cc_RenderDrawInfo_vbBuffer_set(self_, val_) self_->setVbBuffer(val_)
  

#define cc_RenderDrawInfo_ibBuffer_get(self_) self_->getIbBuffer()
#define cc_RenderDrawInfo_ibBuffer_set(self_, val_) self_->setIbBuffer(val_)
  

#define cc_RenderDrawInfo_vDataBuffer_get(self_) self_->getVDataBuffer()
#define cc_RenderDrawInfo_vDataBuffer_set(self_, val_) self_->setVDataBuffer(val_)
  

#define cc_RenderDrawInfo_iDataBuffer_get(self_) self_->getIDataBuffer()
#define cc_RenderDrawInfo_iDataBuffer_set(self_, val_) self_->setIDataBuffer(val_)
  

#define cc_RenderDrawInfo_material_get(self_) self_->getMaterial()
#define cc_RenderDrawInfo_material_set(self_, val_) self_->setMaterial(val_)
  

#define cc_RenderDrawInfo_texture_get(self_) self_->getTexture()
#define cc_RenderDrawInfo_texture_set(self_, val_) self_->setTexture(val_)
  

#define cc_RenderDrawInfo_sampler_get(self_) self_->getSampler()
#define cc_RenderDrawInfo_sampler_set(self_, val_) self_->setSampler(val_)
  

#define cc_RenderDrawInfo_model_get(self_) self_->getModel()
#define cc_RenderDrawInfo_model_set(self_, val_) self_->setModel(val_)
  

#define cc_RenderDrawInfo_drawInfoType_get(self_) self_->getDrawInfoType()
#define cc_RenderDrawInfo_drawInfoType_set(self_, val_) self_->setDrawInfoType(val_)
  

#define cc_RenderDrawInfo_subNode_get(self_) self_->getSubNode()
#define cc_RenderDrawInfo_subNode_set(self_, val_) self_->setSubNode(val_)
  

#define cc_RenderDrawInfo_stride_get(self_) self_->getStride()
#define cc_RenderDrawInfo_stride_set(self_, val_) self_->setStride(val_)
  

#define cc_RenderEntity_node_get(self_) self_->getNode()
#define cc_RenderEntity_node_set(self_, val_) self_->setNode(val_)
  

#define cc_RenderEntity_renderTransform_get(self_) self_->getRenderTransform()
#define cc_RenderEntity_renderTransform_set(self_, val_) self_->setRenderTransform(val_)
  

#define cc_RenderEntity_staticDrawInfoSize_get(self_) self_->getStaticDrawInfoSize()
#define cc_RenderEntity_staticDrawInfoSize_set(self_, val_) self_->setStaticDrawInfoSize(val_)
  

#define cc_RenderEntity_stencilStage_get(self_) self_->getStencilStage()
#define cc_RenderEntity_stencilStage_set(self_, val_) self_->setStencilStage(val_)
  


se::Class* __jsb_cc_MeshBufferLayout_class = nullptr;
se::Object* __jsb_cc_MeshBufferLayout_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_MeshBufferLayout) 

static bool js_cc_MeshBufferLayout_byteOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MeshBufferLayout *arg1 = (cc::MeshBufferLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MeshBufferLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->byteOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MeshBufferLayout_byteOffset_set) 

static bool js_cc_MeshBufferLayout_byteOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MeshBufferLayout *arg1 = (cc::MeshBufferLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MeshBufferLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->byteOffset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MeshBufferLayout_byteOffset_get) 

static bool js_cc_MeshBufferLayout_vertexOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MeshBufferLayout *arg1 = (cc::MeshBufferLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MeshBufferLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vertexOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MeshBufferLayout_vertexOffset_set) 

static bool js_cc_MeshBufferLayout_vertexOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MeshBufferLayout *arg1 = (cc::MeshBufferLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MeshBufferLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vertexOffset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MeshBufferLayout_vertexOffset_get) 

static bool js_cc_MeshBufferLayout_indexOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MeshBufferLayout *arg1 = (cc::MeshBufferLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MeshBufferLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->indexOffset, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MeshBufferLayout_indexOffset_set) 

static bool js_cc_MeshBufferLayout_indexOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MeshBufferLayout *arg1 = (cc::MeshBufferLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MeshBufferLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->indexOffset, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MeshBufferLayout_indexOffset_get) 

static bool js_cc_MeshBufferLayout_dirtyMark_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::MeshBufferLayout *arg1 = (cc::MeshBufferLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MeshBufferLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->dirtyMark, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_MeshBufferLayout_dirtyMark_set) 

static bool js_cc_MeshBufferLayout_dirtyMark_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::MeshBufferLayout *arg1 = (cc::MeshBufferLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::MeshBufferLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->dirtyMark, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_MeshBufferLayout_dirtyMark_get) 

static bool js_new_cc_MeshBufferLayout(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::MeshBufferLayout *result;
    result = (cc::MeshBufferLayout *)new cc::MeshBufferLayout();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_MeshBufferLayout, __jsb_cc_MeshBufferLayout_class, js_delete_cc_MeshBufferLayout)

static bool js_delete_cc_MeshBufferLayout(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_MeshBufferLayout) 

template<>
bool sevalue_to_native(const se::Value &from, cc::MeshBufferLayout * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::MeshBufferLayout*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("byteOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->byteOffset), ctx);
    }
    
    
    json->getProperty("vertexOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->vertexOffset), ctx);
    }
    
    
    json->getProperty("indexOffset", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->indexOffset), ctx);
    }
    
    
    json->getProperty("dirtyMark", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->dirtyMark), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_MeshBufferLayout(se::Object* obj) {
    auto* cls = se::Class::create("MeshBufferLayout", obj, nullptr, _SE(js_new_cc_MeshBufferLayout)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("byteOffset", _SE(js_cc_MeshBufferLayout_byteOffset_get), _SE(js_cc_MeshBufferLayout_byteOffset_set)); 
    cls->defineProperty("vertexOffset", _SE(js_cc_MeshBufferLayout_vertexOffset_get), _SE(js_cc_MeshBufferLayout_vertexOffset_set)); 
    cls->defineProperty("indexOffset", _SE(js_cc_MeshBufferLayout_indexOffset_get), _SE(js_cc_MeshBufferLayout_indexOffset_set)); 
    cls->defineProperty("dirtyMark", _SE(js_cc_MeshBufferLayout_dirtyMark_get), _SE(js_cc_MeshBufferLayout_dirtyMark_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_MeshBufferLayout));
    
    
    cls->install();
    JSBClassType::registerClass<cc::MeshBufferLayout>(cls);
    
    __jsb_cc_MeshBufferLayout_proto = cls->getProto();
    __jsb_cc_MeshBufferLayout_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_UIMeshBuffer_class = nullptr;
se::Object* __jsb_cc_UIMeshBuffer_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_UIMeshBuffer) 

static bool js_new_cc_UIMeshBuffer(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::UIMeshBuffer *result;
    result = (cc::UIMeshBuffer *)new cc::UIMeshBuffer();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_UIMeshBuffer, __jsb_cc_UIMeshBuffer_class, js_delete_cc_UIMeshBuffer)

static bool js_delete_cc_UIMeshBuffer(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_UIMeshBuffer) 

static bool js_cc_UIMeshBuffer_initialize__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    ccstd::vector< cc::gfx::Attribute > *arg2 = 0 ;
    bool arg3 ;
    ccstd::vector< cc::gfx::Attribute > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    
    ok &= sevalue_to_native(args[1], &arg3);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initialize((ccstd::vector< cc::gfx::Attribute > &&)*arg2,arg3);
    
    
    return true;
}

static bool js_cc_UIMeshBuffer_initialize__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    ccstd::vector< cc::gfx::Attribute > *arg2 = 0 ;
    ccstd::vector< cc::gfx::Attribute > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->initialize((ccstd::vector< cc::gfx::Attribute > &&)*arg2);
    
    
    return true;
}

static bool js_cc_UIMeshBuffer_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_UIMeshBuffer_initialize__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_UIMeshBuffer_initialize__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_UIMeshBuffer_initialize) 

static bool js_cc_UIMeshBuffer_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIMeshBuffer_reset) 

static bool js_cc_UIMeshBuffer_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIMeshBuffer_destroy) 

static bool js_cc_UIMeshBuffer_uploadBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    (arg1)->uploadBuffers();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIMeshBuffer_uploadBuffers) 

static bool js_cc_UIMeshBuffer_syncSharedBufferToNative(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    uint32_t *arg2 = (uint32_t *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->syncSharedBufferToNative(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIMeshBuffer_syncSharedBufferToNative) 

static bool js_cc_UIMeshBuffer_vData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    float *arg2 = (float *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_UIMeshBuffer_vData_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_UIMeshBuffer_vData_set) 

static bool js_cc_UIMeshBuffer_vData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    float *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    result = (float *)cc_UIMeshBuffer_vData_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_UIMeshBuffer_vData_get) 

static bool js_cc_UIMeshBuffer_iData_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    uint16_t *arg2 = (uint16_t *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_UIMeshBuffer_iData_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_UIMeshBuffer_iData_set) 

static bool js_cc_UIMeshBuffer_iData_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::UIMeshBuffer *arg1 = (cc::UIMeshBuffer *) NULL ;
    uint16_t *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::UIMeshBuffer>(s);
    if (nullptr == arg1) return true;
    result = (uint16_t *)cc_UIMeshBuffer_iData_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_UIMeshBuffer_iData_get) 

bool js_register_cc_UIMeshBuffer(se::Object* obj) {
    auto* cls = se::Class::create("UIMeshBuffer", obj, nullptr, _SE(js_new_cc_UIMeshBuffer)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("vData", _SE(js_cc_UIMeshBuffer_vData_get), _SE(js_cc_UIMeshBuffer_vData_set)); 
    cls->defineProperty("iData", _SE(js_cc_UIMeshBuffer_iData_get), _SE(js_cc_UIMeshBuffer_iData_set)); 
    
    cls->defineFunction("initialize", _SE(js_cc_UIMeshBuffer_initialize)); 
    cls->defineFunction("reset", _SE(js_cc_UIMeshBuffer_reset)); 
    cls->defineFunction("destroy", _SE(js_cc_UIMeshBuffer_destroy)); 
    cls->defineFunction("uploadBuffers", _SE(js_cc_UIMeshBuffer_uploadBuffers)); 
    cls->defineFunction("syncSharedBufferToNative", _SE(js_cc_UIMeshBuffer_syncSharedBufferToNative)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_UIMeshBuffer));
    
    
    cls->install();
    JSBClassType::registerClass<cc::UIMeshBuffer>(cls);
    
    __jsb_cc_UIMeshBuffer_proto = cls->getProto();
    __jsb_cc_UIMeshBuffer_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Render2dLayout_class = nullptr;
se::Object* __jsb_cc_Render2dLayout_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Render2dLayout) 

static bool js_cc_Render2dLayout_position_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Render2dLayout *arg1 = (cc::Render2dLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Render2dLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->position, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Render2dLayout_position_set) 

static bool js_cc_Render2dLayout_position_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Render2dLayout *arg1 = (cc::Render2dLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Render2dLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->position, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->position, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Render2dLayout_position_get) 

static bool js_cc_Render2dLayout_uv_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Render2dLayout *arg1 = (cc::Render2dLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Render2dLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->uv, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Render2dLayout_uv_set) 

static bool js_cc_Render2dLayout_uv_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Render2dLayout *arg1 = (cc::Render2dLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Render2dLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->uv, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uv, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Render2dLayout_uv_get) 

static bool js_cc_Render2dLayout_color_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Render2dLayout *arg1 = (cc::Render2dLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Render2dLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->color, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_Render2dLayout_color_set) 

static bool js_cc_Render2dLayout_color_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::Render2dLayout *arg1 = (cc::Render2dLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::Render2dLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->color, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->color, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_Render2dLayout_color_get) 

static bool js_new_cc_Render2dLayout(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::Render2dLayout *result;
    result = (cc::Render2dLayout *)new cc::Render2dLayout();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_Render2dLayout, __jsb_cc_Render2dLayout_class, js_delete_cc_Render2dLayout)

static bool js_delete_cc_Render2dLayout(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Render2dLayout) 

template<>
bool sevalue_to_native(const se::Value &from, cc::Render2dLayout * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::Render2dLayout*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("position", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->position), ctx);
    }
    
    
    json->getProperty("uv", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uv), ctx);
    }
    
    
    json->getProperty("color", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->color), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_Render2dLayout(se::Object* obj) {
    auto* cls = se::Class::create("Render2dLayout", obj, nullptr, _SE(js_new_cc_Render2dLayout)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("position", _SE(js_cc_Render2dLayout_position_get), _SE(js_cc_Render2dLayout_position_set)); 
    cls->defineProperty("uv", _SE(js_cc_Render2dLayout_uv_get), _SE(js_cc_Render2dLayout_uv_set)); 
    cls->defineProperty("color", _SE(js_cc_Render2dLayout_color_get), _SE(js_cc_Render2dLayout_color_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Render2dLayout));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Render2dLayout>(cls);
    
    __jsb_cc_Render2dLayout_proto = cls->getProto();
    __jsb_cc_Render2dLayout_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_LocalDSBF_class = nullptr;
se::Object* __jsb_cc_LocalDSBF_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_LocalDSBF) 

static bool js_cc_LocalDSBF_ds_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::LocalDSBF *arg1 = (cc::LocalDSBF *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::LocalDSBF>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->ds, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_LocalDSBF_ds_set) 

static bool js_cc_LocalDSBF_ds_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::LocalDSBF *arg1 = (cc::LocalDSBF *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::LocalDSBF>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->ds, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ds, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_LocalDSBF_ds_get) 

static bool js_cc_LocalDSBF_uboBuf_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::LocalDSBF *arg1 = (cc::LocalDSBF *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::LocalDSBF>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->uboBuf, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_LocalDSBF_uboBuf_set) 

static bool js_cc_LocalDSBF_uboBuf_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::LocalDSBF *arg1 = (cc::LocalDSBF *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::LocalDSBF>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->uboBuf, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->uboBuf, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_LocalDSBF_uboBuf_get) 

static bool js_new_cc_LocalDSBF(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::LocalDSBF *result;
    result = (cc::LocalDSBF *)new cc::LocalDSBF();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_LocalDSBF, __jsb_cc_LocalDSBF_class, js_delete_cc_LocalDSBF)

static bool js_delete_cc_LocalDSBF(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_LocalDSBF) 

template<>
bool sevalue_to_native(const se::Value &from, cc::LocalDSBF * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::LocalDSBF*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("ds", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->ds), ctx);
    }
    
    
    json->getProperty("uboBuf", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->uboBuf), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_LocalDSBF(se::Object* obj) {
    auto* cls = se::Class::create("LocalDSBF", obj, nullptr, _SE(js_new_cc_LocalDSBF)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("ds", _SE(js_cc_LocalDSBF_ds_get), _SE(js_cc_LocalDSBF_ds_set)); 
    cls->defineProperty("uboBuf", _SE(js_cc_LocalDSBF_uboBuf_get), _SE(js_cc_LocalDSBF_uboBuf_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_LocalDSBF));
    
    
    cls->install();
    JSBClassType::registerClass<cc::LocalDSBF>(cls);
    
    __jsb_cc_LocalDSBF_proto = cls->getProto();
    __jsb_cc_LocalDSBF_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_RenderDrawInfo_class = nullptr;
se::Object* __jsb_cc_RenderDrawInfo_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_RenderDrawInfo) 

static bool js_new_cc_RenderDrawInfo(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::RenderDrawInfo *result;
    result = (cc::RenderDrawInfo *)new cc::RenderDrawInfo();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_RenderDrawInfo, __jsb_cc_RenderDrawInfo_class, js_delete_cc_RenderDrawInfo)

static bool js_delete_cc_RenderDrawInfo(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_RenderDrawInfo) 

static bool js_cc_RenderDrawInfo_setMeshBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::UIMeshBuffer *arg2 = (cc::UIMeshBuffer *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setMeshBuffer(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_setMeshBuffer) 

static bool js_cc_RenderDrawInfo_getMeshBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::UIMeshBuffer *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::UIMeshBuffer *)((cc::RenderDrawInfo const *)arg1)->getMeshBuffer();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_getMeshBuffer) 

static bool js_cc_RenderDrawInfo_changeMeshBuffer(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    (arg1)->changeMeshBuffer();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_changeMeshBuffer) 

static bool js_cc_RenderDrawInfo_setRender2dBufferToNative(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint8_t *arg2 = (uint8_t *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setRender2dBufferToNative(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_setRender2dBufferToNative) 

static bool js_cc_RenderDrawInfo_getAttrSharedBufferForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    se::Object *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (se::Object *)((cc::RenderDrawInfo const *)arg1)->getAttrSharedBufferForJS();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_getAttrSharedBufferForJS) 

static bool js_cc_RenderDrawInfo_requestIA(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::gfx::Device *arg2 = (cc::gfx::Device *) NULL ;
    cc::gfx::InputAssembler *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::gfx::InputAssembler *)(arg1)->requestIA(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_requestIA) 

static bool js_cc_RenderDrawInfo_uploadBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    (arg1)->uploadBuffers();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_uploadBuffers) 

static bool js_cc_RenderDrawInfo_resetMeshIA(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    (arg1)->resetMeshIA();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_resetMeshIA) 

static bool js_cc_RenderDrawInfo_getLocalDes(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::gfx::DescriptorSet *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::DescriptorSet *)(arg1)->getLocalDes();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_getLocalDes) 

static bool js_cc_RenderDrawInfo_updateLocalDescriptorSet(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    cc::gfx::DescriptorSetLayout *arg3 = (cc::gfx::DescriptorSetLayout *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateLocalDescriptorSet(arg2,(cc::gfx::DescriptorSetLayout const *)arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderDrawInfo_updateLocalDescriptorSet) 

static bool js_cc_RenderDrawInfo_bufferId_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint16_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderDrawInfo_bufferId_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_bufferId_set) 

static bool js_cc_RenderDrawInfo_bufferId_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint16_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderDrawInfo_bufferId_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_bufferId_get) 

static bool js_cc_RenderDrawInfo_accId_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint16_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderDrawInfo_accId_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_accId_set) 

static bool js_cc_RenderDrawInfo_accId_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint16_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderDrawInfo_accId_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_accId_get) 

static bool js_cc_RenderDrawInfo_vertexOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderDrawInfo_vertexOffset_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_vertexOffset_set) 

static bool js_cc_RenderDrawInfo_vertexOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderDrawInfo_vertexOffset_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_vertexOffset_get) 

static bool js_cc_RenderDrawInfo_indexOffset_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderDrawInfo_indexOffset_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_indexOffset_set) 

static bool js_cc_RenderDrawInfo_indexOffset_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderDrawInfo_indexOffset_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_indexOffset_get) 

static bool js_cc_RenderDrawInfo_vbCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderDrawInfo_vbCount_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_vbCount_set) 

static bool js_cc_RenderDrawInfo_vbCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderDrawInfo_vbCount_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_vbCount_get) 

static bool js_cc_RenderDrawInfo_ibCount_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderDrawInfo_ibCount_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_ibCount_set) 

static bool js_cc_RenderDrawInfo_ibCount_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderDrawInfo_ibCount_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_ibCount_get) 

static bool js_cc_RenderDrawInfo_vertDirty_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_vertDirty_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_vertDirty_set) 

static bool js_cc_RenderDrawInfo_vertDirty_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_RenderDrawInfo_vertDirty_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_vertDirty_get) 

static bool js_cc_RenderDrawInfo_dataHash_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    ccstd::hash_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_RenderDrawInfo_dataHash_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_dataHash_set) 

static bool js_cc_RenderDrawInfo_dataHash_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    ccstd::hash_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderDrawInfo_dataHash_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_dataHash_get) 

static bool js_cc_RenderDrawInfo_isMeshBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    bool arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_isMeshBuffer_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_isMeshBuffer_set) 

static bool js_cc_RenderDrawInfo_isMeshBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (bool)cc_RenderDrawInfo_isMeshBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_isMeshBuffer_get) 

static bool js_cc_RenderDrawInfo_vbBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    float *arg2 = (float *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_vbBuffer_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_vbBuffer_set) 

static bool js_cc_RenderDrawInfo_vbBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    float *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (float *)cc_RenderDrawInfo_vbBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_vbBuffer_get) 

static bool js_cc_RenderDrawInfo_ibBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint16_t *arg2 = (uint16_t *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_ibBuffer_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_ibBuffer_set) 

static bool js_cc_RenderDrawInfo_ibBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint16_t *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (uint16_t *)cc_RenderDrawInfo_ibBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_ibBuffer_get) 

static bool js_cc_RenderDrawInfo_vDataBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    float *arg2 = (float *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_vDataBuffer_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_vDataBuffer_set) 

static bool js_cc_RenderDrawInfo_vDataBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    float *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (float *)cc_RenderDrawInfo_vDataBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_vDataBuffer_get) 

static bool js_cc_RenderDrawInfo_iDataBuffer_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint16_t *arg2 = (uint16_t *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_iDataBuffer_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_iDataBuffer_set) 

static bool js_cc_RenderDrawInfo_iDataBuffer_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint16_t *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (uint16_t *)cc_RenderDrawInfo_iDataBuffer_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_iDataBuffer_get) 

static bool js_cc_RenderDrawInfo_material_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::Material *arg2 = (cc::Material *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_material_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_material_set) 

static bool js_cc_RenderDrawInfo_material_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::Material *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Material *)cc_RenderDrawInfo_material_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_material_get) 

static bool js_cc_RenderDrawInfo_texture_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_texture_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_texture_set) 

static bool js_cc_RenderDrawInfo_texture_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::gfx::Texture *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Texture *)cc_RenderDrawInfo_texture_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_texture_get) 

static bool js_cc_RenderDrawInfo_sampler_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::gfx::Sampler *arg2 = (cc::gfx::Sampler *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_sampler_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_sampler_set) 

static bool js_cc_RenderDrawInfo_sampler_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::gfx::Sampler *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::gfx::Sampler *)cc_RenderDrawInfo_sampler_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_sampler_get) 

static bool js_cc_RenderDrawInfo_model_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_model_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_model_set) 

static bool js_cc_RenderDrawInfo_model_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::scene::Model *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Model *)cc_RenderDrawInfo_model_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_model_get) 

static bool js_cc_RenderDrawInfo_drawInfoType_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderDrawInfo_drawInfoType_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_drawInfoType_set) 

static bool js_cc_RenderDrawInfo_drawInfoType_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderDrawInfo_drawInfoType_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_drawInfoType_get) 

static bool js_cc_RenderDrawInfo_subNode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderDrawInfo_subNode_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_subNode_set) 

static bool js_cc_RenderDrawInfo_subNode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_RenderDrawInfo_subNode_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_subNode_get) 

static bool js_cc_RenderDrawInfo_stride_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint8_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderDrawInfo_stride_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderDrawInfo_stride_set) 

static bool js_cc_RenderDrawInfo_stride_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderDrawInfo *arg1 = (cc::RenderDrawInfo *) NULL ;
    uint8_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderDrawInfo>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderDrawInfo_stride_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderDrawInfo_stride_get) 

bool js_register_cc_RenderDrawInfo(se::Object* obj) {
    auto* cls = se::Class::create("RenderDrawInfo", obj, nullptr, _SE(js_new_cc_RenderDrawInfo)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("bufferId", _SE(js_cc_RenderDrawInfo_bufferId_get), _SE(js_cc_RenderDrawInfo_bufferId_set)); 
    cls->defineProperty("accId", _SE(js_cc_RenderDrawInfo_accId_get), _SE(js_cc_RenderDrawInfo_accId_set)); 
    cls->defineProperty("vertexOffset", _SE(js_cc_RenderDrawInfo_vertexOffset_get), _SE(js_cc_RenderDrawInfo_vertexOffset_set)); 
    cls->defineProperty("indexOffset", _SE(js_cc_RenderDrawInfo_indexOffset_get), _SE(js_cc_RenderDrawInfo_indexOffset_set)); 
    cls->defineProperty("vbCount", _SE(js_cc_RenderDrawInfo_vbCount_get), _SE(js_cc_RenderDrawInfo_vbCount_set)); 
    cls->defineProperty("ibCount", _SE(js_cc_RenderDrawInfo_ibCount_get), _SE(js_cc_RenderDrawInfo_ibCount_set)); 
    cls->defineProperty("vertDirty", _SE(js_cc_RenderDrawInfo_vertDirty_get), _SE(js_cc_RenderDrawInfo_vertDirty_set)); 
    cls->defineProperty("dataHash", _SE(js_cc_RenderDrawInfo_dataHash_get), _SE(js_cc_RenderDrawInfo_dataHash_set)); 
    cls->defineProperty("isMeshBuffer", _SE(js_cc_RenderDrawInfo_isMeshBuffer_get), _SE(js_cc_RenderDrawInfo_isMeshBuffer_set)); 
    cls->defineProperty("vbBuffer", _SE(js_cc_RenderDrawInfo_vbBuffer_get), _SE(js_cc_RenderDrawInfo_vbBuffer_set)); 
    cls->defineProperty("ibBuffer", _SE(js_cc_RenderDrawInfo_ibBuffer_get), _SE(js_cc_RenderDrawInfo_ibBuffer_set)); 
    cls->defineProperty("vDataBuffer", _SE(js_cc_RenderDrawInfo_vDataBuffer_get), _SE(js_cc_RenderDrawInfo_vDataBuffer_set)); 
    cls->defineProperty("iDataBuffer", _SE(js_cc_RenderDrawInfo_iDataBuffer_get), _SE(js_cc_RenderDrawInfo_iDataBuffer_set)); 
    cls->defineProperty("material", _SE(js_cc_RenderDrawInfo_material_get), _SE(js_cc_RenderDrawInfo_material_set)); 
    cls->defineProperty("texture", _SE(js_cc_RenderDrawInfo_texture_get), _SE(js_cc_RenderDrawInfo_texture_set)); 
    cls->defineProperty("sampler", _SE(js_cc_RenderDrawInfo_sampler_get), _SE(js_cc_RenderDrawInfo_sampler_set)); 
    cls->defineProperty("model", _SE(js_cc_RenderDrawInfo_model_get), _SE(js_cc_RenderDrawInfo_model_set)); 
    cls->defineProperty("drawInfoType", _SE(js_cc_RenderDrawInfo_drawInfoType_get), _SE(js_cc_RenderDrawInfo_drawInfoType_set)); 
    cls->defineProperty("subNode", _SE(js_cc_RenderDrawInfo_subNode_get), _SE(js_cc_RenderDrawInfo_subNode_set)); 
    cls->defineProperty("stride", _SE(js_cc_RenderDrawInfo_stride_get), _SE(js_cc_RenderDrawInfo_stride_set)); 
    
    cls->defineFunction("setMeshBuffer", _SE(js_cc_RenderDrawInfo_setMeshBuffer)); 
    cls->defineFunction("getMeshBuffer", _SE(js_cc_RenderDrawInfo_getMeshBuffer)); 
    cls->defineFunction("changeMeshBuffer", _SE(js_cc_RenderDrawInfo_changeMeshBuffer)); 
    cls->defineFunction("setRender2dBufferToNative", _SE(js_cc_RenderDrawInfo_setRender2dBufferToNative)); 
    cls->defineFunction("getAttrSharedBufferForJS", _SE(js_cc_RenderDrawInfo_getAttrSharedBufferForJS)); 
    cls->defineFunction("requestIA", _SE(js_cc_RenderDrawInfo_requestIA)); 
    cls->defineFunction("uploadBuffers", _SE(js_cc_RenderDrawInfo_uploadBuffers)); 
    cls->defineFunction("resetMeshIA", _SE(js_cc_RenderDrawInfo_resetMeshIA)); 
    cls->defineFunction("getLocalDes", _SE(js_cc_RenderDrawInfo_getLocalDes)); 
    cls->defineFunction("updateLocalDescriptorSet", _SE(js_cc_RenderDrawInfo_updateLocalDescriptorSet)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_RenderDrawInfo));
    
    
    cls->install();
    JSBClassType::registerClass<cc::RenderDrawInfo>(cls);
    
    __jsb_cc_RenderDrawInfo_proto = cls->getProto();
    __jsb_cc_RenderDrawInfo_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_EntityAttrLayout_class = nullptr;
se::Object* __jsb_cc_EntityAttrLayout_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_EntityAttrLayout) 

static bool js_cc_EntityAttrLayout_localOpacity_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->localOpacity, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EntityAttrLayout_localOpacity_set) 

static bool js_cc_EntityAttrLayout_localOpacity_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->localOpacity, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EntityAttrLayout_localOpacity_get) 

static bool js_cc_EntityAttrLayout_colorR_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colorR, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EntityAttrLayout_colorR_set) 

static bool js_cc_EntityAttrLayout_colorR_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colorR, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EntityAttrLayout_colorR_get) 

static bool js_cc_EntityAttrLayout_colorG_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colorG, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EntityAttrLayout_colorG_set) 

static bool js_cc_EntityAttrLayout_colorG_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colorG, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EntityAttrLayout_colorG_get) 

static bool js_cc_EntityAttrLayout_colorB_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colorB, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EntityAttrLayout_colorB_set) 

static bool js_cc_EntityAttrLayout_colorB_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colorB, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EntityAttrLayout_colorB_get) 

static bool js_cc_EntityAttrLayout_colorA_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colorA, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EntityAttrLayout_colorA_set) 

static bool js_cc_EntityAttrLayout_colorA_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colorA, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EntityAttrLayout_colorA_get) 

static bool js_cc_EntityAttrLayout_maskMode_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->maskMode, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EntityAttrLayout_maskMode_set) 

static bool js_cc_EntityAttrLayout_maskMode_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->maskMode, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EntityAttrLayout_maskMode_get) 

static bool js_cc_EntityAttrLayout_colorDirtyBit_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->colorDirtyBit, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EntityAttrLayout_colorDirtyBit_set) 

static bool js_cc_EntityAttrLayout_colorDirtyBit_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->colorDirtyBit, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EntityAttrLayout_colorDirtyBit_get) 

static bool js_cc_EntityAttrLayout_enabledIndex_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->enabledIndex, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EntityAttrLayout_enabledIndex_set) 

static bool js_cc_EntityAttrLayout_enabledIndex_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->enabledIndex, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EntityAttrLayout_enabledIndex_get) 

static bool js_cc_EntityAttrLayout_useLocal_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->useLocal, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_EntityAttrLayout_useLocal_set) 

static bool js_cc_EntityAttrLayout_useLocal_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::EntityAttrLayout *arg1 = (cc::EntityAttrLayout *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::EntityAttrLayout>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->useLocal, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_EntityAttrLayout_useLocal_get) 

static bool js_new_cc_EntityAttrLayout(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::EntityAttrLayout *result;
    result = (cc::EntityAttrLayout *)new cc::EntityAttrLayout();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_EntityAttrLayout, __jsb_cc_EntityAttrLayout_class, js_delete_cc_EntityAttrLayout)

static bool js_delete_cc_EntityAttrLayout(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_EntityAttrLayout) 

template<>
bool sevalue_to_native(const se::Value &from, cc::EntityAttrLayout * to, se::Object *ctx)
{
    assert(from.isObject());
    se::Object *json = from.toObject();
    auto* data = reinterpret_cast<cc::EntityAttrLayout*>(json->getPrivateData());
    if (data) {
        *to = *data;
        return true;
    }
    se::Value field;
    bool ok = true;
    
    json->getProperty("localOpacity", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->localOpacity), ctx);
    }
    
    
    json->getProperty("colorR", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorR), ctx);
    }
    
    
    json->getProperty("colorG", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorG), ctx);
    }
    
    
    json->getProperty("colorB", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorB), ctx);
    }
    
    
    json->getProperty("colorA", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorA), ctx);
    }
    
    
    json->getProperty("maskMode", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->maskMode), ctx);
    }
    
    
    json->getProperty("colorDirtyBit", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->colorDirtyBit), ctx);
    }
    
    
    json->getProperty("enabledIndex", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->enabledIndex), ctx);
    }
    
    
    json->getProperty("useLocal", &field, true);
    if (!field.isNullOrUndefined()) {
        ok &= sevalue_to_native(field, &(to->useLocal), ctx);
    }
    
    
    return ok;
}


bool js_register_cc_EntityAttrLayout(se::Object* obj) {
    auto* cls = se::Class::create("EntityAttrLayout", obj, nullptr, _SE(js_new_cc_EntityAttrLayout)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("localOpacity", _SE(js_cc_EntityAttrLayout_localOpacity_get), _SE(js_cc_EntityAttrLayout_localOpacity_set)); 
    cls->defineProperty("colorR", _SE(js_cc_EntityAttrLayout_colorR_get), _SE(js_cc_EntityAttrLayout_colorR_set)); 
    cls->defineProperty("colorG", _SE(js_cc_EntityAttrLayout_colorG_get), _SE(js_cc_EntityAttrLayout_colorG_set)); 
    cls->defineProperty("colorB", _SE(js_cc_EntityAttrLayout_colorB_get), _SE(js_cc_EntityAttrLayout_colorB_set)); 
    cls->defineProperty("colorA", _SE(js_cc_EntityAttrLayout_colorA_get), _SE(js_cc_EntityAttrLayout_colorA_set)); 
    cls->defineProperty("maskMode", _SE(js_cc_EntityAttrLayout_maskMode_get), _SE(js_cc_EntityAttrLayout_maskMode_set)); 
    cls->defineProperty("colorDirtyBit", _SE(js_cc_EntityAttrLayout_colorDirtyBit_get), _SE(js_cc_EntityAttrLayout_colorDirtyBit_set)); 
    cls->defineProperty("enabledIndex", _SE(js_cc_EntityAttrLayout_enabledIndex_get), _SE(js_cc_EntityAttrLayout_enabledIndex_set)); 
    cls->defineProperty("useLocal", _SE(js_cc_EntityAttrLayout_useLocal_get), _SE(js_cc_EntityAttrLayout_useLocal_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_EntityAttrLayout));
    
    
    cls->install();
    JSBClassType::registerClass<cc::EntityAttrLayout>(cls);
    
    __jsb_cc_EntityAttrLayout_proto = cls->getProto();
    __jsb_cc_EntityAttrLayout_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_RenderEntity_class = nullptr;
se::Object* __jsb_cc_RenderEntity_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_RenderEntity) 

static bool js_new_cc_RenderEntity(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::RenderEntityType arg1 ;
    cc::RenderEntity *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::RenderEntity *)new cc::RenderEntity(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_RenderEntity, __jsb_cc_RenderEntity_class, js_delete_cc_RenderEntity)

static bool js_delete_cc_RenderEntity(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_RenderEntity) 

static bool js_cc_RenderEntity_addDynamicRenderDrawInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    cc::RenderDrawInfo *arg2 = (cc::RenderDrawInfo *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->addDynamicRenderDrawInfo(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_addDynamicRenderDrawInfo) 

static bool js_cc_RenderEntity_setDynamicRenderDrawInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    cc::RenderDrawInfo *arg2 = (cc::RenderDrawInfo *) NULL ;
    uint32_t arg3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->setDynamicRenderDrawInfo(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_setDynamicRenderDrawInfo) 

static bool js_cc_RenderEntity_removeDynamicRenderDrawInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    (arg1)->removeDynamicRenderDrawInfo();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_removeDynamicRenderDrawInfo) 

static bool js_cc_RenderEntity_clearDynamicRenderDrawInfos(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearDynamicRenderDrawInfos();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_clearDynamicRenderDrawInfos) 

static bool js_cc_RenderEntity_clearStaticRenderDrawInfos(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearStaticRenderDrawInfos();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_clearStaticRenderDrawInfos) 

static bool js_cc_RenderEntity_getIsMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::RenderEntity const *)arg1)->getIsMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getIsMask) 

static bool js_cc_RenderEntity_getIsSubMask(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::RenderEntity const *)arg1)->getIsSubMask();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getIsSubMask) 

static bool js_cc_RenderEntity_getIsMaskInverted(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::RenderEntity const *)arg1)->getIsMaskInverted();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getIsMaskInverted) 

static bool js_cc_RenderEntity_getUseLocal(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (bool)((cc::RenderEntity const *)arg1)->getUseLocal();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getUseLocal) 

static bool js_cc_RenderEntity_setUseLocal(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setUseLocal(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_setUseLocal) 

static bool js_cc_RenderEntity_getStaticRenderDrawInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    uint32_t arg2 ;
    cc::RenderDrawInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::RenderDrawInfo *)(arg1)->getStaticRenderDrawInfo(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getStaticRenderDrawInfo) 

static bool js_cc_RenderEntity_getStaticRenderDrawInfos(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    std::array< cc::RenderDrawInfo,4 > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (std::array< cc::RenderDrawInfo,4 > *) &(arg1)->getStaticRenderDrawInfos();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getStaticRenderDrawInfos) 

static bool js_cc_RenderEntity_getEntitySharedBufferForJS(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    se::Object *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (se::Object *)((cc::RenderEntity const *)arg1)->getEntitySharedBufferForJS();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getEntitySharedBufferForJS) 

static bool js_cc_RenderEntity_setColorDirty(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setColorDirty(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_setColorDirty) 

static bool js_cc_RenderEntity_getColorAlpha(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (float)((cc::RenderEntity const *)arg1)->getColorAlpha();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getColorAlpha) 

static bool js_cc_RenderEntity_getLocalOpacity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (float)((cc::RenderEntity const *)arg1)->getLocalOpacity();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getLocalOpacity) 

static bool js_cc_RenderEntity_getOpacity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (float)((cc::RenderEntity const *)arg1)->getOpacity();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getOpacity) 

static bool js_cc_RenderEntity_setOpacity(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->setOpacity(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_setOpacity) 

static bool js_cc_RenderEntity_getRenderDrawInfosSize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = ((cc::RenderEntity const *)arg1)->getRenderDrawInfosSize();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getRenderDrawInfosSize) 

static bool js_cc_RenderEntity_getRenderDrawInfoAt(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    uint32_t arg2 ;
    cc::RenderDrawInfo *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::RenderDrawInfo *)(arg1)->getRenderDrawInfoAt(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_RenderEntity_getRenderDrawInfoAt) 

static bool js_cc_RenderEntity_node_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderEntity_node_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderEntity_node_set) 

static bool js_cc_RenderEntity_node_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_RenderEntity_node_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderEntity_node_get) 

static bool js_cc_RenderEntity_renderTransform_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    cc_RenderEntity_renderTransform_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderEntity_renderTransform_set) 

static bool js_cc_RenderEntity_renderTransform_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    cc::Node *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = (cc::Node *)cc_RenderEntity_renderTransform_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderEntity_renderTransform_get) 

static bool js_cc_RenderEntity_staticDrawInfoSize_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderEntity_staticDrawInfoSize_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderEntity_staticDrawInfoSize_set) 

static bool js_cc_RenderEntity_staticDrawInfoSize_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderEntity_staticDrawInfoSize_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderEntity_staticDrawInfoSize_get) 

static bool js_cc_RenderEntity_stencilStage_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    uint32_t arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    cc_RenderEntity_stencilStage_set(arg1,SWIG_STD_MOVE(arg2));
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_RenderEntity_stencilStage_set) 

static bool js_cc_RenderEntity_stencilStage_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::RenderEntity *arg1 = (cc::RenderEntity *) NULL ;
    uint32_t result;
    
    arg1 = SE_THIS_OBJECT<cc::RenderEntity>(s);
    if (nullptr == arg1) return true;
    result = cc_RenderEntity_stencilStage_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_RenderEntity_stencilStage_get) 

bool js_register_cc_RenderEntity(se::Object* obj) {
    auto* cls = se::Class::create("RenderEntity", obj, nullptr, _SE(js_new_cc_RenderEntity)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("node", _SE(js_cc_RenderEntity_node_get), _SE(js_cc_RenderEntity_node_set)); 
    cls->defineProperty("renderTransform", _SE(js_cc_RenderEntity_renderTransform_get), _SE(js_cc_RenderEntity_renderTransform_set)); 
    cls->defineProperty("staticDrawInfoSize", _SE(js_cc_RenderEntity_staticDrawInfoSize_get), _SE(js_cc_RenderEntity_staticDrawInfoSize_set)); 
    cls->defineProperty("stencilStage", _SE(js_cc_RenderEntity_stencilStage_get), _SE(js_cc_RenderEntity_stencilStage_set)); 
    
    cls->defineFunction("addDynamicRenderDrawInfo", _SE(js_cc_RenderEntity_addDynamicRenderDrawInfo)); 
    cls->defineFunction("setDynamicRenderDrawInfo", _SE(js_cc_RenderEntity_setDynamicRenderDrawInfo)); 
    cls->defineFunction("removeDynamicRenderDrawInfo", _SE(js_cc_RenderEntity_removeDynamicRenderDrawInfo)); 
    cls->defineFunction("clearDynamicRenderDrawInfos", _SE(js_cc_RenderEntity_clearDynamicRenderDrawInfos)); 
    cls->defineFunction("clearStaticRenderDrawInfos", _SE(js_cc_RenderEntity_clearStaticRenderDrawInfos)); 
    cls->defineFunction("getIsMask", _SE(js_cc_RenderEntity_getIsMask)); 
    cls->defineFunction("getIsSubMask", _SE(js_cc_RenderEntity_getIsSubMask)); 
    cls->defineFunction("getIsMaskInverted", _SE(js_cc_RenderEntity_getIsMaskInverted)); 
    cls->defineFunction("getUseLocal", _SE(js_cc_RenderEntity_getUseLocal)); 
    cls->defineFunction("setUseLocal", _SE(js_cc_RenderEntity_setUseLocal)); 
    cls->defineFunction("getStaticRenderDrawInfo", _SE(js_cc_RenderEntity_getStaticRenderDrawInfo)); 
    cls->defineFunction("getStaticRenderDrawInfos", _SE(js_cc_RenderEntity_getStaticRenderDrawInfos)); 
    cls->defineFunction("getEntitySharedBufferForJS", _SE(js_cc_RenderEntity_getEntitySharedBufferForJS)); 
    cls->defineFunction("setColorDirty", _SE(js_cc_RenderEntity_setColorDirty)); 
    cls->defineFunction("getColorAlpha", _SE(js_cc_RenderEntity_getColorAlpha)); 
    cls->defineFunction("getLocalOpacity", _SE(js_cc_RenderEntity_getLocalOpacity)); 
    cls->defineFunction("getOpacity", _SE(js_cc_RenderEntity_getOpacity)); 
    cls->defineFunction("setOpacity", _SE(js_cc_RenderEntity_setOpacity)); 
    cls->defineFunction("getRenderDrawInfosSize", _SE(js_cc_RenderEntity_getRenderDrawInfosSize)); 
    cls->defineFunction("getRenderDrawInfoAt", _SE(js_cc_RenderEntity_getRenderDrawInfoAt)); 
    
    cls->defineStaticProperty("STATIC_DRAW_INFO_CAPACITY", nullptr, nullptr); 
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_RenderEntity));
    
    
    cls->install();
    JSBClassType::registerClass<cc::RenderEntity>(cls);
    
    __jsb_cc_RenderEntity_proto = cls->getProto();
    __jsb_cc_RenderEntity_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_UIModelProxy_class = nullptr;
se::Object* __jsb_cc_UIModelProxy_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_UIModelProxy) 

static bool js_new_cc_UIModelProxy(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::UIModelProxy *result;
    result = (cc::UIModelProxy *)new cc::UIModelProxy();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_UIModelProxy, __jsb_cc_UIModelProxy_class, js_delete_cc_UIModelProxy)

static bool js_delete_cc_UIModelProxy(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_UIModelProxy) 

static bool js_cc_UIModelProxy_initModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->initModel(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_initModel) 

static bool js_cc_UIModelProxy_activeSubModels(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    (arg1)->activeSubModels();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_activeSubModels) 

static bool js_cc_UIModelProxy_uploadData(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    (arg1)->uploadData();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_uploadData) 

static bool js_cc_UIModelProxy_destroy(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    (arg1)->destroy();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_destroy) 

static bool js_cc_UIModelProxy_clear(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    (arg1)->clear();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_clear) 

static bool js_cc_UIModelProxy_getModel(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    cc::scene::Model *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    result = (cc::scene::Model *)((cc::UIModelProxy const *)arg1)->getModel();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_getModel) 

static bool js_cc_UIModelProxy_updateModels(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    cc::scene::Model *arg2 = (cc::scene::Model *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->updateModels(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_updateModels) 

static bool js_cc_UIModelProxy_attachDrawInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    (arg1)->attachDrawInfo();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_attachDrawInfo) 

static bool js_cc_UIModelProxy_attachNode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    cc::Node *arg2 = (cc::Node *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->attachNode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_attachNode) 

static bool js_cc_UIModelProxy_clearModels(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::UIModelProxy *arg1 = (cc::UIModelProxy *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::UIModelProxy>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearModels();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_UIModelProxy_clearModels) 

bool js_register_cc_UIModelProxy(se::Object* obj) {
    auto* cls = se::Class::create("UIModelProxy", obj, nullptr, _SE(js_new_cc_UIModelProxy)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("initModel", _SE(js_cc_UIModelProxy_initModel)); 
    cls->defineFunction("activeSubModels", _SE(js_cc_UIModelProxy_activeSubModels)); 
    cls->defineFunction("uploadData", _SE(js_cc_UIModelProxy_uploadData)); 
    cls->defineFunction("destroy", _SE(js_cc_UIModelProxy_destroy)); 
    cls->defineFunction("clear", _SE(js_cc_UIModelProxy_clear)); 
    cls->defineFunction("getModel", _SE(js_cc_UIModelProxy_getModel)); 
    cls->defineFunction("updateModels", _SE(js_cc_UIModelProxy_updateModels)); 
    cls->defineFunction("attachDrawInfo", _SE(js_cc_UIModelProxy_attachDrawInfo)); 
    cls->defineFunction("attachNode", _SE(js_cc_UIModelProxy_attachNode)); 
    cls->defineFunction("clearModels", _SE(js_cc_UIModelProxy_clearModels)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_UIModelProxy));
    
    
    cls->install();
    JSBClassType::registerClass<cc::UIModelProxy>(cls);
    
    __jsb_cc_UIModelProxy_proto = cls->getProto();
    __jsb_cc_UIModelProxy_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_Batcher2d_class = nullptr;
se::Object* __jsb_cc_Batcher2d_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_Batcher2d) 

static bool js_new_cc_Batcher2d__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Batcher2d *result;
    result = (cc::Batcher2d *)new cc::Batcher2d();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_Batcher2d__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::Root *arg1 = (cc::Root *) NULL ;
    cc::Batcher2d *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::Batcher2d *)new cc::Batcher2d(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Batcher2d(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_cc_Batcher2d__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_Batcher2d__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Batcher2d");
    return false;
}
SE_BIND_CTOR(js_new_Batcher2d, __jsb_cc_Batcher2d_class, js_delete_cc_Batcher2d)

static bool js_delete_cc_Batcher2d(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_Batcher2d) 

static bool js_cc_Batcher2d_syncMeshBuffersToNative(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Batcher2d *arg1 = (cc::Batcher2d *) NULL ;
    uint16_t arg2 ;
    ccstd::vector< cc::UIMeshBuffer * > *arg3 = 0 ;
    ccstd::vector< cc::UIMeshBuffer * > temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Batcher2d>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->syncMeshBuffersToNative(arg2,(ccstd::vector< cc::UIMeshBuffer * > &&)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Batcher2d_syncMeshBuffersToNative) 

static bool js_cc_Batcher2d_initialize(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Batcher2d *arg1 = (cc::Batcher2d *) NULL ;
    bool result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Batcher2d>(s);
    if (nullptr == arg1) return true;
    result = (bool)(arg1)->initialize();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Batcher2d_initialize) 

static bool js_cc_Batcher2d_update(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Batcher2d *arg1 = (cc::Batcher2d *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Batcher2d>(s);
    if (nullptr == arg1) return true;
    (arg1)->update();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Batcher2d_update) 

static bool js_cc_Batcher2d_uploadBuffers(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Batcher2d *arg1 = (cc::Batcher2d *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Batcher2d>(s);
    if (nullptr == arg1) return true;
    (arg1)->uploadBuffers();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Batcher2d_uploadBuffers) 

static bool js_cc_Batcher2d_reset(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Batcher2d *arg1 = (cc::Batcher2d *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Batcher2d>(s);
    if (nullptr == arg1) return true;
    (arg1)->reset();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Batcher2d_reset) 

static bool js_cc_Batcher2d_syncRootNodesToNative(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Batcher2d *arg1 = (cc::Batcher2d *) NULL ;
    ccstd::vector< cc::Node * > *arg2 = 0 ;
    ccstd::vector< cc::Node * > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Batcher2d>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->syncRootNodesToNative((ccstd::vector< cc::Node * > &&)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Batcher2d_syncRootNodesToNative) 

static bool js_cc_Batcher2d_releaseDescriptorSetCache(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Batcher2d *arg1 = (cc::Batcher2d *) NULL ;
    cc::gfx::Texture *arg2 = (cc::gfx::Texture *) NULL ;
    cc::gfx::Sampler *arg3 = (cc::gfx::Sampler *) NULL ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Batcher2d>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->releaseDescriptorSetCache(arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Batcher2d_releaseDescriptorSetCache) 

static bool js_cc_Batcher2d_getDefaultAttribute(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Batcher2d *arg1 = (cc::Batcher2d *) NULL ;
    ccstd::vector< cc::gfx::Attribute > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Batcher2d>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::gfx::Attribute > *)(arg1)->getDefaultAttribute();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Batcher2d_getDefaultAttribute) 

static bool js_cc_Batcher2d_handlePostRender(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::Batcher2d *arg1 = (cc::Batcher2d *) NULL ;
    cc::RenderEntity *arg2 = (cc::RenderEntity *) NULL ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::Batcher2d>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    (arg1)->handlePostRender(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_Batcher2d_handlePostRender) 

bool js_register_cc_Batcher2d(se::Object* obj) {
    auto* cls = se::Class::create("Batcher2d", obj, nullptr, _SE(js_new_Batcher2d)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("syncMeshBuffersToNative", _SE(js_cc_Batcher2d_syncMeshBuffersToNative)); 
    cls->defineFunction("initialize", _SE(js_cc_Batcher2d_initialize)); 
    cls->defineFunction("update", _SE(js_cc_Batcher2d_update)); 
    cls->defineFunction("uploadBuffers", _SE(js_cc_Batcher2d_uploadBuffers)); 
    cls->defineFunction("reset", _SE(js_cc_Batcher2d_reset)); 
    cls->defineFunction("syncRootNodesToNative", _SE(js_cc_Batcher2d_syncRootNodesToNative)); 
    cls->defineFunction("releaseDescriptorSetCache", _SE(js_cc_Batcher2d_releaseDescriptorSetCache)); 
    cls->defineFunction("getDefaultAttribute", _SE(js_cc_Batcher2d_getDefaultAttribute)); 
    cls->defineFunction("handlePostRender", _SE(js_cc_Batcher2d_handlePostRender)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_Batcher2d));
    
    
    cls->install();
    JSBClassType::registerClass<cc::Batcher2d>(cls);
    
    __jsb_cc_Batcher2d_proto = cls->getProto();
    __jsb_cc_Batcher2d_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_native2d(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("n2d", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("n2d", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_MeshBufferLayout(ns); 
    js_register_cc_UIMeshBuffer(ns); 
    js_register_cc_Render2dLayout(ns); 
    js_register_cc_LocalDSBF(ns); 
    js_register_cc_RenderDrawInfo(ns); 
    js_register_cc_EntityAttrLayout(ns); 
    js_register_cc_RenderEntity(ns); 
    js_register_cc_UIModelProxy(ns); 
    js_register_cc_Batcher2d(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
