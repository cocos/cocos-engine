// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (https://www.swig.org).
 * Version 4.1.0
 *
 * Do not make changes to this file unless you know what you are doing - modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022-2023 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-variable"
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#elif defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4101)
#endif


#define SWIG_STD_MOVE(OBJ) std::move(OBJ)


#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_geometry_auto.h"
#include "bindings/auto/jsb_cocos_auto.h"


#define cc_geometry_ShapeBase__type_get(self_) self_->getType()
#define cc_geometry_ShapeBase__type_set(self_, val_) self_->setType(val_)
  


se::Class* __jsb_cc_geometry_ShapeBase_class = nullptr;
se::Object* __jsb_cc_geometry_ShapeBase_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_ShapeBase) 

static bool js_new_cc_geometry_ShapeBase(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    if (argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    cc::geometry::ShapeEnum arg1 ;
    cc::geometry::ShapeBase *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::geometry::ShapeBase *)new cc::geometry::ShapeBase(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_geometry_ShapeBase, __jsb_cc_geometry_ShapeBase_class, js_delete_cc_geometry_ShapeBase)

static bool js_cc_geometry_ShapeBase__type_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::ShapeBase *arg1 = (cc::geometry::ShapeBase *) NULL ;
    cc::geometry::ShapeEnum arg2 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::ShapeBase>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    cc_geometry_ShapeBase__type_set(arg1,arg2);
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_ShapeBase__type_set) 

static bool js_cc_geometry_ShapeBase__type_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::ShapeBase *arg1 = (cc::geometry::ShapeBase *) NULL ;
    cc::geometry::ShapeEnum result;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::ShapeBase>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::ShapeEnum)cc_geometry_ShapeBase__type_get(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_ShapeBase__type_get) 

static bool js_delete_cc_geometry_ShapeBase(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_ShapeBase) 

bool js_register_cc_geometry_ShapeBase(se::Object* obj) {
    auto* cls = se::Class::create("ShapeBase", obj, nullptr, _SE(js_new_cc_geometry_ShapeBase)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_type", _SE(js_cc_geometry_ShapeBase__type_get), _SE(js_cc_geometry_ShapeBase__type_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_ShapeBase));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::ShapeBase>(cls);
    
    __jsb_cc_geometry_ShapeBase_proto = cls->getProto();
    __jsb_cc_geometry_ShapeBase_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_AABB_class = nullptr;
se::Object* __jsb_cc_geometry_AABB_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_AABB) 

static bool js_new_cc_geometry_AABB__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::AABB *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::AABB *)new cc::geometry::AABB(arg1,arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_AABB__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::AABB *result;
    result = (cc::geometry::AABB *)new cc::geometry::AABB();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_AABB(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 6) {
        ret = js_new_cc_geometry_AABB__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 0) {
        ret = js_new_cc_geometry_AABB__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of AABB");
    return false;
}
SE_BIND_CTOR(js_new_AABB, __jsb_cc_geometry_AABB_class, js_delete_cc_geometry_AABB)

static bool js_delete_cc_geometry_AABB(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_AABB) 

static bool js_cc_geometry_AABB_center_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->center, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_AABB_center_set) 

static bool js_cc_geometry_AABB_center_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->center, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->center, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_AABB_center_get) 

static bool js_cc_geometry_AABB_halfExtents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->halfExtents, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_AABB_halfExtents_set) 

static bool js_cc_geometry_AABB_halfExtents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->halfExtents, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->halfExtents, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_AABB_halfExtents_get) 

bool js_register_cc_geometry_AABB(se::Object* obj) {
    auto* cls = se::Class::create("AABB", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_AABB)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("center", _SE(js_cc_geometry_AABB_center_get), _SE(js_cc_geometry_AABB_center_set)); 
    cls->defineProperty("halfExtents", _SE(js_cc_geometry_AABB_halfExtents_get), _SE(js_cc_geometry_AABB_halfExtents_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_AABB));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::AABB>(cls);
    
    __jsb_cc_geometry_AABB_proto = cls->getProto();
    __jsb_cc_geometry_AABB_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Line_class = nullptr;
se::Object* __jsb_cc_geometry_Line_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Line) 

static bool js_cc_geometry_Line_s_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Line>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->s, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Line_s_set) 

static bool js_cc_geometry_Line_s_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Line>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->s, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->s, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Line_s_get) 

static bool js_cc_geometry_Line_e_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Line>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->e, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Line_e_set) 

static bool js_cc_geometry_Line_e_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Line>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->e, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->e, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Line_e_get) 

static bool js_new_cc_geometry_Line__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::Line *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::geometry::Line *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2,arg3,arg4,arg5);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Line *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Line *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Line *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Line *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_6(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Line *result;
    result = (cc::geometry::Line *)new cc::geometry::Line();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_7(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Line *arg1 = 0 ;
    cc::geometry::Line temp1 ;
    cc::geometry::Line *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Line *)new cc::geometry::Line((cc::geometry::Line const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_8(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Line *arg1 = 0 ;
    cc::geometry::Line temp1 ;
    cc::geometry::Line *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Line *)new cc::geometry::Line((cc::geometry::Line &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Line(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 6) {
        ret = js_new_cc_geometry_Line__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 5) {
        ret = js_new_cc_geometry_Line__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 4) {
        ret = js_new_cc_geometry_Line__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 3) {
        ret = js_new_cc_geometry_Line__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_cc_geometry_Line__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Line__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 0) {
        ret = js_new_cc_geometry_Line__SWIG_6(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Line__SWIG_7(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Line__SWIG_8(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Line");
    return false;
}
SE_BIND_CTOR(js_new_Line, __jsb_cc_geometry_Line_class, js_delete_cc_geometry_Line)

static bool js_delete_cc_geometry_Line(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Line) 

bool js_register_cc_geometry_Line(se::Object* obj) {
    auto* cls = se::Class::create("Line", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Line)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("s", _SE(js_cc_geometry_Line_s_get), _SE(js_cc_geometry_Line_s_set)); 
    cls->defineProperty("e", _SE(js_cc_geometry_Line_e_get), _SE(js_cc_geometry_Line_e_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Line));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Line>(cls);
    
    __jsb_cc_geometry_Line_proto = cls->getProto();
    __jsb_cc_geometry_Line_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Plane_class = nullptr;
se::Object* __jsb_cc_geometry_Plane_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Plane) 

static bool js_new_cc_geometry_Plane__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Plane *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Plane *)new cc::geometry::Plane(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Plane__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Plane *result;
    result = (cc::geometry::Plane *)new cc::geometry::Plane();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Plane(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 4) {
        ret = js_new_cc_geometry_Plane__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 0) {
        ret = js_new_cc_geometry_Plane__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Plane");
    return false;
}
SE_BIND_CTOR(js_new_Plane, __jsb_cc_geometry_Plane_class, js_delete_cc_geometry_Plane)

static bool js_cc_geometry_Plane_n_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->n, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Plane_n_set) 

static bool js_cc_geometry_Plane_n_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->n, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->n, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Plane_n_get) 

static bool js_cc_geometry_Plane_d_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->d, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Plane_d_set) 

static bool js_cc_geometry_Plane_d_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->d, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Plane_d_get) 

static bool js_delete_cc_geometry_Plane(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Plane) 

bool js_register_cc_geometry_Plane(se::Object* obj) {
    auto* cls = se::Class::create("Plane", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Plane)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("n", _SE(js_cc_geometry_Plane_n_get), _SE(js_cc_geometry_Plane_n_set)); 
    cls->defineProperty("d", _SE(js_cc_geometry_Plane_d_get), _SE(js_cc_geometry_Plane_d_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Plane));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Plane>(cls);
    
    __jsb_cc_geometry_Plane_proto = cls->getProto();
    __jsb_cc_geometry_Plane_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Frustum_class = nullptr;
se::Object* __jsb_cc_geometry_Frustum_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Frustum) 

static bool js_new_cc_geometry_Frustum__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Frustum *result;
    result = (cc::geometry::Frustum *)new cc::geometry::Frustum();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Frustum__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Frustum *arg1 = 0 ;
    cc::geometry::Frustum temp1 ;
    cc::geometry::Frustum *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Frustum *)new cc::geometry::Frustum((cc::geometry::Frustum const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Frustum(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 0) {
        ret = js_new_cc_geometry_Frustum__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Frustum__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Frustum");
    return false;
}
SE_BIND_CTOR(js_new_Frustum, __jsb_cc_geometry_Frustum_class, js_delete_cc_geometry_Frustum)

static bool js_delete_cc_geometry_Frustum(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Frustum) 

static bool js_cc_geometry_Frustum_vertices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->vertices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Frustum_vertices_set) 

static bool js_cc_geometry_Frustum_vertices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->vertices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Frustum_vertices_get) 

static bool js_cc_geometry_Frustum_planes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->planes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Frustum_planes_set) 

static bool js_cc_geometry_Frustum_planes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->planes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->planes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Frustum_planes_get) 

bool js_register_cc_geometry_Frustum(se::Object* obj) {
    auto* cls = se::Class::create("Frustum", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Frustum)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("vertices", _SE(js_cc_geometry_Frustum_vertices_get), _SE(js_cc_geometry_Frustum_vertices_set)); 
    cls->defineProperty("planes", _SE(js_cc_geometry_Frustum_planes_get), _SE(js_cc_geometry_Frustum_planes_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Frustum));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Frustum>(cls);
    
    __jsb_cc_geometry_Frustum_proto = cls->getProto();
    __jsb_cc_geometry_Frustum_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Capsule_class = nullptr;
se::Object* __jsb_cc_geometry_Capsule_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Capsule) 

static bool js_cc_geometry_Capsule_radius_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->radius, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_radius_set) 

static bool js_cc_geometry_Capsule_radius_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->radius, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_radius_get) 

static bool js_cc_geometry_Capsule_halfHeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->halfHeight, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_halfHeight_set) 

static bool js_cc_geometry_Capsule_halfHeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->halfHeight, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_halfHeight_get) 

static bool js_cc_geometry_Capsule_axis_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->axis, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_axis_set) 

static bool js_cc_geometry_Capsule_axis_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->axis, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->axis, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_axis_get) 

static bool js_cc_geometry_Capsule_center_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->center, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_center_set) 

static bool js_cc_geometry_Capsule_center_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->center, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->center, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_center_get) 

static bool js_cc_geometry_Capsule_rotation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->rotation, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_rotation_set) 

static bool js_cc_geometry_Capsule_rotation_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->rotation, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->rotation, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_rotation_get) 

static bool js_cc_geometry_Capsule_ellipseCenter0_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->ellipseCenter0, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_ellipseCenter0_set) 

static bool js_cc_geometry_Capsule_ellipseCenter0_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->ellipseCenter0, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ellipseCenter0, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_ellipseCenter0_get) 

static bool js_cc_geometry_Capsule_ellipseCenter1_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->ellipseCenter1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_ellipseCenter1_set) 

static bool js_cc_geometry_Capsule_ellipseCenter1_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->ellipseCenter1, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ellipseCenter1, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_ellipseCenter1_get) 

static bool js_new_cc_geometry_Capsule__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Capsule::CenterEnum arg3 ;
    cc::geometry::Capsule *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Capsule *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Capsule *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *result;
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = 0 ;
    cc::geometry::Capsule temp1 ;
    cc::geometry::Capsule *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule((cc::geometry::Capsule const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = 0 ;
    cc::geometry::Capsule temp1 ;
    cc::geometry::Capsule *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule((cc::geometry::Capsule &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Capsule(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 3) {
        ret = js_new_cc_geometry_Capsule__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_cc_geometry_Capsule__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Capsule__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 0) {
        ret = js_new_cc_geometry_Capsule__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Capsule__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Capsule__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Capsule");
    return false;
}
SE_BIND_CTOR(js_new_Capsule, __jsb_cc_geometry_Capsule_class, js_delete_cc_geometry_Capsule)

static bool js_delete_cc_geometry_Capsule(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Capsule) 

bool js_register_cc_geometry_Capsule(se::Object* obj) {
    auto* cls = se::Class::create("Capsule", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Capsule)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("radius", _SE(js_cc_geometry_Capsule_radius_get), _SE(js_cc_geometry_Capsule_radius_set)); 
    cls->defineProperty("halfHeight", _SE(js_cc_geometry_Capsule_halfHeight_get), _SE(js_cc_geometry_Capsule_halfHeight_set)); 
    cls->defineProperty("axis", _SE(js_cc_geometry_Capsule_axis_get), _SE(js_cc_geometry_Capsule_axis_set)); 
    cls->defineProperty("center", _SE(js_cc_geometry_Capsule_center_get), _SE(js_cc_geometry_Capsule_center_set)); 
    cls->defineProperty("rotation", _SE(js_cc_geometry_Capsule_rotation_get), _SE(js_cc_geometry_Capsule_rotation_set)); 
    cls->defineProperty("ellipseCenter0", _SE(js_cc_geometry_Capsule_ellipseCenter0_get), _SE(js_cc_geometry_Capsule_ellipseCenter0_set)); 
    cls->defineProperty("ellipseCenter1", _SE(js_cc_geometry_Capsule_ellipseCenter1_get), _SE(js_cc_geometry_Capsule_ellipseCenter1_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Capsule));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Capsule>(cls);
    
    __jsb_cc_geometry_Capsule_proto = cls->getProto();
    __jsb_cc_geometry_Capsule_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Sphere_class = nullptr;
se::Object* __jsb_cc_geometry_Sphere_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Sphere) 

static bool js_new_cc_geometry_Sphere__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Sphere *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Sphere__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Sphere *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Sphere__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Sphere *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Sphere__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Sphere *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Sphere__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Sphere *result;
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Sphere__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Sphere *arg1 = 0 ;
    cc::geometry::Sphere temp1 ;
    cc::geometry::Sphere *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere((cc::geometry::Sphere const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Sphere(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 4) {
        ret = js_new_cc_geometry_Sphere__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 3) {
        ret = js_new_cc_geometry_Sphere__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_cc_geometry_Sphere__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Sphere__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 0) {
        ret = js_new_cc_geometry_Sphere__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Sphere__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Sphere");
    return false;
}
SE_BIND_CTOR(js_new_Sphere, __jsb_cc_geometry_Sphere_class, js_delete_cc_geometry_Sphere)

static bool js_delete_cc_geometry_Sphere(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Sphere) 

static bool js_cc_geometry_Sphere__radius_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_radius, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Sphere__radius_set) 

static bool js_cc_geometry_Sphere__radius_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_radius, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Sphere__radius_get) 

static bool js_cc_geometry_Sphere__center_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->_center, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Sphere__center_set) 

static bool js_cc_geometry_Sphere__center_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->_center, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->_center, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Sphere__center_get) 

bool js_register_cc_geometry_Sphere(se::Object* obj) {
    auto* cls = se::Class::create("Sphere", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Sphere)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("_radius", _SE(js_cc_geometry_Sphere__radius_get), _SE(js_cc_geometry_Sphere__radius_set)); 
    cls->defineProperty("_center", _SE(js_cc_geometry_Sphere__center_get), _SE(js_cc_geometry_Sphere__center_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Sphere));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Sphere>(cls);
    
    __jsb_cc_geometry_Sphere_proto = cls->getProto();
    __jsb_cc_geometry_Sphere_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Triangle_class = nullptr;
se::Object* __jsb_cc_geometry_Triangle_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Triangle) 

static bool js_cc_geometry_Triangle_a_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->a, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Triangle_a_set) 

static bool js_cc_geometry_Triangle_a_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->a, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->a, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Triangle_a_get) 

static bool js_cc_geometry_Triangle_b_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->b, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Triangle_b_set) 

static bool js_cc_geometry_Triangle_b_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->b, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->b, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Triangle_b_get) 

static bool js_cc_geometry_Triangle_c_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->c, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Triangle_c_set) 

static bool js_cc_geometry_Triangle_c_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->c, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->c, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Triangle_c_get) 

static bool js_new_cc_geometry_Triangle__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    float arg9 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[8], &arg9, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[7], &arg8, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[6], &arg7, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_6(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_7(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_8(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_9(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *result;
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_10(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = 0 ;
    cc::geometry::Triangle temp1 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle((cc::geometry::Triangle const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_11(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = 0 ;
    cc::geometry::Triangle temp1 ;
    cc::geometry::Triangle *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle((cc::geometry::Triangle &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Triangle(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 9) {
        ret = js_new_cc_geometry_Triangle__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 8) {
        ret = js_new_cc_geometry_Triangle__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 7) {
        ret = js_new_cc_geometry_Triangle__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 6) {
        ret = js_new_cc_geometry_Triangle__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 5) {
        ret = js_new_cc_geometry_Triangle__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 4) {
        ret = js_new_cc_geometry_Triangle__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 3) {
        ret = js_new_cc_geometry_Triangle__SWIG_6(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_cc_geometry_Triangle__SWIG_7(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Triangle__SWIG_8(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 0) {
        ret = js_new_cc_geometry_Triangle__SWIG_9(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Triangle__SWIG_10(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Triangle__SWIG_11(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Triangle");
    return false;
}
SE_BIND_CTOR(js_new_Triangle, __jsb_cc_geometry_Triangle_class, js_delete_cc_geometry_Triangle)

static bool js_delete_cc_geometry_Triangle(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Triangle) 

bool js_register_cc_geometry_Triangle(se::Object* obj) {
    auto* cls = se::Class::create("Triangle", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Triangle)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("a", _SE(js_cc_geometry_Triangle_a_get), _SE(js_cc_geometry_Triangle_a_set)); 
    cls->defineProperty("b", _SE(js_cc_geometry_Triangle_b_get), _SE(js_cc_geometry_Triangle_b_set)); 
    cls->defineProperty("c", _SE(js_cc_geometry_Triangle_c_get), _SE(js_cc_geometry_Triangle_c_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Triangle));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Triangle>(cls);
    
    __jsb_cc_geometry_Triangle_proto = cls->getProto();
    __jsb_cc_geometry_Triangle_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Ray_class = nullptr;
se::Object* __jsb_cc_geometry_Ray_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Ray) 

static bool js_cc_geometry_Ray_o_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Ray>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->o, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Ray_o_set) 

static bool js_cc_geometry_Ray_o_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Ray>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->o, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->o, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Ray_o_get) 

static bool js_cc_geometry_Ray_d_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Ray>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg1->d, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Ray_d_set) 

static bool js_cc_geometry_Ray_d_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Ray>(s);
    if (nullptr == arg1) return true;
    
    ok &= nativevalue_to_se(arg1->d, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->d, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Ray_d_get) 

static bool js_new_cc_geometry_Ray__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::Ray *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[5], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::geometry::Ray *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[4], &arg5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2,arg3,arg4,arg5);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Ray *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[3], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Ray *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[2], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Ray *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Ray *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_6(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *result;
    result = (cc::geometry::Ray *)new cc::geometry::Ray();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_7(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *arg1 = 0 ;
    cc::geometry::Ray temp1 ;
    cc::geometry::Ray *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Ray *)new cc::geometry::Ray((cc::geometry::Ray const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_8(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *arg1 = 0 ;
    cc::geometry::Ray temp1 ;
    cc::geometry::Ray *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Ray *)new cc::geometry::Ray((cc::geometry::Ray &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Ray(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 6) {
        ret = js_new_cc_geometry_Ray__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 5) {
        ret = js_new_cc_geometry_Ray__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 4) {
        ret = js_new_cc_geometry_Ray__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 3) {
        ret = js_new_cc_geometry_Ray__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 2) {
        ret = js_new_cc_geometry_Ray__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Ray__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 0) {
        ret = js_new_cc_geometry_Ray__SWIG_6(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Ray__SWIG_7(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Ray__SWIG_8(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Ray");
    return false;
}
SE_BIND_CTOR(js_new_Ray, __jsb_cc_geometry_Ray_class, js_delete_cc_geometry_Ray)

static bool js_delete_cc_geometry_Ray(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Ray) 

bool js_register_cc_geometry_Ray(se::Object* obj) {
    auto* cls = se::Class::create("Ray", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Ray)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    cls->defineProperty("o", _SE(js_cc_geometry_Ray_o_get), _SE(js_cc_geometry_Ray_o_set)); 
    cls->defineProperty("d", _SE(js_cc_geometry_Ray_d_get), _SE(js_cc_geometry_Ray_d_set)); 
    
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Ray));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Ray>(cls);
    
    __jsb_cc_geometry_Ray_proto = cls->getProto();
    __jsb_cc_geometry_Ray_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Spline_class = nullptr;
se::Object* __jsb_cc_geometry_Spline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Spline) 

static bool js_new_cc_geometry_Spline__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::SplineMode arg1 ;
    ccstd::vector< cc::Vec3 > arg2 ;
    cc::geometry::Spline *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::geometry::Spline *)new cc::geometry::Spline(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Spline__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::SplineMode arg1 ;
    cc::geometry::Spline *result;
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::geometry::Spline *)new cc::geometry::Spline(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Spline__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Spline *result;
    result = (cc::geometry::Spline *)new cc::geometry::Spline();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Spline__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Spline *arg1 = 0 ;
    cc::geometry::Spline temp1 ;
    cc::geometry::Spline *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Spline *)new cc::geometry::Spline((cc::geometry::Spline const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Spline__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Spline *arg1 = 0 ;
    cc::geometry::Spline temp1 ;
    cc::geometry::Spline *result;
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Spline *)new cc::geometry::Spline((cc::geometry::Spline &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Spline(se::State& s) // NOLINT(readability-identifier-naming)
{
    size_t argc = s.args().size();
    bool ret = false;
    
    if(argc == 2) {
        ret = js_new_cc_geometry_Spline__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Spline__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 0) {
        ret = js_new_cc_geometry_Spline__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Spline__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    if(argc == 1) {
        ret = js_new_cc_geometry_Spline__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    SE_REPORT_ERROR("Illegal arguments for construction of Spline");
    return false;
}
SE_BIND_CTOR(js_new_Spline, __jsb_cc_geometry_Spline_class, js_delete_cc_geometry_Spline)

static bool js_delete_cc_geometry_Spline(se::State& s)
{
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Spline) 

static bool js_cc_geometry_Spline_create_static__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::SplineMode arg1 ;
    ccstd::vector< cc::Vec3 > *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > temp2 ;
    cc::geometry::Spline *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::geometry::Spline *)cc::geometry::Spline::create(arg1,(ccstd::vector< cc::Vec3 > const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Spline_create_static__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::SplineMode arg1 ;
    cc::geometry::Spline *result = 0 ;
    
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    result = (cc::geometry::Spline *)cc::geometry::Spline::create(arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Spline_create_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_geometry_Spline_create_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_geometry_Spline_create_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Spline_create_static) 

static bool js_cc_geometry_Spline_clone_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = 0 ;
    cc::geometry::Spline temp1 ;
    cc::geometry::Spline *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg1 = &temp1;
    
    result = (cc::geometry::Spline *)cc::geometry::Spline::clone((cc::geometry::Spline const &)*arg1);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_clone_static) 

static bool js_cc_geometry_Spline_copy_static(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::geometry::Spline temp2 ;
    cc::geometry::Spline *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    result = (cc::geometry::Spline *)cc::geometry::Spline::copy(arg1,(cc::geometry::Spline const &)*arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_copy_static) 

static bool js_cc_geometry_Spline_setMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::geometry::SplineMode arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    (arg1)->setMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_setMode) 

static bool js_cc_geometry_Spline_getMode(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::geometry::SplineMode result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    result = (cc::geometry::SplineMode)((cc::geometry::Spline const *)arg1)->getMode();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getMode) 

static bool js_cc_geometry_Spline_setKnots(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    ccstd::vector< cc::Vec3 > *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->setKnots((ccstd::vector< cc::Vec3 > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_setKnots) 

static bool js_cc_geometry_Spline_getKnots(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    ccstd::vector< cc::Vec3 > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    result = (ccstd::vector< cc::Vec3 > *) &((cc::geometry::Spline const *)arg1)->getKnots();
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getKnots) 

static bool js_cc_geometry_Spline_clearKnots(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    (arg1)->clearKnots();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_clearKnots) 

static bool js_cc_geometry_Spline_getKnotCount(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    result = ((cc::geometry::Spline const *)arg1)->getKnotCount();
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getKnotCount) 

static bool js_cc_geometry_Spline_addKnot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg2 = &temp2;
    
    (arg1)->addKnot((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_addKnot) 

static bool js_cc_geometry_Spline_setModeAndKnots(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::geometry::SplineMode arg2 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setModeAndKnots(arg2,(ccstd::vector< cc::Vec3 > const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_setModeAndKnots) 

static bool js_cc_geometry_Spline_insertKnot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->insertKnot(arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_insertKnot) 

static bool js_cc_geometry_Spline_removeKnot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    (arg1)->removeKnot(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_removeKnot) 

static bool js_cc_geometry_Spline_setKnot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    arg3 = &temp3;
    
    (arg1)->setKnot(arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_setKnot) 

static bool js_cc_geometry_Spline_getKnot__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::Vec3 *) &((cc::geometry::Spline const *)arg1)->getKnot(arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Spline_getKnot__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = (cc::Vec3 *) &(arg1)->getKnot(arg2);
    
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Spline_getKnot(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 1) {
        ok = js_cc_geometry_Spline_getKnot__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_geometry_Spline_getKnot__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getKnot) 

static bool js_cc_geometry_Spline_getPoint__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    float arg2 ;
    uint32_t arg3 ;
    cc::Vec3 result;
    cc::Vec3 *temp ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = ((cc::geometry::Spline const *)arg1)->getPoint(arg2,arg3);
    
    temp = ccnew cc::Vec3(result);
    ok &= nativevalue_to_se(temp, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    
    return true;
}

static bool js_cc_geometry_Spline_getPoint__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    float arg2 ;
    cc::Vec3 result;
    cc::Vec3 *temp ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments"); 
    result = ((cc::geometry::Spline const *)arg1)->getPoint(arg2);
    
    temp = ccnew cc::Vec3(result);
    ok &= nativevalue_to_se(temp, s.rval(), s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    s.rval().toObject()->getPrivateObject()->tryAllowDestroyInGC();
    
    
    
    return true;
}

static bool js_cc_geometry_Spline_getPoint(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_geometry_Spline_getPoint__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_geometry_Spline_getPoint__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getPoint) 

static bool js_cc_geometry_Spline_getPoints__SWIG_0(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    ccstd::vector< cc::Vec3 > result;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = ((cc::geometry::Spline const *)arg1)->getPoints(arg2,arg3);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_geometry_Spline_getPoints__SWIG_1(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    ccstd::vector< cc::Vec3 > result;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    if (nullptr == arg1) return true;
    
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    
    result = ((cc::geometry::Spline const *)arg1)->getPoints(arg2);
    
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_geometry_Spline_getPoints(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    
    if (argc == 2) {
        ok = js_cc_geometry_Spline_getPoints__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } 
    if (argc == 1) {
        ok = js_cc_geometry_Spline_getPoints__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getPoints) 

bool js_register_cc_geometry_Spline(se::Object* obj) {
    auto* cls = se::Class::create("Spline", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Spline)); 
    
    cls->defineStaticProperty("__isJSB", se::Value(true), se::PropertyAttribute::READ_ONLY | se::PropertyAttribute::DONT_ENUM | se::PropertyAttribute::DONT_DELETE);
    
    cls->defineFunction("setMode", _SE(js_cc_geometry_Spline_setMode)); 
    cls->defineFunction("getMode", _SE(js_cc_geometry_Spline_getMode)); 
    cls->defineFunction("setKnots", _SE(js_cc_geometry_Spline_setKnots)); 
    cls->defineFunction("getKnots", _SE(js_cc_geometry_Spline_getKnots)); 
    cls->defineFunction("clearKnots", _SE(js_cc_geometry_Spline_clearKnots)); 
    cls->defineFunction("getKnotCount", _SE(js_cc_geometry_Spline_getKnotCount)); 
    cls->defineFunction("addKnot", _SE(js_cc_geometry_Spline_addKnot)); 
    cls->defineFunction("setModeAndKnots", _SE(js_cc_geometry_Spline_setModeAndKnots)); 
    cls->defineFunction("insertKnot", _SE(js_cc_geometry_Spline_insertKnot)); 
    cls->defineFunction("removeKnot", _SE(js_cc_geometry_Spline_removeKnot)); 
    cls->defineFunction("setKnot", _SE(js_cc_geometry_Spline_setKnot)); 
    cls->defineFunction("getKnot", _SE(js_cc_geometry_Spline_getKnot)); 
    cls->defineFunction("getPoint", _SE(js_cc_geometry_Spline_getPoint)); 
    cls->defineFunction("getPoints", _SE(js_cc_geometry_Spline_getPoints)); 
    
    
    cls->defineStaticFunction("create", _SE(js_cc_geometry_Spline_create_static)); 
    cls->defineStaticFunction("clone", _SE(js_cc_geometry_Spline_clone_static)); 
    cls->defineStaticFunction("copy", _SE(js_cc_geometry_Spline_copy_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Spline));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Spline>(cls);
    
    __jsb_cc_geometry_Spline_proto = cls->getProto();
    __jsb_cc_geometry_Spline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_geometry(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("ns", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("ns", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_geometry_ShapeBase(ns); 
    js_register_cc_geometry_AABB(ns); 
    js_register_cc_geometry_Line(ns); 
    js_register_cc_geometry_Plane(ns); 
    js_register_cc_geometry_Frustum(ns); 
    js_register_cc_geometry_Capsule(ns); 
    js_register_cc_geometry_Sphere(ns); 
    js_register_cc_geometry_Triangle(ns); 
    js_register_cc_geometry_Ray(ns); 
    js_register_cc_geometry_Spline(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}


#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#pragma warning(pop)
#endif
// clang-format on
