// clang-format off

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.1.0
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/****************************************************************************
 Copyright (c) 2022 Xiamen Yaji Software Co., Ltd.

 http://www.cocos.com

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
 worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
 not use Cocos Creator software for developing other software or tools that's
 used for developing games. You are not granted to publish, distribute,
 sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
****************************************************************************/

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static 
#endif



#include <stdio.h>


#include "bindings/jswrapper/SeApi.h"
#include "bindings/manual/jsb_conversions.h"
#include "bindings/manual/jsb_global.h"


#include "bindings/auto/jsb_geometry_auto.h"



se::Class* __jsb_cc_geometry_ShapeBase_class = nullptr;
se::Object* __jsb_cc_geometry_ShapeBase_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_ShapeBase) 

static bool js_cc_geometry_ShapeBase_getType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::ShapeBase *arg1 = (cc::geometry::ShapeBase *) NULL ;
    cc::geometry::ShapeEnum result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::ShapeBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::ShapeEnum)((cc::geometry::ShapeBase const *)arg1)->getType();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_ShapeBase_getType) 

static bool js_cc_geometry_ShapeBase_setType(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::ShapeBase *arg1 = (cc::geometry::ShapeBase *) NULL ;
    cc::geometry::ShapeEnum arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::ShapeBase>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "ShapeBase_setType,2,SWIGTYPE_cc__geometry__ShapeEnum");
    arg2 = (cc::geometry::ShapeEnum)temp2;
    (arg1)->setType(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_ShapeBase_setType) 

// js_ctor
static bool js_new_cc_geometry_ShapeBase(se::State& s) // NOLINT(readability-identifier-naming)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    cc::geometry::ShapeBase *result;
    result = (cc::geometry::ShapeBase *)new cc::geometry::ShapeBase();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}
SE_BIND_CTOR(js_new_cc_geometry_ShapeBase, __jsb_cc_geometry_ShapeBase_class, js_delete_cc_geometry_ShapeBase)

static bool js_delete_cc_geometry_ShapeBase(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_ShapeBase) 

bool js_register_cc_geometry_ShapeBase(se::Object* obj) {
    auto* cls = se::Class::create("ShapeBase", obj, nullptr, _SE(js_new_cc_geometry_ShapeBase)); 
    
    
    cls->defineFunction("getType", _SE(js_cc_geometry_ShapeBase_getType)); 
    cls->defineFunction("setType", _SE(js_cc_geometry_ShapeBase_setType)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_ShapeBase));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::ShapeBase>(cls);
    
    __jsb_cc_geometry_ShapeBase_proto = cls->getProto();
    __jsb_cc_geometry_ShapeBase_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_AABB_class = nullptr;
se::Object* __jsb_cc_geometry_AABB_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_AABB) 

static bool js_cc_geometry_AABB_create_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::AABB *result = 0 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "AABB_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "AABB_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "AABB_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "AABB_create,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "AABB_create,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "AABB_create,6,SWIGTYPE_float"); 
    result = (cc::geometry::AABB *)cc::geometry::AABB::create(arg1,arg2,arg3,arg4,arg5,arg6);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AABB_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_AABB_create_static) 

static bool js_cc_geometry_AABB_toBoundingSphere_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::geometry::AABB temp2 ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "AABB_toBoundingSphere,1,SWIGTYPE_p_cc__geometry__Sphere"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AABB_toBoundingSphere,2,SWIGTYPE_p_cc__geometry__AABB");
    arg2 = &temp2;
    
    result = (cc::geometry::Sphere *)cc::geometry::AABB::toBoundingSphere(arg1,(cc::geometry::AABB const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AABB_toBoundingSphere, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_AABB_toBoundingSphere_static) 

static bool js_new_cc_geometry_AABB__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::AABB *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_AABB,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_AABB,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_AABB,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_AABB,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_AABB,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "new_AABB,6,SWIGTYPE_float"); 
    result = (cc::geometry::AABB *)new cc::geometry::AABB(arg1,arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_AABB__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::AABB *result;
    result = (cc::geometry::AABB *)new cc::geometry::AABB();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_AABB(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 6) {
        ret = js_new_cc_geometry_AABB__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_geometry_AABB__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of AABB");
    return false;
}
SE_BIND_CTOR(js_new_AABB, __jsb_cc_geometry_AABB_class, js_delete_cc_geometry_AABB)

static bool js_delete_cc_geometry_AABB(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_AABB) 

static bool js_cc_geometry_AABB_aabbPlane(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    cc::geometry::Plane *arg2 = 0 ;
    cc::geometry::Plane temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AABB_aabbPlane,2,SWIGTYPE_p_cc__geometry__Plane");
    arg2 = &temp2;
    
    result = (int)((cc::geometry::AABB const *)arg1)->aabbPlane((cc::geometry::Plane const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_AABB_aabbPlane) 

static bool js_cc_geometry_AABB_contain(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "AABB_contain,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    result = (bool)((cc::geometry::AABB const *)arg1)->contain((cc::Vec3 const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_AABB_contain) 

static bool js_cc_geometry_AABB_center_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->center, s.thisObject());
    SE_PRECONDITION2(ok, false, "AABB_center_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_AABB_center_set) 

static bool js_cc_geometry_AABB_center_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->center, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AABB_center_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->center, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_AABB_center_get) 

static bool js_cc_geometry_AABB_halfExtents_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->halfExtents, s.thisObject());
    SE_PRECONDITION2(ok, false, "AABB_halfExtents_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_AABB_halfExtents_set) 

static bool js_cc_geometry_AABB_halfExtents_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::AABB *arg1 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::AABB>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->halfExtents, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "AABB_halfExtents_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->halfExtents, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_AABB_halfExtents_get) 

bool js_register_cc_geometry_AABB(se::Object* obj) {
    auto* cls = se::Class::create("AABB", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_AABB)); 
    
    cls->defineProperty("center", _SE(js_cc_geometry_AABB_center_get), _SE(js_cc_geometry_AABB_center_set)); 
    cls->defineProperty("halfExtents", _SE(js_cc_geometry_AABB_halfExtents_get), _SE(js_cc_geometry_AABB_halfExtents_set)); 
    
    cls->defineFunction("aabbPlane", _SE(js_cc_geometry_AABB_aabbPlane)); 
    cls->defineFunction("contain", _SE(js_cc_geometry_AABB_contain)); 
    
    
    cls->defineStaticFunction("create", _SE(js_cc_geometry_AABB_create_static)); 
    cls->defineStaticFunction("toBoundingSphere", _SE(js_cc_geometry_AABB_toBoundingSphere_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_AABB));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::AABB>(cls);
    
    __jsb_cc_geometry_AABB_proto = cls->getProto();
    __jsb_cc_geometry_AABB_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Line_class = nullptr;
se::Object* __jsb_cc_geometry_Line_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Line) 

static bool js_cc_geometry_Line_create_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::Line *result = 0 ;
    
    if(argc != 6) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Line_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Line_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Line_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Line_create,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Line_create,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Line_create,6,SWIGTYPE_float"); 
    result = (cc::geometry::Line *)cc::geometry::Line::create(arg1,arg2,arg3,arg4,arg5,arg6);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Line_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Line_create_static) 

static bool js_cc_geometry_Line_clone_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = 0 ;
    cc::geometry::Line temp1 ;
    cc::geometry::Line *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_clone,1,SWIGTYPE_p_cc__geometry__Line");
    arg1 = &temp1;
    
    result = (cc::geometry::Line *)cc::geometry::Line::clone((cc::geometry::Line const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Line_clone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Line_clone_static) 

static bool js_cc_geometry_Line_copy_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    cc::geometry::Line *arg2 = 0 ;
    cc::geometry::Line temp2 ;
    cc::geometry::Line *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_copy,1,SWIGTYPE_p_cc__geometry__Line"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_copy,2,SWIGTYPE_p_cc__geometry__Line");
    arg2 = &temp2;
    
    result = (cc::geometry::Line *)cc::geometry::Line::copy(arg1,(cc::geometry::Line const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Line_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Line_copy_static) 

static bool js_cc_geometry_Line_fromPoints_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::geometry::Line *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_fromPoints,1,SWIGTYPE_p_cc__geometry__Line"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_fromPoints,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_fromPoints,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    result = (cc::geometry::Line *)cc::geometry::Line::fromPoints(arg1,(cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Line_fromPoints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Line_fromPoints_static) 

static bool js_cc_geometry_Line_set_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    cc::geometry::Line *result = 0 ;
    
    if(argc != 7) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 7);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_set,1,SWIGTYPE_p_cc__geometry__Line"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Line_set,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Line_set,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Line_set,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Line_set,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Line_set,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "Line_set,7,SWIGTYPE_float"); 
    result = (cc::geometry::Line *)cc::geometry::Line::set(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Line_set, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Line_set_static) 

static bool js_cc_geometry_Line_len_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = 0 ;
    cc::geometry::Line temp1 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_len,1,SWIGTYPE_p_cc__geometry__Line");
    arg1 = &temp1;
    
    result = (float)cc::geometry::Line::len((cc::geometry::Line const &)*arg1);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Line_len_static) 

static bool js_cc_geometry_Line_s_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Line>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->s, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_s_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Line_s_set) 

static bool js_cc_geometry_Line_s_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Line>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->s, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Line_s_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->s, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Line_s_get) 

static bool js_cc_geometry_Line_e_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Line>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->e, s.thisObject());
    SE_PRECONDITION2(ok, false, "Line_e_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Line_e_set) 

static bool js_cc_geometry_Line_e_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Line>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->e, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Line_e_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->e, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Line_e_get) 

static bool js_new_cc_geometry_Line__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::Line *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,6,SWIGTYPE_float"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::geometry::Line *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,5,SWIGTYPE_float"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2,arg3,arg4,arg5);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Line *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,4,SWIGTYPE_float"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Line *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,3,SWIGTYPE_float"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Line *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,2,SWIGTYPE_float"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Line *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Line,1,SWIGTYPE_float"); 
    result = (cc::geometry::Line *)new cc::geometry::Line(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_6(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Line *result;
    result = (cc::geometry::Line *)new cc::geometry::Line();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_7(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Line *arg1 = 0 ;
    cc::geometry::Line temp1 ;
    cc::geometry::Line *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Line,1,SWIGTYPE_p_cc__geometry__Line");
    arg1 = &temp1;
    
    result = (cc::geometry::Line *)new cc::geometry::Line((cc::geometry::Line const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Line__SWIG_8(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Line *arg1 = 0 ;
    cc::geometry::Line temp1 ;
    cc::geometry::Line *result;
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Line,1,SWIGTYPE_p_cc__geometry__Line");
    arg1 = &temp1;
    
    result = (cc::geometry::Line *)new cc::geometry::Line((cc::geometry::Line &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Line(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 6) {
        ret = js_new_cc_geometry_Line__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 5) {
        ret = js_new_cc_geometry_Line__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 4) {
        ret = js_new_cc_geometry_Line__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_cc_geometry_Line__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_geometry_Line__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Line__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_geometry_Line__SWIG_6(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Line__SWIG_7(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Line__SWIG_8(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Line");
    return false;
}
SE_BIND_CTOR(js_new_Line, __jsb_cc_geometry_Line_class, js_delete_cc_geometry_Line)

static bool js_delete_cc_geometry_Line(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Line) 

static bool js_cc_geometry_Line_length(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Line *arg1 = (cc::geometry::Line *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Line>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::geometry::Line const *)arg1)->length();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Line_length) 

bool js_register_cc_geometry_Line(se::Object* obj) {
    auto* cls = se::Class::create("Line", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Line)); 
    
    cls->defineProperty("s", _SE(js_cc_geometry_Line_s_get), _SE(js_cc_geometry_Line_s_set)); 
    cls->defineProperty("e", _SE(js_cc_geometry_Line_e_get), _SE(js_cc_geometry_Line_e_set)); 
    
    cls->defineFunction("length", _SE(js_cc_geometry_Line_length)); 
    
    
    cls->defineStaticFunction("create", _SE(js_cc_geometry_Line_create_static)); 
    cls->defineStaticFunction("clone", _SE(js_cc_geometry_Line_clone_static)); 
    cls->defineStaticFunction("copy", _SE(js_cc_geometry_Line_copy_static)); 
    cls->defineStaticFunction("fromPoints", _SE(js_cc_geometry_Line_fromPoints_static)); 
    cls->defineStaticFunction("set", _SE(js_cc_geometry_Line_set_static)); 
    cls->defineStaticFunction("len", _SE(js_cc_geometry_Line_len_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Line));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Line>(cls);
    
    __jsb_cc_geometry_Line_proto = cls->getProto();
    __jsb_cc_geometry_Line_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Plane_class = nullptr;
se::Object* __jsb_cc_geometry_Plane_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Plane) 

static bool js_cc_geometry_Plane_create_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Plane *result = 0 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Plane_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Plane_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Plane_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Plane_create,4,SWIGTYPE_float"); 
    result = (cc::geometry::Plane *)cc::geometry::Plane::create(arg1,arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Plane_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_create_static) 

static bool js_cc_geometry_Plane_setX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Plane_setX,2,SWIGTYPE_float"); 
    (arg1)->setX(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_setX) 

static bool js_cc_geometry_Plane_getX(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::geometry::Plane const *)arg1)->getX();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_getX) 

static bool js_cc_geometry_Plane_setY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Plane_setY,2,SWIGTYPE_float"); 
    (arg1)->setY(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_setY) 

static bool js_cc_geometry_Plane_getY(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::geometry::Plane const *)arg1)->getY();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_getY) 

static bool js_cc_geometry_Plane_setZ(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Plane_setZ,2,SWIGTYPE_float"); 
    (arg1)->setZ(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_setZ) 

static bool js_cc_geometry_Plane_getZ(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::geometry::Plane const *)arg1)->getZ();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_getZ) 

static bool js_cc_geometry_Plane_setW(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Plane_setW,2,SWIGTYPE_float"); 
    (arg1)->setW(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_setW) 

static bool js_cc_geometry_Plane_getW(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::geometry::Plane const *)arg1)->getW();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_getW) 

static bool js_new_cc_geometry_Plane__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Plane *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Plane,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Plane,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Plane,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Plane,4,SWIGTYPE_float"); 
    result = (cc::geometry::Plane *)new cc::geometry::Plane(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Plane__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Plane *result;
    result = (cc::geometry::Plane *)new cc::geometry::Plane();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Plane(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 4) {
        ret = js_new_cc_geometry_Plane__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_geometry_Plane__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Plane");
    return false;
}
SE_BIND_CTOR(js_new_Plane, __jsb_cc_geometry_Plane_class, js_delete_cc_geometry_Plane)

static bool js_cc_geometry_Plane_transform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Plane_transform,2,SWIGTYPE_p_cc__Mat4");
    arg2 = &temp2;
    
    (arg1)->transform((cc::Mat4 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_transform) 

static bool js_cc_geometry_Plane_n_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->n, s.thisObject());
    SE_PRECONDITION2(ok, false, "Plane_n_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Plane_n_set) 

static bool js_cc_geometry_Plane_n_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->n, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Plane_n_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->n, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Plane_n_get) 

static bool js_cc_geometry_Plane_d_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->d, nullptr);
    SE_PRECONDITION2(ok, false, "Plane_d_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Plane_d_set) 

static bool js_cc_geometry_Plane_d_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->d, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Plane_d_get) 

static bool js_cc_geometry_Plane_define__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Plane_define,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Plane_define,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Plane_define,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    (arg1)->define((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4);
    
    
    return true;
}

static bool js_cc_geometry_Plane_define__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Plane_define,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Plane_define,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    (arg1)->define((cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}

static bool js_cc_geometry_Plane_define(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_geometry_Plane_define__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_geometry_Plane_define__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Plane_define) 

static bool js_cc_geometry_Plane_distance(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Plane *arg1 = (cc::geometry::Plane *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    float result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Plane>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Plane_distance,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    result = (float)((cc::geometry::Plane const *)arg1)->distance((cc::Vec3 const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Plane_distance) 

static bool js_delete_cc_geometry_Plane(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Plane) 

bool js_register_cc_geometry_Plane(se::Object* obj) {
    auto* cls = se::Class::create("Plane", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Plane)); 
    
    cls->defineProperty("n", _SE(js_cc_geometry_Plane_n_get), _SE(js_cc_geometry_Plane_n_set)); 
    cls->defineProperty("d", _SE(js_cc_geometry_Plane_d_get), _SE(js_cc_geometry_Plane_d_set)); 
    
    cls->defineFunction("setX", _SE(js_cc_geometry_Plane_setX)); 
    cls->defineFunction("getX", _SE(js_cc_geometry_Plane_getX)); 
    cls->defineFunction("setY", _SE(js_cc_geometry_Plane_setY)); 
    cls->defineFunction("getY", _SE(js_cc_geometry_Plane_getY)); 
    cls->defineFunction("setZ", _SE(js_cc_geometry_Plane_setZ)); 
    cls->defineFunction("getZ", _SE(js_cc_geometry_Plane_getZ)); 
    cls->defineFunction("setW", _SE(js_cc_geometry_Plane_setW)); 
    cls->defineFunction("getW", _SE(js_cc_geometry_Plane_getW)); 
    cls->defineFunction("transform", _SE(js_cc_geometry_Plane_transform)); 
    cls->defineFunction("define", _SE(js_cc_geometry_Plane_define)); 
    cls->defineFunction("distance", _SE(js_cc_geometry_Plane_distance)); 
    
    
    cls->defineStaticFunction("create", _SE(js_cc_geometry_Plane_create_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Plane));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Plane>(cls);
    
    __jsb_cc_geometry_Plane_proto = cls->getProto();
    __jsb_cc_geometry_Plane_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Frustum_class = nullptr;
se::Object* __jsb_cc_geometry_Frustum_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Frustum) 

static bool js_cc_geometry_Frustum_createOrtho_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::Mat4 *arg6 = 0 ;
    cc::Mat4 temp6 ;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,1,SWIGTYPE_p_cc__geometry__Frustum"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,5,SWIGTYPE_float"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[5], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,6,SWIGTYPE_p_cc__Mat4");
    arg6 = &temp6;
    
    cc::geometry::Frustum::createOrtho(arg1,arg2,arg3,arg4,arg5,(cc::Mat4 const &)*arg6);
    
    
    return true;
}

static bool js_cc_geometry_Frustum_createFromAABB_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::geometry::AABB temp2 ;
    cc::geometry::Frustum *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_createFromAABB,1,SWIGTYPE_p_cc__geometry__Frustum"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_createFromAABB,2,SWIGTYPE_p_cc__geometry__AABB");
    arg2 = &temp2;
    
    result = (cc::geometry::Frustum *)cc::geometry::Frustum::createFromAABB(arg1,(cc::geometry::AABB const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Frustum_createFromAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Frustum_createFromAABB_static) 

static bool js_cc_geometry_Frustum_create_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    result = (cc::geometry::Frustum *)cc::geometry::Frustum::create();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Frustum_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Frustum_create_static) 

static bool js_cc_geometry_Frustum_clone_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = 0 ;
    cc::geometry::Frustum temp1 ;
    cc::geometry::Frustum *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_clone,1,SWIGTYPE_p_cc__geometry__Frustum");
    arg1 = &temp1;
    
    result = (cc::geometry::Frustum *)cc::geometry::Frustum::clone((cc::geometry::Frustum const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Frustum_clone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Frustum_clone_static) 

static bool js_cc_geometry_Frustum_copy_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::geometry::Frustum temp2 ;
    cc::geometry::Frustum *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_copy,1,SWIGTYPE_p_cc__geometry__Frustum"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_copy,2,SWIGTYPE_p_cc__geometry__Frustum");
    arg2 = &temp2;
    
    result = (cc::geometry::Frustum *)cc::geometry::Frustum::copy(arg1,(cc::geometry::Frustum const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Frustum_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Frustum_copy_static) 

static bool js_new_cc_geometry_Frustum__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Frustum *result;
    result = (cc::geometry::Frustum *)new cc::geometry::Frustum();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Frustum__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Frustum *arg1 = 0 ;
    cc::geometry::Frustum temp1 ;
    cc::geometry::Frustum *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Frustum,1,SWIGTYPE_p_cc__geometry__Frustum");
    arg1 = &temp1;
    
    result = (cc::geometry::Frustum *)new cc::geometry::Frustum((cc::geometry::Frustum const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Frustum(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_geometry_Frustum__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Frustum__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Frustum");
    return false;
}
SE_BIND_CTOR(js_new_Frustum, __jsb_cc_geometry_Frustum_class, js_delete_cc_geometry_Frustum)

static bool js_delete_cc_geometry_Frustum(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Frustum) 

static bool js_cc_geometry_Frustum_transform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Mat4 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_transform,2,SWIGTYPE_p_cc__Mat4");
    arg2 = &temp2;
    
    (arg1)->transform((cc::Mat4 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Frustum_transform) 

static bool js_cc_geometry_Frustum_createOrtho__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::Mat4 *arg6 = 0 ;
    cc::Mat4 temp6 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,5,SWIGTYPE_float"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[4], &temp6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_createOrtho,6,SWIGTYPE_p_cc__Mat4");
    arg6 = &temp6;
    
    (arg1)->createOrtho(arg2,arg3,arg4,arg5,(cc::Mat4 const &)*arg6);
    
    
    return true;
}

static bool js_cc_geometry_Frustum_createOrtho(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_geometry_Frustum_createOrtho_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_geometry_Frustum_createOrtho__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Frustum_createOrtho) 

static bool js_cc_geometry_Frustum_updatePlanes(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->updatePlanes();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Frustum_updatePlanes) 

static bool js_cc_geometry_Frustum_setAccurate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    bool arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) bool
    ok &= sevalue_to_native(args[0], &arg2);
    SE_PRECONDITION2(ok, false, "Frustum_setAccurate,2,SWIGTYPE_bool"); 
    (arg1)->setAccurate(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Frustum_setAccurate) 

static bool js_cc_geometry_Frustum_vertices_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->vertices, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_vertices_set,2,SWIGTYPE_ccstd__arrayT_cc__Vec3_8_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Frustum_vertices_set) 

static bool js_cc_geometry_Frustum_vertices_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->vertices, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Frustum_vertices_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->vertices, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Frustum_vertices_get) 

static bool js_cc_geometry_Frustum_planes_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->planes, s.thisObject());
    SE_PRECONDITION2(ok, false, "Frustum_planes_set,2,SWIGTYPE_ccstd__arrayT_cc__geometry__Plane_p_6_t"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Frustum_planes_set) 

static bool js_cc_geometry_Frustum_planes_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Frustum *arg1 = (cc::geometry::Frustum *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Frustum>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->planes, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Frustum_planes_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->planes, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Frustum_planes_get) 

bool js_register_cc_geometry_Frustum(se::Object* obj) {
    auto* cls = se::Class::create("Frustum", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Frustum)); 
    
    cls->defineProperty("vertices", _SE(js_cc_geometry_Frustum_vertices_get), _SE(js_cc_geometry_Frustum_vertices_set)); 
    cls->defineProperty("planes", _SE(js_cc_geometry_Frustum_planes_get), _SE(js_cc_geometry_Frustum_planes_set)); 
    
    cls->defineFunction("transform", _SE(js_cc_geometry_Frustum_transform)); 
    cls->defineFunction("createOrtho", _SE(js_cc_geometry_Frustum_createOrtho)); 
    cls->defineFunction("updatePlanes", _SE(js_cc_geometry_Frustum_updatePlanes)); 
    cls->defineFunction("setAccurate", _SE(js_cc_geometry_Frustum_setAccurate)); 
    
    
    cls->defineStaticFunction("createFromAABB", _SE(js_cc_geometry_Frustum_createFromAABB_static)); 
    cls->defineStaticFunction("create", _SE(js_cc_geometry_Frustum_create_static)); 
    cls->defineStaticFunction("clone", _SE(js_cc_geometry_Frustum_clone_static)); 
    cls->defineStaticFunction("copy", _SE(js_cc_geometry_Frustum_copy_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Frustum));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Frustum>(cls);
    
    __jsb_cc_geometry_Frustum_proto = cls->getProto();
    __jsb_cc_geometry_Frustum_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Capsule_class = nullptr;
se::Object* __jsb_cc_geometry_Capsule_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Capsule) 

static bool js_cc_geometry_Capsule_radius_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->radius, nullptr);
    SE_PRECONDITION2(ok, false, "Capsule_radius_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_radius_set) 

static bool js_cc_geometry_Capsule_radius_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->radius, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_radius_get) 

static bool js_cc_geometry_Capsule_halfHeight_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1->halfHeight, nullptr);
    SE_PRECONDITION2(ok, false, "Capsule_halfHeight_set,2,SWIGTYPE_float"); 
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_halfHeight_set) 

static bool js_cc_geometry_Capsule_halfHeight_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // out 1
    ok &= nativevalue_to_se(arg1->halfHeight, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_halfHeight_get) 

static bool js_cc_geometry_Capsule_axis_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    int32_t temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Capsule_axis_set,2,SWIGTYPE_cc__geometry__Capsule__CenterEnum");
    arg1->axis = (cc::geometry::Capsule::CenterEnum)temp2;
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_axis_set) 

static bool js_cc_geometry_Capsule_axis_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    int32_t temp ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // out 4
    s.rval().setInt32(static_cast<int32_t>(arg1->axis));
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_axis_get) 

static bool js_cc_geometry_Capsule_center_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->center, s.thisObject());
    SE_PRECONDITION2(ok, false, "Capsule_center_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_center_set) 

static bool js_cc_geometry_Capsule_center_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->center, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Capsule_center_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->center, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_center_get) 

static bool js_cc_geometry_Capsule_rotation_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->rotation, s.thisObject());
    SE_PRECONDITION2(ok, false, "Capsule_rotation_set,2,SWIGTYPE_cc__Quaternion"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_rotation_set) 

static bool js_cc_geometry_Capsule_rotation_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->rotation, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Capsule_rotation_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->rotation, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_rotation_get) 

static bool js_cc_geometry_Capsule_ellipseCenter0_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->ellipseCenter0, s.thisObject());
    SE_PRECONDITION2(ok, false, "Capsule_ellipseCenter0_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_ellipseCenter0_set) 

static bool js_cc_geometry_Capsule_ellipseCenter0_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->ellipseCenter0, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Capsule_ellipseCenter0_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ellipseCenter0, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_ellipseCenter0_get) 

static bool js_cc_geometry_Capsule_ellipseCenter1_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->ellipseCenter1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Capsule_ellipseCenter1_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Capsule_ellipseCenter1_set) 

static bool js_cc_geometry_Capsule_ellipseCenter1_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->ellipseCenter1, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Capsule_ellipseCenter1_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->ellipseCenter1, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Capsule_ellipseCenter1_get) 

static bool js_new_cc_geometry_Capsule__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Capsule::CenterEnum arg3 ;
    int32_t temp3 ;
    cc::geometry::Capsule *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Capsule,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Capsule,2,SWIGTYPE_float"); 
    // %typemap(in) enum SWIGTYPE (int32_t temp3)
    ok &= sevalue_to_native(args[2], &temp3);
    SE_PRECONDITION2(ok, false, "new_Capsule,3,SWIGTYPE_cc__geometry__Capsule__CenterEnum");
    arg3 = (cc::geometry::Capsule::CenterEnum)temp3;
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Capsule *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Capsule,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Capsule,2,SWIGTYPE_float"); 
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Capsule *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Capsule,1,SWIGTYPE_float"); 
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *result;
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = 0 ;
    cc::geometry::Capsule temp1 ;
    cc::geometry::Capsule *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Capsule,1,SWIGTYPE_p_cc__geometry__Capsule");
    arg1 = &temp1;
    
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule((cc::geometry::Capsule const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Capsule__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Capsule *arg1 = 0 ;
    cc::geometry::Capsule temp1 ;
    cc::geometry::Capsule *result;
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Capsule,1,SWIGTYPE_p_cc__geometry__Capsule");
    arg1 = &temp1;
    
    result = (cc::geometry::Capsule *)new cc::geometry::Capsule((cc::geometry::Capsule &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Capsule(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_cc_geometry_Capsule__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_geometry_Capsule__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Capsule__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_geometry_Capsule__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Capsule__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Capsule__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Capsule");
    return false;
}
SE_BIND_CTOR(js_new_Capsule, __jsb_cc_geometry_Capsule_class, js_delete_cc_geometry_Capsule)

static bool js_delete_cc_geometry_Capsule(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Capsule) 

static bool js_cc_geometry_Capsule_transform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Capsule *arg1 = (cc::geometry::Capsule *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Quaternion *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::geometry::Capsule *arg6 = (cc::geometry::Capsule *) NULL ;
    cc::Mat4 temp2 ;
    cc::Vec3 temp3 ;
    cc::Quaternion temp4 ;
    cc::Vec3 temp5 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Capsule>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Capsule_transform,2,SWIGTYPE_p_cc__Mat4");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Capsule_transform,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Capsule_transform,4,SWIGTYPE_p_cc__Quaternion");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Capsule_transform,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Capsule_transform,6,SWIGTYPE_p_cc__geometry__Capsule"); 
    ((cc::geometry::Capsule const *)arg1)->transform((cc::Mat4 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Quaternion const &)*arg4,(cc::Vec3 const &)*arg5,arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Capsule_transform) 

bool js_register_cc_geometry_Capsule(se::Object* obj) {
    auto* cls = se::Class::create("Capsule", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Capsule)); 
    
    cls->defineProperty("radius", _SE(js_cc_geometry_Capsule_radius_get), _SE(js_cc_geometry_Capsule_radius_set)); 
    cls->defineProperty("halfHeight", _SE(js_cc_geometry_Capsule_halfHeight_get), _SE(js_cc_geometry_Capsule_halfHeight_set)); 
    cls->defineProperty("axis", _SE(js_cc_geometry_Capsule_axis_get), _SE(js_cc_geometry_Capsule_axis_set)); 
    cls->defineProperty("center", _SE(js_cc_geometry_Capsule_center_get), _SE(js_cc_geometry_Capsule_center_set)); 
    cls->defineProperty("rotation", _SE(js_cc_geometry_Capsule_rotation_get), _SE(js_cc_geometry_Capsule_rotation_set)); 
    cls->defineProperty("ellipseCenter0", _SE(js_cc_geometry_Capsule_ellipseCenter0_get), _SE(js_cc_geometry_Capsule_ellipseCenter0_set)); 
    cls->defineProperty("ellipseCenter1", _SE(js_cc_geometry_Capsule_ellipseCenter1_get), _SE(js_cc_geometry_Capsule_ellipseCenter1_set)); 
    
    cls->defineFunction("transform", _SE(js_cc_geometry_Capsule_transform)); 
    
    
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Capsule));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Capsule>(cls);
    
    __jsb_cc_geometry_Capsule_proto = cls->getProto();
    __jsb_cc_geometry_Capsule_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Sphere_class = nullptr;
se::Object* __jsb_cc_geometry_Sphere_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Sphere) 

static bool js_cc_geometry_Sphere_create_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Sphere_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Sphere_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Sphere_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Sphere_create,4,SWIGTYPE_float"); 
    result = (cc::geometry::Sphere *)cc::geometry::Sphere::create(arg1,arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_create_static) 

static bool js_cc_geometry_Sphere_clone_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = 0 ;
    cc::geometry::Sphere temp1 ;
    cc::geometry::Sphere *result = 0 ;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_clone,1,SWIGTYPE_p_cc__geometry__Sphere");
    arg1 = &temp1;
    
    result = (cc::geometry::Sphere *)cc::geometry::Sphere::clone((cc::geometry::Sphere const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_clone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Sphere_copy_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Sphere *arg2 = 0 ;
    cc::geometry::Sphere temp2 ;
    cc::geometry::Sphere *result = 0 ;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_copy,1,SWIGTYPE_p_cc__geometry__Sphere"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_copy,2,SWIGTYPE_p_cc__geometry__Sphere");
    arg2 = &temp2;
    
    result = (cc::geometry::Sphere *)cc::geometry::Sphere::copy(arg1,(cc::geometry::Sphere const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Sphere_fromPoints_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_fromPoints,1,SWIGTYPE_p_cc__geometry__Sphere"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_fromPoints,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_fromPoints,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    result = (cc::geometry::Sphere *)cc::geometry::Sphere::fromPoints(arg1,(cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_fromPoints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_fromPoints_static) 

static bool js_cc_geometry_Sphere_set_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::geometry::Sphere *result = 0 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_set,1,SWIGTYPE_p_cc__geometry__Sphere"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Sphere_set,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Sphere_set,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Sphere_set,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Sphere_set,5,SWIGTYPE_float"); 
    result = (cc::geometry::Sphere *)cc::geometry::Sphere::set(arg1,arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_set, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_set_static) 

static bool js_cc_geometry_Sphere_mergePoint_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Sphere *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::geometry::Sphere temp2 ;
    cc::Vec3 temp3 ;
    cc::geometry::Sphere *result = 0 ;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_mergePoint,1,SWIGTYPE_p_cc__geometry__Sphere"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_mergePoint,2,SWIGTYPE_p_cc__geometry__Sphere");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_mergePoint,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    result = (cc::geometry::Sphere *)cc::geometry::Sphere::mergePoint(arg1,(cc::geometry::Sphere const &)*arg2,(cc::Vec3 const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_mergePoint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Sphere_mergeAABB_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Sphere *arg2 = 0 ;
    cc::geometry::AABB *arg3 = 0 ;
    cc::geometry::Sphere temp2 ;
    cc::geometry::AABB temp3 ;
    cc::geometry::Sphere *result = 0 ;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_mergeAABB,1,SWIGTYPE_p_cc__geometry__Sphere"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_mergeAABB,2,SWIGTYPE_p_cc__geometry__Sphere");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_mergeAABB,3,SWIGTYPE_p_cc__geometry__AABB");
    arg3 = &temp3;
    
    result = (cc::geometry::Sphere *)cc::geometry::Sphere::mergeAABB(arg1,(cc::geometry::Sphere const &)*arg2,(cc::geometry::AABB const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_mergeAABB, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_new_cc_geometry_Sphere__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Sphere *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,4,SWIGTYPE_float"); 
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Sphere__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Sphere *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,3,SWIGTYPE_float"); 
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Sphere__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Sphere *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,2,SWIGTYPE_float"); 
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Sphere__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Sphere *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Sphere,1,SWIGTYPE_float"); 
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Sphere__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Sphere *result;
    result = (cc::geometry::Sphere *)new cc::geometry::Sphere();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Sphere(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 4) {
        ret = js_new_cc_geometry_Sphere__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_cc_geometry_Sphere__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_geometry_Sphere__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Sphere__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_geometry_Sphere__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Sphere");
    return false;
}
SE_BIND_CTOR(js_new_Sphere, __jsb_cc_geometry_Sphere_class, js_delete_cc_geometry_Sphere)

static bool js_delete_cc_geometry_Sphere(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Sphere) 

static bool js_cc_geometry_Sphere_getRadius(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    float result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (float)((cc::geometry::Sphere const *)arg1)->getRadius();
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_getRadius) 

static bool js_cc_geometry_Sphere_getCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::Vec3 *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::Vec3 *) &((cc::geometry::Sphere const *)arg1)->getCenter();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_getCenter, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_getCenter) 

static bool js_cc_geometry_Sphere_setCenter(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_setCenter,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->setCenter((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_setCenter) 

static bool js_cc_geometry_Sphere_setRadius(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    float arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Sphere_setRadius,2,SWIGTYPE_float"); 
    (arg1)->setRadius(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_setRadius) 

static bool js_cc_geometry_Sphere_clone__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::Sphere *)((cc::geometry::Sphere const *)arg1)->clone();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_clone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Sphere_clone(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_clone_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_geometry_Sphere_clone__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_clone) 

static bool js_cc_geometry_Sphere_copy__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Sphere *arg2 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Sphere *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_copy,2,SWIGTYPE_p_cc__geometry__Sphere"); 
    result = (cc::geometry::Sphere *)((cc::geometry::Sphere const *)arg1)->copy(arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Sphere_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Sphere_copy(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_geometry_Sphere_copy_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_copy__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_copy) 

static bool js_cc_geometry_Sphere_define(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::AABB *arg2 = 0 ;
    cc::geometry::AABB temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_define,2,SWIGTYPE_p_cc__geometry__AABB");
    arg2 = &temp2;
    
    (arg1)->define((cc::geometry::AABB const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_define) 

static bool js_cc_geometry_Sphere_mergeAABB__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_mergeAABB,2,SWIGTYPE_p_cc__geometry__AABB"); 
    (arg1)->mergeAABB((cc::geometry::AABB const *)arg2);
    
    
    return true;
}

static bool js_cc_geometry_Sphere_mergeAABB(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_geometry_Sphere_mergeAABB_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_mergeAABB__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_mergeAABB) 

static bool js_cc_geometry_Sphere_mergePoint__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_mergePoint,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->mergePoint((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_geometry_Sphere_mergePoint(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_geometry_Sphere_mergePoint_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_mergePoint__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_mergePoint) 

static bool js_cc_geometry_Sphere_mergeFrustum(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::geometry::Frustum temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_mergeFrustum,2,SWIGTYPE_p_cc__geometry__Frustum");
    arg2 = &temp2;
    
    (arg1)->mergeFrustum((cc::geometry::Frustum const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_mergeFrustum) 

static bool js_cc_geometry_Sphere_merge__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::AABB *arg2 = (cc::geometry::AABB *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_merge,2,SWIGTYPE_p_cc__geometry__AABB"); 
    (arg1)->merge((cc::geometry::AABB const *)arg2);
    
    
    return true;
}

static bool js_cc_geometry_Sphere_merge__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_merge,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->merge((cc::Vec3 const &)*arg2);
    
    
    return true;
}

static bool js_cc_geometry_Sphere_merge__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    ccstd::vector< cc::Vec3 > *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_merge,2,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg2 = &temp2;
    
    (arg1)->merge((ccstd::vector< cc::Vec3 > const &)*arg2);
    
    
    return true;
}

static bool js_cc_geometry_Sphere_merge__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::geometry::Frustum temp2 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_merge,2,SWIGTYPE_p_cc__geometry__Frustum");
    arg2 = &temp2;
    
    (arg1)->merge((cc::geometry::Frustum const &)*arg2);
    
    
    return true;
}

static bool js_cc_geometry_Sphere_merge(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_merge__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_merge__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_merge__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_merge__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_merge) 

static bool js_cc_geometry_Sphere_interset__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::geometry::Frustum temp2 ;
    bool result;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_interset,2,SWIGTYPE_p_cc__geometry__Frustum");
    arg2 = &temp2;
    
    result = (bool)((cc::geometry::Sphere const *)arg1)->interset((cc::geometry::Frustum const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}

static bool js_cc_geometry_Sphere_interset__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Plane *arg2 = 0 ;
    cc::geometry::Plane temp2 ;
    int result;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_interset,2,SWIGTYPE_p_cc__geometry__Plane");
    arg2 = &temp2;
    
    result = (int)((cc::geometry::Sphere const *)arg1)->interset((cc::geometry::Plane const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}

static bool js_cc_geometry_Sphere_interset(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_interset__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Sphere_interset__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_interset) 

static bool js_cc_geometry_Sphere_spherePlane(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Plane *arg2 = 0 ;
    cc::geometry::Plane temp2 ;
    int result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_spherePlane,2,SWIGTYPE_p_cc__geometry__Plane");
    arg2 = &temp2;
    
    result = (int)(arg1)->spherePlane((cc::geometry::Plane const &)*arg2);
    
    // out 1
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_spherePlane) 

static bool js_cc_geometry_Sphere_sphereFrustum(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::geometry::Frustum *arg2 = 0 ;
    cc::geometry::Frustum temp2 ;
    bool result;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_sphereFrustum,2,SWIGTYPE_p_cc__geometry__Frustum");
    arg2 = &temp2;
    
    result = (bool)((cc::geometry::Sphere const *)arg1)->sphereFrustum((cc::geometry::Frustum const &)*arg2);
    // out 5
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_sphereFrustum) 

static bool js_cc_geometry_Sphere_transform(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Quaternion *arg4 = 0 ;
    cc::Vec3 *arg5 = 0 ;
    cc::geometry::Sphere *arg6 = (cc::geometry::Sphere *) NULL ;
    cc::Mat4 temp2 ;
    cc::Vec3 temp3 ;
    cc::Quaternion temp4 ;
    cc::Vec3 temp5 ;
    
    if(argc != 5) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_transform,2,SWIGTYPE_p_cc__Mat4");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_transform,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_transform,4,SWIGTYPE_p_cc__Quaternion");
    arg4 = &temp4;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp5, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_transform,5,SWIGTYPE_p_cc__Vec3");
    arg5 = &temp5;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[4], &arg6, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_transform,6,SWIGTYPE_p_cc__geometry__Sphere"); 
    ((cc::geometry::Sphere const *)arg1)->transform((cc::Mat4 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Quaternion const &)*arg4,(cc::Vec3 const &)*arg5,arg6);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_transform) 

static bool js_cc_geometry_Sphere_translateAndRotate(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::Mat4 *arg2 = 0 ;
    cc::Quaternion *arg3 = 0 ;
    cc::geometry::Sphere *arg4 = (cc::geometry::Sphere *) NULL ;
    cc::Mat4 temp2 ;
    cc::Quaternion temp3 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_translateAndRotate,2,SWIGTYPE_p_cc__Mat4");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_translateAndRotate,3,SWIGTYPE_p_cc__Quaternion");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[2], &arg4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_translateAndRotate,4,SWIGTYPE_p_cc__geometry__Sphere"); 
    ((cc::geometry::Sphere const *)arg1)->translateAndRotate((cc::Mat4 const &)*arg2,(cc::Quaternion const &)*arg3,arg4);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_translateAndRotate) 

static bool js_cc_geometry_Sphere_setScale(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Sphere *arg1 = (cc::geometry::Sphere *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::geometry::Sphere *arg3 = (cc::geometry::Sphere *) NULL ;
    cc::Vec3 temp2 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Sphere>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_setScale,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Sphere_setScale,3,SWIGTYPE_p_cc__geometry__Sphere"); 
    ((cc::geometry::Sphere const *)arg1)->setScale((cc::Vec3 const &)*arg2,arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Sphere_setScale) 

bool js_register_cc_geometry_Sphere(se::Object* obj) {
    auto* cls = se::Class::create("Sphere", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Sphere)); 
    
    
    cls->defineFunction("getRadius", _SE(js_cc_geometry_Sphere_getRadius)); 
    cls->defineFunction("getCenter", _SE(js_cc_geometry_Sphere_getCenter)); 
    cls->defineFunction("setCenter", _SE(js_cc_geometry_Sphere_setCenter)); 
    cls->defineFunction("setRadius", _SE(js_cc_geometry_Sphere_setRadius)); 
    cls->defineFunction("clone", _SE(js_cc_geometry_Sphere_clone)); 
    cls->defineFunction("copy", _SE(js_cc_geometry_Sphere_copy)); 
    cls->defineFunction("define", _SE(js_cc_geometry_Sphere_define)); 
    cls->defineFunction("mergeAABB", _SE(js_cc_geometry_Sphere_mergeAABB)); 
    cls->defineFunction("mergePoint", _SE(js_cc_geometry_Sphere_mergePoint)); 
    cls->defineFunction("mergeFrustum", _SE(js_cc_geometry_Sphere_mergeFrustum)); 
    cls->defineFunction("merge", _SE(js_cc_geometry_Sphere_merge)); 
    cls->defineFunction("interset", _SE(js_cc_geometry_Sphere_interset)); 
    cls->defineFunction("spherePlane", _SE(js_cc_geometry_Sphere_spherePlane)); 
    cls->defineFunction("sphereFrustum", _SE(js_cc_geometry_Sphere_sphereFrustum)); 
    cls->defineFunction("transform", _SE(js_cc_geometry_Sphere_transform)); 
    cls->defineFunction("translateAndRotate", _SE(js_cc_geometry_Sphere_translateAndRotate)); 
    cls->defineFunction("setScale", _SE(js_cc_geometry_Sphere_setScale)); 
    
    
    cls->defineStaticFunction("create", _SE(js_cc_geometry_Sphere_create_static)); 
    cls->defineStaticFunction("fromPoints", _SE(js_cc_geometry_Sphere_fromPoints_static)); 
    cls->defineStaticFunction("set", _SE(js_cc_geometry_Sphere_set_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Sphere));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Sphere>(cls);
    
    __jsb_cc_geometry_Sphere_proto = cls->getProto();
    __jsb_cc_geometry_Sphere_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Triangle_class = nullptr;
se::Object* __jsb_cc_geometry_Triangle_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Triangle) 

static bool js_cc_geometry_Triangle_create_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    float arg9 ;
    cc::geometry::Triangle *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,7,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[7], &arg8, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,8,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[8], &arg9, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,9,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    cc::geometry::Triangle *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,7,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[7], &arg8, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,8,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    cc::geometry::Triangle *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,7,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::Triangle *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,6,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create(arg1,arg2,arg3,arg4,arg5,arg6);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::geometry::Triangle *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,5,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create(arg1,arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Triangle *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,4,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create(arg1,arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Triangle *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,3,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create(arg1,arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static__SWIG_7(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    cc::geometry::Triangle *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,2,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create(arg1,arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static__SWIG_8(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    cc::geometry::Triangle *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_create,1,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static__SWIG_9(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Triangle *result = 0 ;
    
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::create();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Triangle_create_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 9) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 8) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 7) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_7(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_8(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_geometry_Triangle_create_static__SWIG_9(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Triangle_create_static) 

static bool js_cc_geometry_Triangle_clone_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = 0 ;
    cc::geometry::Triangle temp1 ;
    cc::geometry::Triangle *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_clone,1,SWIGTYPE_p_cc__geometry__Triangle");
    arg1 = &temp1;
    
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::clone((cc::geometry::Triangle const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_clone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Triangle_clone_static) 

static bool js_cc_geometry_Triangle_copy_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    cc::geometry::Triangle *arg2 = 0 ;
    cc::geometry::Triangle temp2 ;
    cc::geometry::Triangle *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_copy,1,SWIGTYPE_p_cc__geometry__Triangle"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_copy,2,SWIGTYPE_p_cc__geometry__Triangle");
    arg2 = &temp2;
    
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::copy(arg1,(cc::geometry::Triangle const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Triangle_copy_static) 

static bool js_cc_geometry_Triangle_fromPoints_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 *arg4 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::Vec3 temp4 ;
    cc::geometry::Triangle *result = 0 ;
    
    if(argc != 4) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_fromPoints,1,SWIGTYPE_p_cc__geometry__Triangle"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_fromPoints,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_fromPoints,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[3], &temp4, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_fromPoints,4,SWIGTYPE_p_cc__Vec3");
    arg4 = &temp4;
    
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::fromPoints(arg1,(cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3,(cc::Vec3 const &)*arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_fromPoints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Triangle_fromPoints_static) 

static bool js_cc_geometry_Triangle_set_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    float arg9 ;
    float arg10 ;
    cc::geometry::Triangle *result = 0 ;
    
    if(argc != 10) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 10);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_set,1,SWIGTYPE_p_cc__geometry__Triangle"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_set,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_set,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_set,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_set,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_set,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_set,7,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[7], &arg8, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_set,8,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[8], &arg9, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_set,9,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[9], &arg10, nullptr);
    SE_PRECONDITION2(ok, false, "Triangle_set,10,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)cc::geometry::Triangle::set(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_set, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Triangle_set_static) 

static bool js_cc_geometry_Triangle_a_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->a, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_a_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Triangle_a_set) 

static bool js_cc_geometry_Triangle_a_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->a, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_a_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->a, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Triangle_a_get) 

static bool js_cc_geometry_Triangle_b_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->b, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_b_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Triangle_b_set) 

static bool js_cc_geometry_Triangle_b_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->b, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_b_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->b, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Triangle_b_get) 

static bool js_cc_geometry_Triangle_c_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->c, s.thisObject());
    SE_PRECONDITION2(ok, false, "Triangle_c_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Triangle_c_set) 

static bool js_cc_geometry_Triangle_c_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = (cc::geometry::Triangle *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Triangle>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->c, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Triangle_c_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->c, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Triangle_c_get) 

static bool js_new_cc_geometry_Triangle__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    float arg9 ;
    cc::geometry::Triangle *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,7,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[7], &arg8, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,8,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[8], &arg9, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,9,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    float arg8 ;
    cc::geometry::Triangle *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,7,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[7], &arg8, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,8,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    cc::geometry::Triangle *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,7,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::Triangle *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,6,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::geometry::Triangle *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,5,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4,arg5);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Triangle *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,4,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_6(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Triangle *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,3,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_7(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Triangle *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,2,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_8(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Triangle *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_float"); 
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_9(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *result;
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_10(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = 0 ;
    cc::geometry::Triangle temp1 ;
    cc::geometry::Triangle *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_p_cc__geometry__Triangle");
    arg1 = &temp1;
    
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle((cc::geometry::Triangle const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Triangle__SWIG_11(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Triangle *arg1 = 0 ;
    cc::geometry::Triangle temp1 ;
    cc::geometry::Triangle *result;
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Triangle,1,SWIGTYPE_p_cc__geometry__Triangle");
    arg1 = &temp1;
    
    result = (cc::geometry::Triangle *)new cc::geometry::Triangle((cc::geometry::Triangle &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Triangle(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 9) {
        ret = js_new_cc_geometry_Triangle__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 8) {
        ret = js_new_cc_geometry_Triangle__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 7) {
        ret = js_new_cc_geometry_Triangle__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 6) {
        ret = js_new_cc_geometry_Triangle__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 5) {
        ret = js_new_cc_geometry_Triangle__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 4) {
        ret = js_new_cc_geometry_Triangle__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_cc_geometry_Triangle__SWIG_6(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_geometry_Triangle__SWIG_7(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Triangle__SWIG_8(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_geometry_Triangle__SWIG_9(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Triangle__SWIG_10(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Triangle__SWIG_11(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Triangle");
    return false;
}
SE_BIND_CTOR(js_new_Triangle, __jsb_cc_geometry_Triangle_class, js_delete_cc_geometry_Triangle)

static bool js_delete_cc_geometry_Triangle(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Triangle) 

bool js_register_cc_geometry_Triangle(se::Object* obj) {
    auto* cls = se::Class::create("Triangle", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Triangle)); 
    
    cls->defineProperty("a", _SE(js_cc_geometry_Triangle_a_get), _SE(js_cc_geometry_Triangle_a_set)); 
    cls->defineProperty("b", _SE(js_cc_geometry_Triangle_b_get), _SE(js_cc_geometry_Triangle_b_set)); 
    cls->defineProperty("c", _SE(js_cc_geometry_Triangle_c_get), _SE(js_cc_geometry_Triangle_c_set)); 
    
    
    
    cls->defineStaticFunction("create", _SE(js_cc_geometry_Triangle_create_static)); 
    cls->defineStaticFunction("clone", _SE(js_cc_geometry_Triangle_clone_static)); 
    cls->defineStaticFunction("copy", _SE(js_cc_geometry_Triangle_copy_static)); 
    cls->defineStaticFunction("fromPoints", _SE(js_cc_geometry_Triangle_fromPoints_static)); 
    cls->defineStaticFunction("set", _SE(js_cc_geometry_Triangle_set_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Triangle));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Triangle>(cls);
    
    __jsb_cc_geometry_Triangle_proto = cls->getProto();
    __jsb_cc_geometry_Triangle_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Ray_class = nullptr;
se::Object* __jsb_cc_geometry_Ray_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Ray) 

static bool js_cc_geometry_Ray_create_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::Ray *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,6,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)cc::geometry::Ray::create(arg1,arg2,arg3,arg4,arg5,arg6);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Ray_create_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::geometry::Ray *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,5,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)cc::geometry::Ray::create(arg1,arg2,arg3,arg4,arg5);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Ray_create_static__SWIG_2(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Ray *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,4,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)cc::geometry::Ray::create(arg1,arg2,arg3,arg4);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Ray_create_static__SWIG_3(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Ray *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,3,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)cc::geometry::Ray::create(arg1,arg2,arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Ray_create_static__SWIG_4(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    float arg2 ;
    cc::geometry::Ray *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,2,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)cc::geometry::Ray::create(arg1,arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Ray_create_static__SWIG_5(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    float arg1 ;
    cc::geometry::Ray *result = 0 ;
    
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_create,1,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)cc::geometry::Ray::create(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Ray_create_static__SWIG_6(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Ray *result = 0 ;
    
    result = (cc::geometry::Ray *)cc::geometry::Ray::create();
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Ray_create_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 6) {
        ok = js_cc_geometry_Ray_create_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 5) {
        ok = js_cc_geometry_Ray_create_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 4) {
        ok = js_cc_geometry_Ray_create_static__SWIG_2(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 3) {
        ok = js_cc_geometry_Ray_create_static__SWIG_3(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_geometry_Ray_create_static__SWIG_4(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Ray_create_static__SWIG_5(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 0) {
        ok = js_cc_geometry_Ray_create_static__SWIG_6(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Ray_create_static) 

static bool js_cc_geometry_Ray_clone_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Ray *arg1 = 0 ;
    cc::geometry::Ray temp1 ;
    cc::geometry::Ray *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ray_clone,1,SWIGTYPE_p_cc__geometry__Ray");
    arg1 = &temp1;
    
    result = (cc::geometry::Ray *)cc::geometry::Ray::clone((cc::geometry::Ray const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_clone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Ray_clone_static) 

static bool js_cc_geometry_Ray_copy_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    cc::geometry::Ray *arg2 = 0 ;
    cc::geometry::Ray temp2 ;
    cc::geometry::Ray *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ray_copy,1,SWIGTYPE_p_cc__geometry__Ray"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ray_copy,2,SWIGTYPE_p_cc__geometry__Ray");
    arg2 = &temp2;
    
    result = (cc::geometry::Ray *)cc::geometry::Ray::copy(arg1,(cc::geometry::Ray const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Ray_copy_static) 

static bool js_cc_geometry_Ray_fromPoints_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp2 ;
    cc::Vec3 temp3 ;
    cc::geometry::Ray *result = 0 ;
    
    if(argc != 3) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ray_fromPoints,1,SWIGTYPE_p_cc__geometry__Ray"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ray_fromPoints,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[2], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ray_fromPoints,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    result = (cc::geometry::Ray *)cc::geometry::Ray::fromPoints(arg1,(cc::Vec3 const &)*arg2,(cc::Vec3 const &)*arg3);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_fromPoints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Ray_fromPoints_static) 

static bool js_cc_geometry_Ray_set_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    float arg7 ;
    cc::geometry::Ray *result = 0 ;
    
    if(argc != 7) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 7);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ray_set,1,SWIGTYPE_p_cc__geometry__Ray"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_set,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_set,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_set,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_set,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_set,6,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[6], &arg7, nullptr);
    SE_PRECONDITION2(ok, false, "Ray_set,7,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)cc::geometry::Ray::set(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_set, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Ray_set_static) 

static bool js_cc_geometry_Ray_o_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Ray>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->o, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ray_o_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Ray_o_set) 

static bool js_cc_geometry_Ray_o_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Ray>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->o, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_o_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->o, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Ray_o_get) 

static bool js_cc_geometry_Ray_d_set(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Ray>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg1->d, s.thisObject());
    SE_PRECONDITION2(ok, false, "Ray_d_set,2,SWIGTYPE_cc__Vec3"); 
    
    
    
    return true;
}
SE_BIND_PROP_SET(js_cc_geometry_Ray_d_set) 

static bool js_cc_geometry_Ray_d_get(se::State& s)
{
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *arg1 = (cc::geometry::Ray *) NULL ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Ray>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(arg1->d, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Ray_d_get, Error processing arguments");
    SE_HOLD_RETURN_VALUE(arg1->d, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_PROP_GET(js_cc_geometry_Ray_d_get) 

static bool js_new_cc_geometry_Ray__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    float arg6 ;
    cc::geometry::Ray *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,5,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[5], &arg6, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,6,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2,arg3,arg4,arg5,arg6);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    float arg5 ;
    cc::geometry::Ray *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,4,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[4], &arg5, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,5,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2,arg3,arg4,arg5);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    float arg4 ;
    cc::geometry::Ray *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,3,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[3], &arg4, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,4,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2,arg3,arg4);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    float arg3 ;
    cc::geometry::Ray *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,2,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[2], &arg3, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,3,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2,arg3);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    float arg2 ;
    cc::geometry::Ray *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,1,SWIGTYPE_float"); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[1], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,2,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_5(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    float arg1 ;
    cc::geometry::Ray *result;
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg1, nullptr);
    SE_PRECONDITION2(ok, false, "new_Ray,1,SWIGTYPE_float"); 
    result = (cc::geometry::Ray *)new cc::geometry::Ray(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_6(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *result;
    result = (cc::geometry::Ray *)new cc::geometry::Ray();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_7(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *arg1 = 0 ;
    cc::geometry::Ray temp1 ;
    cc::geometry::Ray *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Ray,1,SWIGTYPE_p_cc__geometry__Ray");
    arg1 = &temp1;
    
    result = (cc::geometry::Ray *)new cc::geometry::Ray((cc::geometry::Ray const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Ray__SWIG_8(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Ray *arg1 = 0 ;
    cc::geometry::Ray temp1 ;
    cc::geometry::Ray *result;
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Ray,1,SWIGTYPE_p_cc__geometry__Ray");
    arg1 = &temp1;
    
    result = (cc::geometry::Ray *)new cc::geometry::Ray((cc::geometry::Ray &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Ray(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 6) {
        ret = js_new_cc_geometry_Ray__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 5) {
        ret = js_new_cc_geometry_Ray__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 4) {
        ret = js_new_cc_geometry_Ray__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 3) {
        ret = js_new_cc_geometry_Ray__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_geometry_Ray__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Ray__SWIG_5(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_geometry_Ray__SWIG_6(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Ray__SWIG_7(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Ray__SWIG_8(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Ray");
    return false;
}
SE_BIND_CTOR(js_new_Ray, __jsb_cc_geometry_Ray_class, js_delete_cc_geometry_Ray)

static bool js_delete_cc_geometry_Ray(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Ray) 

bool js_register_cc_geometry_Ray(se::Object* obj) {
    auto* cls = se::Class::create("Ray", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Ray)); 
    
    cls->defineProperty("o", _SE(js_cc_geometry_Ray_o_get), _SE(js_cc_geometry_Ray_o_set)); 
    cls->defineProperty("d", _SE(js_cc_geometry_Ray_d_get), _SE(js_cc_geometry_Ray_d_set)); 
    
    
    
    cls->defineStaticFunction("create", _SE(js_cc_geometry_Ray_create_static)); 
    cls->defineStaticFunction("clone", _SE(js_cc_geometry_Ray_clone_static)); 
    cls->defineStaticFunction("copy", _SE(js_cc_geometry_Ray_copy_static)); 
    cls->defineStaticFunction("fromPoints", _SE(js_cc_geometry_Ray_fromPoints_static)); 
    cls->defineStaticFunction("set", _SE(js_cc_geometry_Ray_set_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Ray));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Ray>(cls);
    
    __jsb_cc_geometry_Ray_proto = cls->getProto();
    __jsb_cc_geometry_Ray_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}


se::Class* __jsb_cc_geometry_Spline_class = nullptr;
se::Object* __jsb_cc_geometry_Spline_proto = nullptr;
SE_DECLARE_FINALIZE_FUNC(js_delete_cc_geometry_Spline) 

static bool js_new_cc_geometry_Spline__SWIG_0(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::SplineMode arg1 ;
    ccstd::vector< cc::Vec3 > arg2 ;
    int32_t temp1 ;
    cc::geometry::Spline *result;
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "new_Spline,1,SWIGTYPE_cc__geometry__SplineMode");
    arg1 = (cc::geometry::SplineMode)temp1;
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Spline,2,SWIGTYPE_ccstd__vectorT_cc__Vec3_t"); 
    
    result = (cc::geometry::Spline *)new cc::geometry::Spline(arg1,arg2);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Spline__SWIG_1(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::SplineMode arg1 ;
    int32_t temp1 ;
    cc::geometry::Spline *result;
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "new_Spline,1,SWIGTYPE_cc__geometry__SplineMode");
    arg1 = (cc::geometry::SplineMode)temp1;
    result = (cc::geometry::Spline *)new cc::geometry::Spline(arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Spline__SWIG_2(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Spline *result;
    result = (cc::geometry::Spline *)new cc::geometry::Spline();
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Spline__SWIG_3(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Spline *arg1 = 0 ;
    cc::geometry::Spline temp1 ;
    cc::geometry::Spline *result;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Spline,1,SWIGTYPE_p_cc__geometry__Spline");
    arg1 = &temp1;
    
    result = (cc::geometry::Spline *)new cc::geometry::Spline((cc::geometry::Spline const &)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_cc_geometry_Spline__SWIG_4(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_overloaded_ctor
    const auto& args = s.args();
    CC_UNUSED bool ok = true;
    cc::geometry::Spline *arg1 = 0 ;
    cc::geometry::Spline temp1 ;
    cc::geometry::Spline *result;
    // %typemap(in) SWIGTYPE&&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "new_Spline,1,SWIGTYPE_p_cc__geometry__Spline");
    arg1 = &temp1;
    
    result = (cc::geometry::Spline *)new cc::geometry::Spline((cc::geometry::Spline &&)*arg1);
    
    
    auto *ptr = JSB_MAKE_PRIVATE_OBJECT_WITH_INSTANCE(result);
    s.thisObject()->setPrivateObject(ptr);
    return true;
}


static bool js_new_Spline(se::State& s) // NOLINT(readability-identifier-naming)
{
    // js_ctor_dispatcher
    size_t argc = s.args().size();
    bool ret = false;
    
    // switch all cases by means of series of if-returns.
    
    // js_ctor_dispatch_case
    if(argc == 2) {
        ret = js_new_cc_geometry_Spline__SWIG_0(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Spline__SWIG_1(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 0) {
        ret = js_new_cc_geometry_Spline__SWIG_2(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Spline__SWIG_3(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    // js_ctor_dispatch_case
    if(argc == 1) {
        ret = js_new_cc_geometry_Spline__SWIG_4(s);
        if (ret) {
            return ret; 
        } /* reset exception and return */
    }
    
    
    // default:
    SE_REPORT_ERROR("Illegal arguments for construction of Spline");
    return false;
}
SE_BIND_CTOR(js_new_Spline, __jsb_cc_geometry_Spline_class, js_delete_cc_geometry_Spline)

static bool js_delete_cc_geometry_Spline(se::State& s)
{
    // js_dtoroverride
    return true;
}
SE_BIND_FINALIZE_FUNC(js_delete_cc_geometry_Spline) 

static bool js_cc_geometry_Spline_create_static__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::SplineMode arg1 ;
    ccstd::vector< cc::Vec3 > *arg2 = 0 ;
    int32_t temp1 ;
    ccstd::vector< cc::Vec3 > temp2 ;
    cc::geometry::Spline *result = 0 ;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "Spline_create,1,SWIGTYPE_cc__geometry__SplineMode");
    arg1 = (cc::geometry::SplineMode)temp1;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_create,2,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg2 = &temp2;
    
    result = (cc::geometry::Spline *)cc::geometry::Spline::create(arg1,(ccstd::vector< cc::Vec3 > const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Spline_create_static__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::SplineMode arg1 ;
    int32_t temp1 ;
    cc::geometry::Spline *result = 0 ;
    
    // %typemap(in) enum SWIGTYPE (int32_t temp1)
    ok &= sevalue_to_native(args[0], &temp1);
    SE_PRECONDITION2(ok, false, "Spline_create,1,SWIGTYPE_cc__geometry__SplineMode");
    arg1 = (cc::geometry::SplineMode)temp1;
    result = (cc::geometry::Spline *)cc::geometry::Spline::create(arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_create, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Spline_create_static(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_geometry_Spline_create_static__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Spline_create_static__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Spline_create_static) 

static bool js_cc_geometry_Spline_clone_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = 0 ;
    cc::geometry::Spline temp1 ;
    cc::geometry::Spline *result = 0 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_clone,1,SWIGTYPE_p_cc__geometry__Spline");
    arg1 = &temp1;
    
    result = (cc::geometry::Spline *)cc::geometry::Spline::clone((cc::geometry::Spline const &)*arg1);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_clone, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_clone_static) 

static bool js_cc_geometry_Spline_copy_static(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::geometry::Spline *arg2 = 0 ;
    cc::geometry::Spline temp2 ;
    cc::geometry::Spline *result = 0 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    // %typemap(in) SWIGTYPE*
    ok &= sevalue_to_native(args[0], &arg1, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_copy,1,SWIGTYPE_p_cc__geometry__Spline"); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_copy,2,SWIGTYPE_p_cc__geometry__Spline");
    arg2 = &temp2;
    
    result = (cc::geometry::Spline *)cc::geometry::Spline::copy(arg1,(cc::geometry::Spline const &)*arg2);
    // %typemap(out) SWIGTYPE*
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_copy, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_copy_static) 

static bool js_cc_geometry_Spline_setMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::geometry::SplineMode arg2 ;
    int32_t temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Spline_setMode,2,SWIGTYPE_cc__geometry__SplineMode");
    arg2 = (cc::geometry::SplineMode)temp2;
    (arg1)->setMode(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_setMode) 

static bool js_cc_geometry_Spline_getMode(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::geometry::SplineMode result;
    int32_t temp ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (cc::geometry::SplineMode)((cc::geometry::Spline const *)arg1)->getMode();
    // out 4
    s.rval().setInt32(static_cast<int32_t>(result));
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getMode) 

static bool js_cc_geometry_Spline_setKnots(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    ccstd::vector< cc::Vec3 > *arg2 = 0 ;
    ccstd::vector< cc::Vec3 > temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_setKnots,2,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg2 = &temp2;
    
    (arg1)->setKnots((ccstd::vector< cc::Vec3 > const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_setKnots) 

static bool js_cc_geometry_Spline_getKnots(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    ccstd::vector< cc::Vec3 > *result = 0 ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = (ccstd::vector< cc::Vec3 > *) &((cc::geometry::Spline const *)arg1)->getKnots();
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_getKnots, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getKnots) 

static bool js_cc_geometry_Spline_clearKnots(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    (arg1)->clearKnots();
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_clearKnots) 

static bool js_cc_geometry_Spline_getKnotCount(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t result;
    
    if(argc != 0) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    result = ((cc::geometry::Spline const *)arg1)->getKnotCount();
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_getKnotCount, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getKnotCount) 

static bool js_cc_geometry_Spline_addKnot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::Vec3 *arg2 = 0 ;
    cc::Vec3 temp2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[0], &temp2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_addKnot,2,SWIGTYPE_p_cc__Vec3");
    arg2 = &temp2;
    
    (arg1)->addKnot((cc::Vec3 const &)*arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_addKnot) 

static bool js_cc_geometry_Spline_setModeAndKnots(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    cc::geometry::SplineMode arg2 ;
    ccstd::vector< cc::Vec3 > *arg3 = 0 ;
    int32_t temp2 ;
    ccstd::vector< cc::Vec3 > temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) enum SWIGTYPE (int32_t temp2)
    ok &= sevalue_to_native(args[0], &temp2);
    SE_PRECONDITION2(ok, false, "Spline_setModeAndKnots,2,SWIGTYPE_cc__geometry__SplineMode");
    arg2 = (cc::geometry::SplineMode)temp2;
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_setModeAndKnots,3,SWIGTYPE_p_ccstd__vectorT_cc__Vec3_t");
    arg3 = &temp3;
    
    (arg1)->setModeAndKnots(arg2,(ccstd::vector< cc::Vec3 > const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_setModeAndKnots) 

static bool js_cc_geometry_Spline_insertKnot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_insertKnot,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_insertKnot,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    (arg1)->insertKnot(arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_insertKnot) 

static bool js_cc_geometry_Spline_removeKnot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    
    if(argc != 1) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_removeKnot,2,SWIGTYPE_uint32_t"); 
    
    (arg1)->removeKnot(arg2);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_removeKnot) 

static bool js_cc_geometry_Spline_setKnot(se::State& s)
{
    // js_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    cc::Vec3 *arg3 = 0 ;
    cc::Vec3 temp3 ;
    
    if(argc != 2) {
        SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
        return false;
    }
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_setKnot,2,SWIGTYPE_uint32_t"); 
    
    // %typemap(in) SWIGTYPE&
    ok &= sevalue_to_native(args[1], &temp3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_setKnot,3,SWIGTYPE_p_cc__Vec3");
    arg3 = &temp3;
    
    (arg1)->setKnot(arg2,(cc::Vec3 const &)*arg3);
    
    
    return true;
}
SE_BIND_FUNC(js_cc_geometry_Spline_setKnot) 

static bool js_cc_geometry_Spline_getKnot__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_getKnot,2,SWIGTYPE_uint32_t"); 
    
    result = (cc::Vec3 *) &((cc::geometry::Spline const *)arg1)->getKnot(arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_getKnot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Spline_getKnot__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    cc::Vec3 *result = 0 ;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_getKnot,2,SWIGTYPE_uint32_t"); 
    
    result = (cc::Vec3 *) &(arg1)->getKnot(arg2);
    // %typemap(out) SWIGTYPE&
    ok &= nativevalue_to_se(*result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_getKnot, Error processing arguments");
    SE_HOLD_RETURN_VALUE(*result, s.thisObject(), s.rval()); 
    
    
    return true;
}

static bool js_cc_geometry_Spline_getKnot(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Spline_getKnot__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Spline_getKnot__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getKnot) 

static bool js_cc_geometry_Spline_getPoint__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    float arg2 ;
    uint32_t arg3 ;
    cc::Vec3 result;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Spline_getPoint,2,SWIGTYPE_float"); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_getPoint,3,SWIGTYPE_uint32_t"); 
    
    result = ((cc::geometry::Spline const *)arg1)->getPoint(arg2,arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_getPoint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_geometry_Spline_getPoint__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    float arg2 ;
    cc::Vec3 result;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    // %typemap(in) int, short, long, signed char, float, double
    ok &= sevalue_to_native(args[0], &arg2, nullptr);
    SE_PRECONDITION2(ok, false, "Spline_getPoint,2,SWIGTYPE_float"); 
    result = ((cc::geometry::Spline const *)arg1)->getPoint(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_getPoint, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_geometry_Spline_getPoint(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_geometry_Spline_getPoint__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Spline_getPoint__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getPoint) 

static bool js_cc_geometry_Spline_getPoints__SWIG_0(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    uint32_t arg3 ;
    ccstd::vector< cc::Vec3 > result;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_getPoints,2,SWIGTYPE_uint32_t"); 
    
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[1], &arg3, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_getPoints,3,SWIGTYPE_uint32_t"); 
    
    result = ((cc::geometry::Spline const *)arg1)->getPoints(arg2,arg3);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_getPoints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_geometry_Spline_getPoints__SWIG_1(se::State& s)
{
    // js_overloaded_function
    
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cc::geometry::Spline *arg1 = (cc::geometry::Spline *) NULL ;
    uint32_t arg2 ;
    ccstd::vector< cc::Vec3 > result;
    
    arg1 = SE_THIS_OBJECT<cc::geometry::Spline>(s);
    SE_PRECONDITION2(arg1, false, "%s: Invalid Native Object", __FUNCTION__); 
    
    // %typemap(in) SWIGTYPE value in
    ok &= sevalue_to_native(args[0], &arg2, s.thisObject());
    SE_PRECONDITION2(ok, false, "Spline_getPoints,2,SWIGTYPE_uint32_t"); 
    
    result = ((cc::geometry::Spline const *)arg1)->getPoints(arg2);
    // %typemap(out) SWIGTYPE
    ok &= nativevalue_to_se(result, s.rval(), s.thisObject() /*ctx*/);
    SE_PRECONDITION2(ok, false, "Spline_getPoints, Error processing arguments");
    SE_HOLD_RETURN_VALUE(result, s.thisObject(), s.rval());
    
    
    
    return true;
}

static bool js_cc_geometry_Spline_getPoints(se::State& s)
{
    // js_function_dispatcher
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    
    // js_function_dispatch_case
    if (argc == 2) {
        ok = js_cc_geometry_Spline_getPoints__SWIG_0(s);
        if (ok) {
            return true; 
        }
    } // js_function_dispatch_case
    if (argc == 1) {
        ok = js_cc_geometry_Spline_getPoints__SWIG_1(s);
        if (ok) {
            return true; 
        }
    } 
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cc_geometry_Spline_getPoints) 

bool js_register_cc_geometry_Spline(se::Object* obj) {
    auto* cls = se::Class::create("Spline", obj, __jsb_cc_geometry_ShapeBase_proto, _SE(js_new_Spline)); 
    
    
    cls->defineFunction("setMode", _SE(js_cc_geometry_Spline_setMode)); 
    cls->defineFunction("getMode", _SE(js_cc_geometry_Spline_getMode)); 
    cls->defineFunction("setKnots", _SE(js_cc_geometry_Spline_setKnots)); 
    cls->defineFunction("getKnots", _SE(js_cc_geometry_Spline_getKnots)); 
    cls->defineFunction("clearKnots", _SE(js_cc_geometry_Spline_clearKnots)); 
    cls->defineFunction("getKnotCount", _SE(js_cc_geometry_Spline_getKnotCount)); 
    cls->defineFunction("addKnot", _SE(js_cc_geometry_Spline_addKnot)); 
    cls->defineFunction("setModeAndKnots", _SE(js_cc_geometry_Spline_setModeAndKnots)); 
    cls->defineFunction("insertKnot", _SE(js_cc_geometry_Spline_insertKnot)); 
    cls->defineFunction("removeKnot", _SE(js_cc_geometry_Spline_removeKnot)); 
    cls->defineFunction("setKnot", _SE(js_cc_geometry_Spline_setKnot)); 
    cls->defineFunction("getKnot", _SE(js_cc_geometry_Spline_getKnot)); 
    cls->defineFunction("getPoint", _SE(js_cc_geometry_Spline_getPoint)); 
    cls->defineFunction("getPoints", _SE(js_cc_geometry_Spline_getPoints)); 
    
    
    cls->defineStaticFunction("create", _SE(js_cc_geometry_Spline_create_static)); 
    cls->defineStaticFunction("clone", _SE(js_cc_geometry_Spline_clone_static)); 
    cls->defineStaticFunction("copy", _SE(js_cc_geometry_Spline_copy_static)); 
    
    
    cls->defineFinalizeFunction(_SE(js_delete_cc_geometry_Spline));
    
    
    cls->install();
    JSBClassType::registerClass<cc::geometry::Spline>(cls);
    
    __jsb_cc_geometry_Spline_proto = cls->getProto();
    __jsb_cc_geometry_Spline_class = cls;
    se::ScriptEngine::getInstance()->clearException();
    return true;
}




bool register_all_geometry(se::Object* obj) {
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("ns", &nsVal, true))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("ns", nsVal);
    }
    se::Object* ns = nsVal.toObject();
    /* Register classes */
    js_register_cc_geometry_ShapeBase(ns); 
    js_register_cc_geometry_AABB(ns); 
    js_register_cc_geometry_Line(ns); 
    js_register_cc_geometry_Plane(ns); 
    js_register_cc_geometry_Frustum(ns); 
    js_register_cc_geometry_Capsule(ns); 
    js_register_cc_geometry_Sphere(ns); 
    js_register_cc_geometry_Triangle(ns); 
    js_register_cc_geometry_Ray(ns); 
    js_register_cc_geometry_Spline(ns); 
    
    /* Register global variables & global functions */
    
    
    
    return true;
}

// clang-format on
