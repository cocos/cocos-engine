const pkg = require('../../../package.json');
const version = pkg.version.replace(/(^\d+\.\d+)\..*$/, (str, a) => {
    return a;
});

const url = 'https://docs.cocos.com/creator';

module.exports = {
    menu: {
        custom_script: 'Custom script',
    },
    help: {
        cc: {
            Node: `${url}/${version}/manual/en/concepts/scene/node-component.html`,
            MeshRenderer: `${url}/${version}/manual/en/engine/renderable/model-component.html`,
            UITransform: `${url}/${version}/manual/en/ui-system/components/editor/ui-transform.html`,
            Sprite: `${url}/${version}/manual/en/ui-system/components/editor/sprite.html`,
            SubContextView: `${url}/${version}/manual/zh/editor/publish/build-open-data-context.html`,
            BlockInputEvents: `${url}/${version}/manual/en/ui-system/components/editor/block-input-events.html`,
            Camera: `${url}/${version}/manual/en/editor/components/camera-component.html`,
            Canvas: `${url}/${version}/manual/en/ui-system/components/editor/canvas.html`,
            SkinnedMeshRenderer: `${url}/${version}/manual/en/engine/animation/skeletal-animation.html`,
            SkinnedMeshBatchRenderer: `${url}/${version}/manual/en/engine/animation/skeletal-animation.html`,
            DirectionalLight: `${url}/${version}/manual/en/concepts/scene/light/dir-light.html`,
            SphereLight: `${url}/${version}/manual/en/concepts/scene/light/sphere-light.html`,
            SpotLight: `${url}/${version}/manual/en/concepts/scene/light/spot-light.html`,
            UICoordinateTracker: `${url}/${version}/manual/en/ui-system/components/editor/ui-coordinate-tracker.html`,
            Animation: `${url}/${version}/manual/en/engine/animation/animation-component.html`,
            SkeletalAnimation: `${url}/${version}/manual/en/engine/animation/skeletal-animation.html`,
            AudioSource: `${url}/${version}/manual/en/audio-system/overview.html`,
            Billboard: `${url}/${version}/manual/en/particle-system/billboard-component.html`,
            Line: `${url}/${version}/manual/en/particle-system/line-component.html`,
            ParticleSystem: `${url}/${version}/manual/en/particle-system/main-module.html`,
            Button: `${url}/${version}/manual/en/ui-system/components/editor/button.html`,
            Label: `${url}/${version}/manual/en/ui-system/components/editor/label.html`,
            EditBox: `${url}/${version}/manual/en/ui-system/components/editor/editbox.html`,
            Layout: `${url}/${version}/manual/en/ui-system/components/editor/layout.html`,
            Graphics: `${url}/${version}/manual/en/ui-system/components/editor/graphics.html`,
            Mask: `${url}/${version}/manual/en/ui-system/components/editor/mask.html`,
            ProgressBar: `${url}/${version}/manual/en/ui-system/components/editor/progress.html`,
            LabelOutline: `${url}/${version}/manual/en/ui-system/components/editor/label-outline.html`,
            RichText: `${url}/${version}/manual/en/ui-system/components/editor/richtext.html`,
            ScrollBar: `${url}/${version}/manual/en/ui-system/components/editor/scrollbar.html`,
            ScrollView: `${url}/${version}/manual/en/ui-system/components/editor/scrollview.html`,
            Slider: `${url}/${version}/manual/en/ui-system/components/editor/slider.html`,
            ToggleContainer: `${url}/${version}/manual/en/ui-system/components/editor/toggleContainer.html`,
            Toggle: `${url}/${version}/manual/en/ui-system/components/editor/toggle.html`,
            UIMeshRenderer: `${url}/${version}/manual/en/ui-system/components/editor/ui-model.html`,
            Widget: `${url}/${version}/manual/en/ui-system/components/editor/widget.html`,
            PageViewIndicator: `${url}/${version}/manual/en/ui-system/components/editor/pageviewindicator.html`,
            PageView: `${url}/${version}/manual/en/ui-system/components/editor/pageview.html`,
            UIStaticBatch: `${url}/${version}/manual/en/ui-system/components/editor/ui-static.html`,
            UIOpacity: `${url}/${version}/manual/en/ui-system/components/editor/ui-opacity.html`,
            BoxCollider: `${url}/${version}/manual/en/physics/physics-collider.html`,
            SphereCollider: `${url}/${version}/manual/en/physics/physics-component.html`,
            CapsuleCollider: `${url}/${version}/manual/en/physics/physics-component.html`,
            CylinderCollider: `${url}/${version}/manual/en/physics/physics-component.html`,
            MeshCollider: `${url}/${version}/manual/en/physics/physics-component.html`,
            RigidBody: `${url}/${version}/manual/en/physics/physics-rigidbody.html`,
            ConstantForce: `${url}/${version}/manual/en/physics/physics-component.html`,
            VideoPlayer: `${url}/${version}/manual/en/ui-system/components/editor/videoplayer.html`,
            WebView: `${url}/${version}/manual/en/ui-system/components/editor/webview.html`,
            SafeArea: `${url}/${version}/manual/en/ui-system/components/editor/safearea.html`,
            Terrain: `${url}/${version}/manual/en/editor/terrain/`,
            TiledMap: ``,
            Spine: ``,
        },
    },
    animation: {
        default_clip: 'When checking, the deault animation clip is automatically played.',
        clips: 'You can access and play animation clips via a script',
        play_on_load: 'Automatically play animation clip with the scene is loaded',
        use_baked_animation:
            'Whether to bake animations. Default to true,\nwhich substantially increases performance while making all animations completely fixed',
        sockets:
            'The joint sockets this animation component maintains.\nSockets have to be registered before attaching custom nodes to animated joints',
    },
    audio: {
        clip: 'The default AudioClip to be played for this audio source',
        volume: 'The volume of this audio source',
        loop: 'Is looping enabled for this audio source?',
        playOnAwake: 'Is auto-play enabled for this audio source?',
    },
    batched_skinning_model: {
        atlas_size: 'Size of the generated texture atlas',
        batchable_texture_names:
            "Texture properties that will be actually using the generated atlas.\nThe first unit's texture will be used if not specified",
        units: 'Source skinning model components, containing all the data to be batched',
    },
    camera: {
        priority: 'Render priority of the camera, in ascending-order',
        visibility: 'Visibility mask, declaring a set of node layers that will be visible to this camera',
        clear_flags: 'Clearing flags of the camera, specifies which part of the framebuffer will be actually cleared every frame',
        color: 'Clearing color of the camera',
        depth: 'Clearing depth of the camera',
        stencil: 'Clearing stencil of the camera',
        projection: 'Projection type of the camera',
        fov_axis: 'The axis on which the FOV would be fixed regardless of screen aspect changes',
        fov: 'Field of view of the camera',
        ortho_height: 'Viewport height in orthographic mode',
        near: 'Near clipping distance of the camera, should be as large as possible within acceptable range',
        far: 'Far clipping distance of the camera, should be as small as possible within acceptable range',
        aperture: 'Camera aperture, controls the exposure parameter',
        shutter: 'Camera shutter, controls the exposure parameter',
        ISO: 'Camera ISO, controls the exposure parameter',
        rect: 'Screen viewport of the camera wrt. the sceen size',
        target_texture: 'Output render texture of the camera. Default to null, which outputs directly to screen',
    },
    lights: {
        color: 'Color of the light',
        use_color_temperature: 'Whether to enable light color temperature',
        color_temperature: 'Color Temperature of the light',
        illuminance: 'Illuminance of the light',
        luminous_power: 'Luminous power of the light',
        luminance: 'Luminance of the light',
        term: 'The photometric term currently being used',
        size: 'Size of the light',
        range: 'Range of the light',
    },
    model: {
        shadow_casting_model: 'Shadow projection mode',
        mesh: 'The mesh of the model',
        skinning_root: 'The skinning root, where the controlling Animation is located',
    },
    sprite: {
        gray_scale: 'Whether turn on grayscale rendering mode',
        sprite_frame: 'SpriteFrame image to use',
        atlas: 'Atlas that the image belongs to',
        type:
            'Rendering mode:\n - Simple: Modifying the size will stretch the image as a whole, which is suitable for sequence frame animation and normal images. \n' +
        '- Sliced: When changing the size, the four corners will not stretch, which is suitable for UI buttons and panel backgrounds. \n' +
        '- Tiled : When changing the size, the original size image will continue to be tiled. \n' +
        '- Filled : set a certain starting position and direction of filling, and the picture can be cropped and displayed at a certain ratio.',
        original_size: "Use the Image's original size as the Node size?",
        edit_button: 'Edit',
        select_button: 'Select In Atlas',
        select_tooltip: 'Choose Atlas',
        edit_tooltip: 'Open Sprite Editor, set squares and other data',
        fill_type: 'The direction of filling, choose from Horizontal, Vertical and Radial',
        fill_center: 'For radial filling, set the center of the circle, value range is 0 to 1',
        fill_start: 'The normalized value indicates where to start filling',
        fill_range: 'The normalizad value indicates how much of the sprite we want to show',
        src_blend_factor: 'The source image blend mode',
        dst_blend_factor: 'The destination image blend mode',
        size_mode:
            'Set the size of the node on which the Sprite component is on. CUSTOM for setting width and height manually;TRIMMED to use image size with transparent pixels trimmed; RAW to use image size without trimming.',
        trim:
            "Whether to render transparent pixels around image in node's bounding box. If you check this option the bounding box will not include transparent pixels around the image.",
    },
    UIOpacity: {
        opacity: 'The value between 0 to 255 showing the transparency of the object',
    },
    billboard: {
        texture: 'Billboard texture',
        height: 'Billboard height',
        width: 'Billboard width',
        rotation: 'Angle of rotation around the center point of Billboard',
    },
    button: {
        click_event: {
            target: 'Node that receives click events',
            component: 'Component that receive click events',
            handler: 'Component method to respond to click events',
            customEventData: "The extra event data passed to the event handler, it's passed in as the last argument in the event handler. ",
        },
        interactable: 'Interactable state of the button, when this item is unchecked, the button is disabled',
        transition: 'Transition type when the button state changes',
        normal_color: 'Button color',
        pressed_color: 'Button color when pressed',
        hover_color: 'Button color when the mouse hovers over it',
        disabled_color: 'Button color when disabled',
        duration: 'Transition time for button color change or zoom change',
        zoom_scale:
            'When the user clicks the button, the button is scaled to a value equal to the original scale of the Button * zoomScale, zoomScale can be a negative number',
        auto_gray_effect: 'When this flag is true, Button target sprite will turn gray when interactable is false.',
        normal_sprite: 'The sprite frame used when the button is in a normal sate.',
        pressed_sprite: 'The sprite frame used when the button is in a pressed sate.',
        hover_sprite: 'The sprite frame used when the button is in hovered over.',
        disabled_sprite: 'The sprite frame used when the button is in a disabled sate.',
        target:
            "reference to the Sprite as target's background. When the state of the target changes the sprite's color or spriteFrame will be updated.",
        click_events: 'By changing the number to 1 or more, you can set the receiver and the handler for each click event',
    },
    canvas: {
        camera: '2D rendering camera',
        align: 'Automatically calculate parameters for the camera.',
        design_resolution: 'The resolution of the assets used in the game, in pixels.',
        fit_height: 'Canvas allows designers to automatically scale the resolution  to the full height of devices screen',
        fit_width: 'Canvas allows designers to automatically scale the resolution  to the full width of devices screen',
    },
    forceOvertimeModule: {
        x: 'Acceleration component along X-axis',
        y: 'Acceleration component along Y-axis',
        z: 'Acceleration component along Z-axis',
        space: 'Space where acceleration calculated',
    },
    label: {
        string: 'Text of the Label',
        horizontal_align: 'Horizontal alignment',
        vertical_align: 'Vertical alignment',
        font_size: 'Font size, in points',
        font_family: 'Font family name',
        line_height: 'Line height, in points',
        overflow:
            'Text layout modes: \n 1. CLAMP: Text nodes outside the bounding box will be truncated. \n 2. SHRINK: Automatically shrink text box according to the constraint node. \n 3. RESIZE: Automatically updates the Node based on heightof the text.',
        wrap: 'Wrap text?',
        font: 'What font to use',
        system_font: 'Whether to use the system default font',
        cache_mode:
            'Text cache modes：\n 1. NONE: No cache，draw once. \n 2. BITMAP: Text is added as a static image to the dynamic atlas for batch merging, but its content cannot be dynamically modified frequently. \n 3. CHAR: Split the text into characters and cache the character texture into a character atlas for reuse, which is suitable for text content with repeated character content and frequently updated.',
        font_bold: 'Font bold',
        font_italic: 'Font italic',
        font_underline: 'Font underlined',
    },
    labelOutline: {
        color: 'Outline color',
        width: 'Outline width',
    },
    labelShadow: {
        color: 'Shadow color',
        offset: 'Offset between font and shadow.',
        blur: 'A non-negative float specifying the level of shadow blur.',
    },
    limitVelocityOvertimeModule: {
        limitX: 'Minimum speed along X-axis',
        limitY: 'Minimum speed along Y-axis',
        limitZ: 'Minimum speed along Z-axis',
        limit: 'Minimum speed',
        dampen: 'Lerp value between current speed and minimum speed',
        separateAxes: 'Set X,Y and Z limitation respectively',
        space: 'Space where minimum speed calculated',
    },
    line: {
        texture: 'Line texture',
        wordSpace: 'Which coordinate the point in line belongs to. Check if in world space, otherwise local space',
        positions: 'Position of control point',
        width: 'Fixed line width if constant input, or line width gradually changes according to the value if curve input',
        tile: 'Number of texture tiles',
        offset: 'Texture coordinates offset',
        color: 'Fixed color if constant input, or color gradually changes according to the value if gradient color input',
    },
    progress: {
        bar_sprite: 'A progress bar is displayed with the Sprite node that can dynamically change the size',
        mode: 'Progress bar display modes, including: \n 1. HORIZONTAL: horizontal mode \n 2. VERTICAL: vertical mode \n 3. FILLED: fan-fill mode',
        total_length: 'Length of progress bar. The maximum length of 100',
        progress: 'Current progress indicator, ranging from 0-1',
        reverse: 'Can the progress bar update negatively (i.e go backwards)',
    },
    scrollbar: {
        handle: 'reference to the interactive bar sprite',
        direction: 'Scroll direction',
        auto_hide: 'Automatically hide',
        auto_hide_time: 'How long will the scroll bar to be hidden after no scrolling action.\nNote: Only valid if "enableAutoHide" is true',
    },
    scrollview: {
        content: 'A scrollable display of the Nodes content',
        horizontal: 'Horizontal scroll',
        vertical: 'Vertical scroll',
        inertia: 'When inertia is set, the content will continue to move when touch ended',
        brake: 'It determines how quickly the content stop moving\nA value of 1 will stop the movement immediately\nA value of 0 will never stop the movement until it reaches to the boundary of scrollview',
        elastic: "If elastic is set, the content will bounce back when it's moved out of scroll boundary.",
        horizontal_bar: 'Horizontal scrollbar',
        vertical_bar: 'Vertical scrollbar',
        bounceDuration: 'The elapse time for bouncing. A value of 0 means the content will bounce back immediately.',
        scrollEvents: 'Scrollview events callback',
        cancelInnerEvents: 'If cancelInnerEvents is set to true, the scroll behavior will cancel touch events on inner content nodes',
    },
    pageview: {
        sizeMode: 'Specify the size type of each page in PageView',
        direction: 'The page view direction',
        scrollThreshold:
            'The scroll threshold value, when drag exceeds this value, release the next page will automatically scroll, less than the restore',
        pageTurningEventTiming:
            "Change the AutoScroll stop epsilon value of PageView, change this value could adjust the PageView's event triggering timing.",
        indicator: 'The Page View Indicator',
        pageTurningSpeed: 'The time required to turn over a page. unit: second',
        pageEvents: 'PageView events callback',
        autoPageTurningThreshold:
            'The turning velocity threshold for page turning\nWhen user swipes the PageView quickly, a velocity is calculated based on the swipe distance and time.\nIf the velocity is larger than the threshold, the page will be flipped',
    },
    pageview_indicator: {
        spriteFrame: 'The spriteFrame for each element',
        direction: 'The location direction of PageViewIndicator',
        cell_size: 'The cellSize for each element',
        spacing: 'The distance between each element',
    },
    particleSystemRenderer: {
        renderMode: 'Particle render mode',
        velocityScale: 'Lerp speed of particle along move direction when render mode is StrecthedBillboard',
        lengthScale: 'Lerp length of particle along move direction when render mode is StrecthedBillboard',
        mesh: 'Particle emit mesh',
        particleMaterial: 'Particle material',
        trailMaterial: 'Trail material of particle',
        useGPU: 'Enable GPU particle',
    },
    renderable2D: {
        srcBlendFactor: 'Source blend factor',
        dstBlendFactor: 'Destination blend factor',
        customMaterial: 'User specified material',
        color: 'Render color',
    },
    rotationOvertimeModule: {
        separateAxes: 'Set rotation of X, Y and Z respectively(not supported now)',
        x: 'Set rotation of X-axis',
        y: 'Set rotation of Y-axis',
        z: 'Set rotation of Z-axis',
    },
    sizeOvertimeModule: {
        separateAxes: 'Set particle size in X, Y and Z respectively',
        size: 'How particle size will change during its lifetime',
        x: 'How particle size along X-axis will change during its lifetime',
        y: 'How particle size along Y-axis will change during its lifetime',
        z: 'How particle size along Z-axis will change during its lifetime',
    },
    textureAnimationModule: {
        mode: 'Set mode of texture animation(support Grid only now)',
        numTilesX: 'Animation frames along X-axis',
        numTilesY: 'Animation frames along Y-axis',
        animation: 'Animation play mode',
        frameOverTime: 'How frame speed changes over time in a cycle',
        startFrame: 'Which frame start to play during the lifetime of particle system',
        cycleCount: 'Playing cycle count of whole lifetime',
        randomRow: 'Generate animation by a row of texture random selected,\nonly valid in SingleRow',
        rowIndex: 'Generate animation by a row of texture at [rowIndex],\nonly valid in SingleRow and randomRow is disabled',
    },
    toggle: {
        interactable: 'Interactive Toggle? When this one is not selected, the Toggle is in a disabled state',
        transition: 'Transition Type: when the state changes',
        normal_color: 'Toggle color',
        pressed_color: 'Toggle color when pressed',
        hover_color: 'Toggle color when the mouse hovers over it',
        disabled_color: 'Toggle color when disabled',
        duration: 'How long until the Toggle color/scale transitions to a new color?',
        zoom_scale:
            'When user press the Toggle, the Toggle will zoom to a scale.The final scale of the Toggle  equals (Toggle original scale * zoomScale), zoomScale could be negative value.',
        auto_gray_effect: 'When this flag is true, Toggle target sprite will turn gray when interactable is false.',
        normal_sprite: 'The Sprite that is used when the Toggle is in a normal sate.',
        pressed_sprite: 'The Sprite that is used when the Toggle is in a pressed sate.',
        hover_sprite: 'The Sprite that is used when the Toggle is hovered over.',
        disabled_sprite: 'The Sprite that is used when the Toggle is in a disabled sate.',
        target:
            "reference to the Sprite as Toggle's background. When the state of the button changes the sprite's color or spriteFrame will be updated.",
        isChecked:
            'If this flag is true, the associated checkMark sprite component will be enabled, otherwise the checkMark will be disabled.',
        checkMark: 'The Sprite component displayed when Toggle is checked.',
        toggleGroup:
            'The toggle group which the toggle belongs to. When it is null, the toggle is a CheckBox. Otherwise, the toggle is a RadioButton.',
        check_events: 'The events triggered while toggle item is checked',
    },
    toggle_group: {
        allowSwitchOff:
            "If this setting is true, a toggle could be switched off and on when pressed.If it is false, it will make sure there is always only one toggle could be switched on and the already switched on toggle can't be switched off.",
        check_events: "If Toggle is clicked, it will trigger event's handler.",
    },
    shapeModule: {
        position: 'Position of particle emitter',
        rotation: 'Rotation of particle emitter',
        scale: 'Scale of particle emitter',
        arc: 'Emit in a sector',
        angle: 'The angle between the axis of the cone and the generatrix',
        shapeType: 'Type of particle emitter',
        emitFrom: 'Where emit from',
        alignToDirection: 'Particle move direction align to its origin direction',
        randomDirectionAmount: 'Random setting of particle move direction',
        sphericalDirectionAmount: 'Lerp value between current emit direction and current move direction',
        randomPositionAmount: 'Random setting of particle move position(particle will appear beyond emit range)',
        radius: 'Radius of particle emitter',
        radiusThickness: 'Radius thickness of particle emitter(invalid when emitter type is Box):\n - 0 emit from surface；\n - 1 emit from center；\n - 0 ~ 1 emit between center and surface',
        arcMode: 'Emit mode in the sector range',
        arcSpread: 'Space margin along arc',
        arcSpeed: 'Emit speed along arc',
        length: 'The axis length from the top section of the cone to the bottom',
        boxThickness: 'Thickness of particle emitter(only valid when emitter type is Box)',
    },
    slider: {
        handle: 'The "handle" part of the slider',
        direction: 'The slider direction',
        progress: 'The current progress of the slider. The valid value is between 0-1',
        slideEvents: 'The slider events callback',
    },
    trailSegment: {
        mode: 'Particle trail mode',
        lifeTime: 'Particle trail lifetime',
        minParticleDistance: 'Minimum trail distance',
        space: 'Space where particle trail in',
        textureMode: 'How texture covers trail',
        widthFromParticle: 'Trail width inherit from particle',
        widthRatio: 'Trail width, it\'s ratio if inherit from particle',
        colorFromParticle: 'Whether trail color inherit from particle',
        colorOverTrail: 'Gradient color with length',
        colorOvertime: 'Gradient color over time',
    },
    velocityOvertimeModule: {
        x: 'Velocity component along X-axis',
        y: 'Velocity component along Y-axis',
        z: 'Velocity component along Z-axis',
        speedModifier: 'Speed ​​correction factor(CPU particle supported only)',
        space: 'Space where velocity calculated',
    },
    widget: {
        target:
            'Specifies an alignment target that can only be one of the parent nodes of the current node. The default value is null, and when null, indicates the current parent',
        align_top: 'Top edge alignment of the target Node',
        align_bottom: 'Bottom edge alignment of the target Node',
        align_left: 'Left edge alignment of the target Node',
        align_right: 'Right edge alignment of the target Node',
        align_h_center: 'Align to the horizontal midpoint of the target Node',
        align_v_center: 'Align to the vertical midpoint of the target Node',
        align_mode: 'Specifies the alignment mode of the Widget, which determines when the widget should refresh at runtime.',
        top: 'Top edge postion in pixels. This can be a percentage and a positive or negative value',
        bottom: 'Bottom edge postion in pixels. This can be a percentage and a positive or negative value',
        left: 'Left edge postion in pixels. This can be a percentage and a positive or negative value',
        right: 'Right edge postion in pixels. This can be a percentage and a positive or negative value',
        horizontal_center: 'Horizontal midpoint offset in pixels, This can be a percentage and a positive or negative value',
        vertical_center: 'Vertical midpoint offset in pixels, This can be a percentage and a positive or negative value',
    },
    layout: {
        layout_type:
            'Automatic layout mode: \n 1. NONE, no automatic arrangement of child Nodes \n 2. HORIZONTAL, automatic horizontal arrangement of child Nodes \n 3. VERTICAL, automatic vertical arrangement of child Nodes\n 4. GRID, automatic grid arrangement of child Nodes',
        resize_mode:
            'Automatic resize mode: \n 1. NONE, no resize of both child Nodes and container. \n 2. CONTAINER, resize container Node. \n 3. CHILDREN, resize child Nodes.',
        padding_left: 'Use a padding between left sides of the Node',
        padding_right: 'Use a padding between right sides of the Node',
        padding_top: 'Use a padding between top sides of the Node',
        padding_bottom: 'Use a padding between bottom sides of the Node',
        space_x: 'The horizontal distance between adjacent child Nodes',
        space_y: 'The vertical distance between adjacent child Nodes',
        vertical_direction: 'Vertically align in the direction of the child Nodes: \n 1. TOP_TO_BOTTOM, \n 2. BOTTOM_TO_TOP',
        horizontal_direction: 'Horizontally align in the direction of the child Nodes: \n 1. LEFT_TO_RIGHT \n 2. RIGHT_TO_LEFT',
        cell_size: 'In Grid layout, the size of each child element.',
        start_axis: 'In Grid layout, the arrangement direction of children elements.',
        constraint: 'In Grid layout, content layout constraints, including: \n 1.NONE, no constraints \n 2.FIXED_ROW, fixed number of rows \n 3.FIXED_COL, fixed number of columns',
        constraint_number: 'In Grid layout, number of rows or columns for content layout constraints',
        affected_scale: 'Child node scaling affects layout',
        align_horizontal: 'Align content horizontally\nFixed starting position in the same direction when Type is Horizontal.',
        align_vertical: 'Align content vertically\nFixed starting position in the same direction when Type is Vertical.',
    },
    particle: {
        export_title: 'Export custom particle data to plist file.',
        export: 'Export',
        export_error: 'This resource does not support exports outside of the project',
        sync: 'Sync',
        sync_tips: 'Synchronize the parameters in the File to Custom',
    },
    editbox: {
        string: 'The initial input text of EditBox.',
        backgroundImage: 'The background image of EditBox.',
        returnType: 'The keyboard return type of EditBox. This is useful for keyboard of mobile device.',
        input_flag: 'Specify the input flag: password or capitalize word. ',
        input_mode: 'Specify the input mode: multiline or single line.',
        font_size: 'The font size of input label.',
        line_height: 'The line height of input label.',
        stay_on_top: 'Set to true and the input is always visible and be on top of the game view',
        tab_index: 'Set the tabIndex of the DOM input element, only useful on Web.',
        font_color: 'The font color of input label.',
        placeholder: 'The content string of placeholder.',
        placeholder_font_size: 'The font size of placeholder label.',
        placeholder_font_color: 'The font color of placeholder label.',
        max_length: 'The maximize input characters.',
        text_lable: "The Label component attached to the node for EditBox's input text label",
        placeholder_label: "The Label component attached to the node for EditBox's placeholder text label",
        editing_began: 'The event handler to be triggered when user begin to edit text',
        text_changed: 'The event handler to be triggered when the text content changes',
        editing_ended: 'The event handler to be triggered when user stop editing\nIn single line mode, the function is usually called when the user presses enter or clicks outside the input box on the screen \n In case of multiline input, the function is usually called when the user clicks outside the input box on the screen',
        editing_return: 'The event handler to be called when return key is pressed\nIn single line mode, pressing the Enter key also causes the input box to lose focus',
    },
    videoplayer: {
        resourceType: 'The resource type of video player, REMOTE for remote url and LOCAL for local file path.',
        remoteURL: 'The remote URL of video.',
        clip: 'The local video clip',
        playOnAwake: 'Whether the video start playing automatically after loaded?',
        volume: 'The volume of the video.(0.0 ~ 1.0)',
        mute: 'Mutes the VideoPlayer. Mute sets the volume=0, Un-Mute restore the original volume.',
        playbackRate: 'The Video playback rate',
        loop: 'Whether the video should be played again at the end',
        keepAspectRatio: 'Whether keep the aspect ration of the original video.',
        fullScreenOnAwake: 'Whether play video in fullscreen mode?',
        stayOnBottom:
            'Always below the game view (only useful on Web. Note: The specific effects are not guaranteed to be consistent, depending on whether each browser supports or restricts).',
        videoPlayerEvent:
            "The video player's callback, it will be triggered when certain event occurs, like: playing, paused, stopped and completed.",
    },
    webview: {
        url: 'A given URL to be loaded by the Webview, it should have a http or https prefix.',
        webviewEvents: "The Webview's event callback , it will be triggered when certain Webview event occurs.",
    },
    richtext: {
        string: 'Text of the RichText, you could use BBcode in the string',
        horizontal_align: 'Horizontal alignment',
        font_size: 'Font size, in points',
        font: 'Custom TTF font of RichText',
        font_family:'Custom System font of RichText',
        use_system_font: 'Using system font',
        cache_mode: 'The cache mode of label. This mode only supports system fonts.',
        max_width: 'The maximize width of RichText, pass 0 means not limit the maximize width.',
        line_height: 'Line height, in points',
        image_atlas:
            'The image atlas for the img tag. For each src value in the img tag, there should be a valid spriteFrame in the image atlas.',
        handleTouchEvent:
            'Once checked, the RichText will block all input events (mouse and touch) within the bounding box of the node, preventing the input from penetrating into the underlying node.',
    },
    UICoordinateTracker: {
        target: 'Target node',
        camera: 'The 3D camera representing the original coordinate system.',
        use_scale: "Whether to scale the converted 2d node's size according to the distance between the camera and the 3d node.",
        distance: 'The distance from the camera for displaying the 2d node in normal size',
        sync_events: 'Event callback after coordinates synchronization.\nThe first parameter of the callback is the mapped local coordinate in UI camera.\nThe second parameter is the distance scale of the 3d node from the 3d camera viewport.',
    },
    subContextView: {
        design_size: 'Design resolution of the SubContextView, dynamic updates at runtime is not possible',
        fps: 'Update frame rate for the SubContextView',
    },
    skeleton: {
        skeleton_data: 'The skeleton data contains the skeleton information, drag the json file exported from Spine to get started.',
        default_skin: 'Choose the default skin.',
        animation: 'The name of current playing animation.',
        loop: 'Whether loop current animation',
        time_scale: 'The time scale of animations of this skeleton',
        debug_slots: 'Indicates whether show debug slots.',
        debug_bones: 'Indicates whether show debug bones.',
        premultipliedAlpha: 'Indicates whether to enable premultiplied alpha.',
    },
    dragon_bones: {
        dragon_bones_asset:
            'The json data contains the DragonBones information, drag the json file exported from DragonBones to get started.',
        dragon_bones_atlas_asset:
            'The json data contains the Texture information, drag the json file exported from DragonBones to get started.',
        armature_name: 'The name of current armature.',
        animation_name: 'The name of current playing animation.',
        time_scale: 'The time scale of this armature.',
        play_times:
            'The play times of the default animation.\n-1 means using the value of config file\n0 means repeat for ever\n>0 means repeat times',
        debug_bones: 'Indicates whether open debug bones',
    },
    motionStreak: {
        fadeTime: 'Trail fragment fade time, in seconds',
        minSeg: 'The minimum distance between of the trail',
        stroke: 'The width of the trail',
        texture: 'The texture of the trail',
        color: 'The color of the trail',
        fastMode: 'Whether to enable fast mode',
    },
    missing_scirpt: {
        error_compiled:
            'Error on executing script, or the script reference is missing. Please check error log carefully and correct/recover your script. The component will be restored once scripting error is gone. If you no long need the missing script, please remove this component manually.',
        error_not_compiled:
            'Error on compiling script. Please check error log carefully and correct your script. This component will be restored once compiling error is gone.',
    },
    collider: {
        editing: 'Edit this collider component',
        category: 'Collider component category',
        mask: 'The collider mask can collide with this collider',
    },
    particle_system: {
        preview: 'Play particle in edit mode',
        custom: 'If set custom to true, then use custom properties instead of read particle file',
        file: 'The plist file',
        spriteFrame: 'SpriteFrame of Particle System',
        texture: 'Texture of Particle System, readonly, please use spriteFrame to setup new texture',
        particleCount: 'Current quantity of particles that are being simulated',
        srcBlendFactor: 'Specify the source Blend Factor',
        dstBlendFactor: 'Specify the destination Blend Factor',
        playOnLoad: 'If set to true, the particle system will automatically start playing on load',
        autoRemoveOnFinish: 'Indicate whether the owner node will be auto-removed when it has no particles left',
        duration: 'How many seconds the emitter wil run. -1 means forever',
        emissionRate: 'Emission rate of the particles',
        life: 'Life and variation of each particle setter',
        totalParticles: 'Maximum particles of the system',
        startColor: 'Start color of each particle',
        startColorVar: 'Variation of the start color',
        endColor: 'Ending color of each particle',
        endColorVar: 'Variation of the end color',
        angle: 'Angle and variation of each particle setter',
        startSize: 'Start size and variation in pixels of each particle',
        endSize: 'End size and variation in pixels of each particle',
        startSpin: 'Start angle and variation of each particle',
        endSpin: 'End angle and variation of each particle',
        sourcePos: 'Source position of the emitter',
        posVar: 'Variation of source position',
        positionType: 'Particles movement type',
        emitterMode: 'Particles emitter modes',
        gravity: 'Gravity of the emitter',
        speed: 'Speed and variation of the emitter',
        tangentialAccel: 'Tangential acceleration and variation of each particle. Only available in Gravity mode ',
        radialAccel: 'Acceleration and variation of each particle. Only available in Gravity mode',
        rotationIsDir: 'Indicate whether the rotation of each particle equals to its direction. Only available in Gravity mode',
        startRadius: 'Starting radius and variation of the particles. Only available in Radius mode',
        endRadius: 'Ending radius and variation of the particles. Only available in Radius mode',
        rotatePerS: 'Number of degress to rotate a particle around the source pos per second and variation. Only available in Radius mode',
        capacity: 'Maximum particle amount that the system can generate',
        scaleSpace: 'Scale space',
        startSize3D: 'Set start size of X, Y and Z respectively if true',
        startSizeX: 'Start size in X direction',
        startSizeY: 'Start size in Y direction',
        startSizeZ: 'Start size in Z direction',
        startSpeed: 'Start speed',
        startRotation3D: 'Set rotation of X, Y and Z respectively if true',
        startRotationX: 'Angle of rotation around X-axis at beginning',
        startRotationY: 'Angle of rotation around Y-axis at beginning',
        startRotationZ: 'Angle of rotation around Z-axis at beginning',
        startDelay: 'Time delayed of particle emit after the system start running',
        startLifetime: 'Life time of the particle',
        duration: 'Particle duration',
        loop: 'Loop animation',
        prewarm: 'Animation plays from the end state of last round(only valid when loop activated)',
        simulationSpace: 'The particle space your calculation is done in',
        simulationSpeed: 'Update ratio of particles',
        playOnAwake: 'Play on awake',
        gravityModifier: 'How much particles get affected by the gravity(only support on CPU)',
        rateOverTime: 'Number of particles emitted per second',
        rateOverDistance: 'Number of particles emitted per unit distance',
        bursts: 'Emit a given number of particles at a certain point in time',
        colorOverLifetimeModule: 'Color control module',
        shapeModule: 'Particle emitter module',
        sizeOvertimeModule: 'Particle size module',
        velocityOvertimeModule: 'Particle velocity module',
        forceOvertimeModule: 'Particle acceleration module',
        limitVelocityOvertimeModule: 'Particle velocity limitation module(only support on CPU)',
        rotationOvertimeModule: 'Particle rotation module',
        textureAnimationModule: 'Texture animation module',
        trailModule: 'Trail module(only support on CPU)',
        renderer: 'Particle render module',
        enableCulling: 'Enable culling option, if switch enable the emitter will generate a bounding box and if main camera can not see the bounding box the emitter will be culled. The culled behavior will be described in cullingMode.',
        cullingMode: 'Behavior if culled. There are 3 options include pause, pause and catchup, always simulate. Pause means if we can not see bounding box of the emitter the emitter will pause simulation, if we see the bounding box again the emitter will continue simulation from the pause time. Pause and catchup means if we can not see bounding box of the emitter the emitter will pause simulation, if we see the bounding box again the emitter will continue simulation from current time. Always simulate means no matter we see the bounding box or not, the emitter will always simulate and we do not render the particle of whose emitter is invisible.',
        alignSpace: 'Particle align space. There are 3 options include view, world, local. If we choose view, the particle mesh will have the same rotation of the main camera. World means the rotation of particle mesh will be the same as the world rotation of the emitter node. If we choose local, the rotation of particle mesh will be the same as the local rotation of the emitter node.',
        aabbHalfX: 'Half width of emitter bounding box',
        aabbHalfY: 'Half height of emitter bounding box',
        aabbHalfZ: 'Half length of emitter bounding box',
    },
    mask: {
        type: 'The mask type',
        spriteFrame: 'The mask image',
        inverted: 'The Reverse mask (Not supported Canvas Mode)',
        alphaThreshold:
            'The alpha threshold，The content is drawn only where the stencil have pixel with alpha greater than the alphaThreshold (Not supported Canvas Mode)',
        segements: 'The segements for ellipse mask',
    },
    physics: {
        rigidbody: {
            enabledContactListener:
                'Should enabled contact listener. When a collision is trigger, the collision callback will only be called when enabled contact listener.',
            bullet: 'Is this a fast moving body that should be prevented from tunneling through other moving bodies?',
            type: 'Rigidbody type : Static, Kinematic, Dynamic or Animated.',
            allowSleep: 'Set this flag to false if this body should never fall asleep. Note that this increases CPU usage.',
            gravityScale: 'Scale the gravity applied to this body.',
            linearDamping:
                'Linear damping is use to reduce the linear velocity. The damping parameter can be larger than 1, but the damping effect becomes sensitive to the time step when the damping parameter is large.',
            angularDamping:
                'Angular damping is use to reduce the angular velocity. The damping parameter can be larger than 1 but the damping effect becomes sensitive to the time step when the damping parameter is large.',
            linearVelocity: "The linear velocity of the body's origin in world co-ordinates",
            angularVelocity: 'The angular velocity of the body.',
            fixedRotation: 'Should this body be prevented from rotating?',
            awake: 'Is this body initially awake or sleeping?',
        },
        physics_collider: {
            density: 'The density',
            sensor: 'A sensor collider collects contact information but never generates a collision response',
            friction: 'The friction coefficient, usually in the range [0,1].',
            restitution: 'The restitution (elasticity) usually in the range [0,1].',
            anchor: 'The anchor of the rigidbody.',
            connectedAnchor: 'The anchor of the connected rigidbody.',
            connectedBody: 'The rigidbody to which the other end of the joint is attached.',
            collideConnected: 'Should the two rigid bodies connected with this joint collide with each other?',
            distance: 'The distance separating the two ends of the joint.',
            frequency: 'The spring frequency.',
            dampingRatio: 'The damping ratio.',
            linearOffset: 'The linear offset from connected rigidbody to rigidbody.',
            angularOffset: 'The angular offset from connected rigidbody to rigidbody.',
            maxForce: 'The maximum force can be applied to rigidbody.',
            maxTorque: 'The maximum torque can be applied to rigidbody.',
            correctionFactor: 'The position correction factor in the range [0,1].',
            mouseRegion: "The node used to register touch evnet. If this is null, it will be the joint's node.",
            target: 'The target point. The mouse joint will move choosed rigidbody to target point.',
            localAxisA: 'The local joint axis relative to rigidbody.',
            enableLimit: 'Enable joint distance limit?',
            enableMotor: 'Enable joint motor?',
            lowerLimit: 'The lower joint limit.',
            upperLimit: 'The upper joint limit.',
            maxMotorForce: 'The maxium force can be applied to rigidbody to rearch the target motor speed.',
            motorSpeed: 'The expected motor speed.',
            referenceAngle: 'The reference angle. An angle between bodies considered to be zero for the joint angle.',
            lowerAngle: 'The lower angle.',
            upperAngle: 'The upper angle.',
            maxMotorTorque: 'The maxium torque can be applied to rigidbody to rearch the target motor speed.',
            maxLength: 'The max length.',
            offset: 'Position offset',
            size: 'Box size',
            radius: 'Circle radius',
            tag: 'Tag. If a node has several collider components, you can judge which type of collider is collided according to the tag.',
            points: 'Polygon points',
        },
    },
    block_input_events: {
        brief_help:
            'This component will block all input events, preventing the input from penetrating to other nodes below the screen, typically for the background of the top-level UI of the screen.',
    },
    tiledtile: {
        row: 'Specify the TiledTile horizontal coordinate，use map tile as the unit.',
        column: 'Specify the TiledTile vertical coordinate，use map tile as the unit.',
        gid: 'Specify the TiledTile gid.',
        layer: 'Specify which TiledLayer the TiledTile belong to.',
    },
    INSPECTOR: {
        component: {
            script: 'Custom Script',
        },
    },
    features: {
        categories: {
            '2d': {
                label: '2D',
                description: '2D',
            },
            '3d': {
                label: '3D',
                description: '3D',
            },
        },
        core: {
            label: "Core",
            description: "Cocos Creator core functionalities.",
        },
        graphics: {
            label: "Graphics Backend",
            description: "Select graphics back end used for rendering.",
        },
        gfx_webgl: {
            label: "WebGL",
            description: "Include support for WebGL 1.0 graphics API.",
        },
        gfx_webgl2: {
            label: "WebGL 2.0",
            description: "Include support for WebGL 2.0 graphics API.\n If WebGL 2.0 is not available on target platform, the one will fallback as WebGL 1.0.",
        },
        ui: {
            label: "User Interface",
            description: "User interface support.",
        },
        gpu_driven: {
            label: "GPU Driven",
            description: "Whether to enable GPU-driven solutions (only works for packaged projects for now)",
        },
        base_3d: {
            label: "Basic 3D Features",
            description: "Components and tools that are widely used in general 3D applications.",
        },
        particle: {
            label: "Particle System",
            description: "Particle system support.",
        },
        physics: {
            label: "Physics System",
            description: "Select physics system.",
        },
        physics_builtin: {
            label: "Builtin Physics System",
            description: "Builtin physics system support.",
        },
        physics_cannon: {
            label: "cannon.js Based Physics system",
            description: "Physics system that based on cannon.js.",
        },
        physics_ammo: {
            label: "Bullet Based Physics System",
            description: "Physics system that based on Bullet.",
        },
        physics_physx: {
            label: "PhysX Based Physics System",
            description: "Physics system that based on PhysX.",
        },
        primitives: {
            label: "Primitive Geometries",
            description: "Libraries that used to create primitive geometries.",
        },
        base_2d: {
            label: "Basic 2D Features",
            description: "Components and tools that are widely used in general 2D applications.",
        },
        physics_2d: {
            label: "2D Physics System",
            description: "Physics system that applied to 2D application.",
        },
        physics_2d_builtin: {
            label: "Builtin 2D Physics System",
            description: "Builtin 2D physics system support.",
        },
        physics_2d_box2d: {
            label: "Box2D Based 2D Physics System",
            description: "2D Physics system that based on Box2D.",
        },
        intersection_2d: {
            label: "2D Intersection Algorithms",
            description: "Include 2D intersection algorithms.",
        },
        particle_2d: {
            label: "2D Particle System",
            description: "Particle system that applied to 2D application.",
        },
        terrain: {
            label: "Terrain",
            description: "Terrain support.",
        },
        audio: {
            label: "Audio",
            description: "Audio playing support.",
        },
        video: {
            label: "Video",
            description: "Video playing support.",
        },
        webview: {
            label: "Web View",
            description: "Support displaying Web contents.",
        },
        tween: {
            label: "Tween",
            description: "Tween system.",
        },
        profiler: {
            label: "Running Stats",
            description: "Include various components and tools used to audit and display rendering stats.",
        },
        tiled_map: {
            label: "Tiled Map",
            description: "Tiled map support.",
        },
        spine: {
            label: "Spine Animation",
            description: "Spine Animation support.",
        },
        dragon_bones: {
            label: "DragonBones",
            description: "DragonBones support.",
        },
    },
    renderable_2d: {
        srcBlendFactor: 'Specifies the source blend mode, it will clone a new material object.',
        dstBlendFactor: 'Specifies the destination blend mode.',
        color: 'Main color for rendering, it normally multiplies with texture color.',
    },
    ui_transform: {
        content_size:'Size of the UI node.',
        anchor_point:'Anchor point of the UI node.',
        priority:'Priority of rendering ordering.',
    },
    graphics: {
        lineWidth: 'The width of edges',
        lineJoin: 'Determines how two connecting segments (of lines, arcs or curves) with non-zero lengths in a shape are joined together.',
        lineCap: 'Determines how the end points of every line are drawn.',
        strokeColor: 'Brush stroke color.',
        fillColor: 'Fill paint color.',
        miterLimit: 'Set the miter limit ratio.',
    },
    physics3d: {
        rigidbody: {
            group: 'Group of this rigid body',
            type: 'Type of this rigid body',
            mass: 'The mass of this rigid body, which needs to be greater than 0',
            allowSleep: 'Whether to allow automatic hibernation',
            linearDamping: 'Used to decay the linear velocity, the larger it is, the faster the decay will be',
            angularDamping: 'Used to decay the angular velocity, the larger it is, the faster the decay will be',
            useGravity: 'Whether to use gravity',
            linearFactor: 'For scaling physical values (velocity or force) in each axis direction',
            angularFactor: 'Angular factor to scale physical values (velocity or force) in each axis direction',
        },
        collider: {
            attached: 'The rigid body where the collider is attached to',
            sharedMaterial: 'The physical material used, default when not set',
            isTrigger: 'Whether it is a trigger, the trigger does not generate physical feedback',
            center: 'The center of the shape in the local coordinate system',
            sphere_radius: 'The radius of the sphere in the local coordinate system',
            box_size: 'The size of the box in the local coordinate system',
            capsule_radius: 'The radius of the sphere on the capsule body in the local coordinate system',
            capsule_cylinderHeight: 'The height of the cylinder on the capsule in the local coordinate system',
            capsule_direction: 'The orientation of the capsule body in the local coordinate system',
            cone_radius: 'The radius of the upper circular surface of the cone in the local coordinate system',
            cone_height: 'The height of the cone in the corresponding axial direction in the local coordinate system',
            cone_direction: 'The orientation of the cone in the local coordinate system',
            cylinder_radius: 'The radius of the circular surface on the cylinder in the local coordinate system',
            cylinder_height: 'The height of the cylinder in the corresponding axial direction in the local coordinate system',
            cylinder_direction: 'The orientation of the cylinder in the local coordinate system',
            plane_normal: 'The normal to the plane in the local coordinate system',
            plane_constant: 'The distance of the plane moving along the normal from the origin in the local coordinate system',
            mesh_mesh: 'Mesh resources used by collider',
            mesh_convex: 'Whether to use convex hull approximation instead, the number of vertices should be less than 255, and the dynamics can be supported after turning on',
            terrain_terrain: 'Terrain resources used by collider',
            simplex_shapeType: 'Simplex type, point, line, triangle, tetrahedron',
            simplex_vertex0: 'Vertex 0 of the shape',
            simplex_vertex1: 'Vertex 1 of the shape',
            simplex_vertex2: 'Vertex 2 of the shape',
            simplex_vertex3: 'Vertex 3 of the shape',
        },
        constant_force:{
            force: 'The force apply on a rigid body in the world coordinate system',
            localForce: 'The force apply on a rigid body in the local coordinate system',
            torque: 'The torque applied to the rigid body in the world coordinate system',
            localTorque: 'The torque applied to the rigid body in the local coordinate system',
        },
    },
};
