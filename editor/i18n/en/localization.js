const pkg = require('../../../package.json');
const version = pkg.version.replace(/(^\d+\.\d+)\..*$/, (str, a) => {
    return a;
});

const url = 'https://docs.cocos.com/creator';

module.exports = {
    menu: {
        custom_script: 'Custom script',
    },

    help: {
        cc: {
            Node: `${url}/${version}/manual/en/concepts/scene/node-component.html`,
            MeshRenderer: `${url}/${version}/manual/en/engine/renderable/model-component.html`,
            UITransform: `${url}/${version}/manual/en/ui-system/components/editor/ui-transform.html`,
            Sprite: `${url}/${version}/manual/en/ui-system/components/editor/sprite.html`,
            SubContextView: `${url}/${version}/manual/zh/editor/publish/build-open-data-context.html`,
            BlockInputEvents: `${url}/${version}/manual/en/ui-system/components/editor/block-input-events.html`,
            Camera: `${url}/${version}/manual/en/editor/components/camera-component.html`,
            Canvas: `${url}/${version}/manual/en/ui-system/components/editor/canvas.html`,
            SkinnedMeshRenderer: `${url}/${version}/manual/en/engine/animation/skeletal-animation.html`,
            SkinnedMeshBatchRenderer: `${url}/${version}/manual/en/engine/animation/skeletal-animation.html`,
            DirectionalLight: `${url}/${version}/manual/en/concepts/scene/light/dir-light.html`,
            SphereLight: `${url}/${version}/manual/en/concepts/scene/light/sphere-light.html`,
            SpotLight: `${url}/${version}/manual/en/concepts/scene/light/spot-light.html`,
            UICoordinateTracker: `${url}/${version}/manual/en/ui-system/components/editor/ui-coordinate-tracker.html`,
            Animation: `${url}/${version}/manual/en/engine/animation/animation-component.html`,
            SkeletalAnimation: `${url}/${version}/manual/en/engine/animation/skeletal-animation.html`,
            AudioSource: `${url}/${version}/manual/en/audio-system/overview.html`,
            Billboard: `${url}/${version}/manual/en/particle-system/billboard-component.html`,
            Line: `${url}/${version}/manual/en/particle-system/line-component.html`,
            ParticleSystem: `${url}/${version}/manual/en/particle-system/main-module.html`,
            Button: `${url}/${version}/manual/en/ui-system/components/editor/button.html`,
            Label: `${url}/${version}/manual/en/ui-system/components/editor/label.html`,
            EditBox: `${url}/${version}/manual/en/ui-system/components/editor/editbox.html`,
            Layout: `${url}/${version}/manual/en/ui-system/components/editor/layout.html`,
            Graphics: `${url}/${version}/manual/en/ui-system/components/editor/graphics.html`,
            Mask: `${url}/${version}/manual/en/ui-system/components/editor/mask.html`,
            ProgressBar: `${url}/${version}/manual/en/ui-system/components/editor/progress.html`,
            LabelOutline: `${url}/${version}/manual/en/ui-system/components/editor/label-outline.html`,
            RichText: `${url}/${version}/manual/en/ui-system/components/editor/richtext.html`,
            ScrollBar: `${url}/${version}/manual/en/ui-system/components/editor/scrollbar.html`,
            ScrollView: `${url}/${version}/manual/en/ui-system/components/editor/scrollview.html`,
            Slider: `${url}/${version}/manual/en/ui-system/components/editor/slider.html`,
            ToggleContainer: `${url}/${version}/manual/en/ui-system/components/editor/toggleContainer.html`,
            Toggle: `${url}/${version}/manual/en/ui-system/components/editor/toggle.html`,
            UIMeshRenderer: `${url}/${version}/manual/en/ui-system/components/editor/ui-model.html`,
            Widget: `${url}/${version}/manual/en/ui-system/components/editor/widget.html`,
            PageViewIndicator: `${url}/${version}/manual/en/ui-system/components/editor/pageviewindicator.html`,
            PageView: `${url}/${version}/manual/en/ui-system/components/editor/pageview.html`,
            UIStaticBatch: `${url}/${version}/manual/en/ui-system/components/editor/ui-static.html`,
            UIOpacity: `${url}/${version}/manual/en/ui-system/components/editor/ui-opacity.html`,
            BoxCollider: `${url}/${version}/manual/en/physics/physics-collider.html`,
            SphereCollider: `${url}/${version}/manual/en/physics/physics-component.html`,
            CapsuleCollider: `${url}/${version}/manual/en/physics/physics-component.html`,
            CylinderCollider: `${url}/${version}/manual/en/physics/physics-component.html`,
            MeshCollider: `${url}/${version}/manual/en/physics/physics-component.html`,
            RigidBody: `${url}/${version}/manual/en/physics/physics-rigidbody.html`,
            ConstantForce: `${url}/${version}/manual/en/physics/physics-component.html`,
            VideoPlayer: `${url}/${version}/manual/en/ui-system/components/editor/videoplayer.html`,
            WebView: `${url}/${version}/manual/en/ui-system/components/editor/webview.html`,
            SafeArea: `${url}/${version}/manual/en/ui-system/components/editor/safearea.html`,
            Terrain: `${url}/${version}/manual/en/editor/terrain/`,
            TiledMap: ``,
            Spine: ``,
        },
    },

    animation: {
        default_clip: 'When checking, the deault animation clip is automatically played.',
        clips: 'You can access and play animation clips via a script',
        play_on_load: 'Automatically play animation clip with the scene is loaded',
        use_baked_animation:
            'Whether to bake animations. Default to true,\nwhich substantially increases performance while making all animations completely fixed',
        sockets:
            'The joint sockets this animation component maintains.\nSockets have to be registered before attaching custom nodes to animated joints',
    },
    audio: {
        clip: 'The default AudioClip to be played for this audio source',
        volume: 'The volume of this audio source',
        loop: 'Is looping enabled for this audio source?',
        playOnAwake: 'Is auto-play enabled for this audio source?',
    },
    batched_skinning_model: {
        atlas_size: 'Size of the generated texture atlas',
        batchable_texture_names:
            "Texture properties that will be actually using the generated atlas.\nThe first unit's texture will be used if not specified",
        units: 'Source skinning model components, containing all the data to be batched',
    },
    camera: {
        priority: 'Render priority of the camera, in ascending-order',
        visibility: 'Visibility mask, declaring a set of node layers that will be visible to this camera',
        clear_flags: 'Clearing flags of the camera, specifies which part of the framebuffer will be actually cleared every frame',
        color: 'Clearing color of the camera',
        depth: 'Clearing depth of the camera',
        stencil: 'Clearing stencil of the camera',
        projection: 'Projection type of the camera',
        fov_axis: 'The axis on which the FOV would be fixed regardless of screen aspect changes',
        fov: 'Field of view of the camera',
        ortho_height: 'Viewport height in orthographic mode',
        near: 'Near clipping distance of the camera, should be as large as possible within acceptable range',
        far: 'Far clipping distance of the camera, should be as small as possible within acceptable range',
        aperture: 'Camera aperture, controls the exposure parameter',
        shutter: 'Camera shutter, controls the exposure parameter',
        ISO: 'Camera ISO, controls the exposure parameter',
        rect: 'Screen viewport of the camera wrt. the sceen size',
        target_texture: 'Output render texture of the camera. Default to null, which outputs directly to screen',
    },
    lights: {
        color: 'Color of the light',
        use_color_temperature: 'Whether to enable light color temperature',
        color_temperature: 'Color Temperature of the light',
        illuminance: 'Illuminance of the light',
        luminous_power: 'Luminous power of the light',
        luminance: 'Luminance of the light',
        term: 'The photometric term currently being used',
        size: 'Size of the light',
        range: 'Range of the light',
    },
    model: {
        shadow_casting_model: 'Shadow projection mode',
        mesh: 'The mesh of the model',
        skinning_root: 'The skinning root, where the controlling Animation is located',
    },
    sprite: {
        sprite_frame: 'SpriteFrame image to use',
        atlas: 'Atlas that the image belongs to',
        type: 
            'Rendering mode:\n - Simple: Modifying the size will stretch the image as a whole, which is suitable for sequence frame animation and normal images. \n' +
        '- Sliced: When changing the size, the four corners will not stretch, which is suitable for UI buttons and panel backgrounds. \n' +
        '- Tiled : When changing the size, the original size image will continue to be tiled. \n' +
        '- Filled : set a certain starting position and direction of filling, and the picture can be cropped and displayed at a certain ratio.',
        original_size: "Use the Image's original size as the Node size?",
        edit_button: 'Edit',
        select_button: 'Select In Atlas',
        select_tooltip: 'Choose Atlas',
        edit_tooltip: 'Open Sprite Editor, set squares and other data',
        fill_type: 'The direction of filling, choose from Horizontal, Vertical and Radial',
        fill_center: 'For radial filling, set the center of the circle, value range is 0 to 1',
        fill_start: 'The normalized value indicates where to start filling',
        fill_range: 'The normalizad value indicates how much of the sprite we want to show',
        src_blend_factor: 'The source image blend mode',
        dst_blend_factor: 'The destination image blend mode',
        size_mode:
            'Set the size of the node on which the Sprite component is on. CUSTOM for setting width and height manually;TRIMMED to use image size with transparent pixels trimmed; RAW to use image size without trimming.',
        trim:
            "Whether to render transparent pixels around image in node's bounding box. If you check this option the bounding box will not include transparent pixels around the image.",
    },
    button: {
        click_event: {
            target: 'Node receives a click event?',
            component: 'Component receives a click event?',
            handler: 'What method is called on the click event?',
            customEventData: "The extra event data passed to the event handler, it's passed in as the last argument in the event handler. ",
        },
        interactable: 'Interactive button? When this one is not selected, the button is in a disabled state',
        transition: 'Transition Type: when the state changes',
        normal_color: 'Button color',
        pressed_color: 'Button color when pressed',
        hover_color: 'Button color when the mouse hovers over it',
        disabled_color: 'Button color when disabled',
        duration: 'How long until the button color/scale transitions to a new color?',
        zoom_scale:
            'When user press the button, the button will zoom to a scale.The final scale of the button  equals (button original scale * zoomScale), zoomScale could be negative value.',
        auto_gray_effect: 'When this flag is true, Button target sprite will turn gray when interactable is false.',
        normal_sprite: 'The Sprite that is used when the button is in a normal sate.',
        pressed_sprite: 'The Sprite that is used when the button is in a pressed sate.',
        hover_sprite: 'The Sprite that is used when the button is hovered over.',
        disabled_sprite: 'The Sprite that is used when the button is in a disabled sate.',
        target:
            "reference to the Sprite as button's background. When the state of the button changes the sprite's color or spriteFrame will be updated.",
        click_events: 'What method is called on the click event?',
    },
    canvas: {
        camera: '2D rendering camera',
        align: 'Automatically calculate parameters for the camera.',
        design_resolution: 'The resolution of the assets used in the game, in pixels.',
        fit_height: 'Canvas allows designers to automatically scale the resolution  to the full height of devices screen',
        fit_width: 'Canvas allows designers to automatically scale the resolution  to the full width of devices screen',
    },
    label: {
        string: 'Text of the Label',
        horizontal_align: 'Horizontal alignment',
        vertical_align: 'Vertical alignment',
        font_size: 'Font size, in points',
        font_family: 'Font family name',
        line_height: 'Line height, in points',
        overflow: 
            'Text layout modes: \n 1. CLAMP: Text nodes outside the bounding box will be truncated. \n 2. SHRINK: Automatically shrink text box according to the constraint node. \n 3. RESIZE: Automatically updates the Node based on heightof the text.',
        wrap: 'Wrap text?',
        font: 'What font to use',
        system_font: 'Whether to use the system default font',
        cache_mode: 
            'Text cache modes：\n 1. NONE: No cache，draw once. \n 2. BITMAP: Text is added as a static image to the dynamic atlas for batch merging, but its content cannot be dynamically modified frequently. \n 3. CHAR: Split the text into characters and cache the character texture into a character atlas for reuse, which is suitable for text content with repeated character content and frequently updated.',
        font_bold: 'Bold font',
        font_italic: 'Font italic',
        font_underline: 'Font underlined',
    },
    labelOutline: {
        color: 'Outline color',
        width: 'Outline width',
    },
    labelShadow: {
        color: 'Shadow color',
        offset: 'Offset between font and shadow.',
        blur: 'A non-negative float specifying the level of shadow blur.',
    },
    progress: {
        bar_sprite: 'A progress bar is displayed with the Sprite node that can dynamically change the size',
        mode: 'Horizontal or Vertical progress bar?',
        total_length: 'Length of progress bar. The maximum length of 100',
        progress: 'Current progress indicator, ranging from 0-1',
        reverse: 'Can the progress bar update negatively (i.e go backwards)',
    },
    scrollbar: {
        handle: 'reference to the interactive bar sprite',
        direction: 'Scroll direction',
        auto_hide: 'Hide scroll bar when it is not scrolling?',
        auto_hide_time: 'How long to wait to hide the scroll bar when it is not scrolling?',
    },
    scrollview: {
        content: 'A scrollable display of the Nodes content',
        horizontal: 'Horizontal scroll',
        vertical: 'Vertical scroll',
        inertia: 'Use intertia when scrolling? (or just let your finger do all the work?)',
        brake: 'When using interia scrolling what to do when the user stops touching? 0 never stop, 1 stop immediately',
        elastic: 'Use elastic scrolling?',
        bounce_time: 'When using elastic scrolling how long to rebound afterwards?',
        horizontal_bar: 'Horizontal scrollbar',
        vertical_bar: 'Vertical scrollbar',
        bounceDuration: 'The elapse time of bouncing back. A value of 0 will bounce back immediately',
        scrollEvents: 'Scrollview events callback',
        cancelInnerEvents: 'If cancelInnerEvents is set to true, the scroll behavior will cancel touch events on inner content nodes',
    },
    pageview: {
        sizeMode: 'Specify the size type of each page in PageView',
        direction: 'The page view direction',
        scrollThreshold:
            'The scroll threshold value, when drag exceeds this value, release the next page will automatically scroll, less than the restore',
        pageTurningEventTiming:
            "Change the AutoScroll stop epsilon value of PageView, change this value could adjust the PageView's event triggering timing.",
        indicator: 'The Page View Indicator',
        pageTurningSpeed: 'The time required to turn over a page. unit: second',
        pageEvents: 'PageView events callback',
        autoPageTurningThreshold:
            'Auto page turning velocity threshold. When users swipe the PageView quickly, it will calculate a velocity based on the scroll distance and time, if the calculated velocity is larger than the threshold, then it will trigger page turning',
    },
    pageview_indicator: {
        spriteFrame: 'The spriteFrame for each element',
        direction: 'The location direction of PageViewIndicator',
        cell_size: 'The cellSize for each element',
        spacing: 'The distance between each element',
    },
    toggle: {
        interactable: 'Interactive Toggle? When this one is not selected, the Toggle is in a disabled state',
        transition: 'Transition Type: when the state changes',
        normal_color: 'Toggle color',
        pressed_color: 'Toggle color when pressed',
        hover_color: 'Toggle color when the mouse hovers over it',
        disabled_color: 'Toggle color when disabled',
        duration: 'How long until the Toggle color/scale transitions to a new color?',
        zoom_scale:
            'When user press the Toggle, the Toggle will zoom to a scale.The final scale of the Toggle  equals (Toggle original scale * zoomScale), zoomScale could be negative value.',
        auto_gray_effect: 'When this flag is true, Toggle target sprite will turn gray when interactable is false.',
        normal_sprite: 'The Sprite that is used when the Toggle is in a normal sate.',
        pressed_sprite: 'The Sprite that is used when the Toggle is in a pressed sate.',
        hover_sprite: 'The Sprite that is used when the Toggle is hovered over.',
        disabled_sprite: 'The Sprite that is used when the Toggle is in a disabled sate.',
        target:
            "reference to the Sprite as Toggle's background. When the state of the button changes the sprite's color or spriteFrame will be updated.",
        isChecked:
            'If this flag is true, the associated checkMark sprite component will be enabled, otherwise the checkMark will be disabled.',
        checkMark: 'The Sprite component displayed when Toggle is checked.',
        toggleGroup:
            'The toggle group which the toggle belongs to. When it is null, the toggle is a CheckBox. Otherwise, the toggle is a RadioButton.',
    },
    toggle_group: {
        allowSwitchOff:
            "If this setting is true, a toggle could be switched off and on when pressed.If it is false, it will make sure there is always only one toggle could be switched on and the already switched on toggle can't be switched off.",
    },
    slider: {
        handle: 'The "handle" part of the slider',
        direction: 'The slider direction',
        progress: 'The current progress of the slider. The valid value is between 0-1',
        slideEvents: 'The slider events callback',
    },
    widget: {
        target:
            'Specifies an alignment target that can only be one of the parent nodes of the current node. The default value is null, and when null, indicates the current parent',
        align_top: 'Top edge alignment of the parent Node',
        align_bottom: 'Bottom edge alignment of the parent Node',
        align_left: 'Left edge alignment of the parent Node',
        align_right: 'Right edge alignment of the parent Node',
        align_h_center: 'Align to the horizontal midpoint of the parent Node',
        align_v_center: 'Align to the vertical midpoint of the parent Node',
        align_mode: 'Specifies the alignment mode of the Widget, which determines when the widget should refresh at runtime.',
        top: 'Top edge postion in pixels. This can be a percentage and a positive or negative value',
        bottom: 'Bottom edge postion in pixels. This can be a percentage and a positive or negative value',
        left: 'Left edge postion in pixels. This can be a percentage and a positive or negative value',
        right: 'Right edge postion in pixels. This can be a percentage and a positive or negative value',
        horizontal_center: 'Horizontal midpoint offset in pixels, This can be a percentage and a positive or negative value',
        vertical_center: 'Vertical midpoint offset in pixels, This can be a percentage and a positive or negative value',
    },
    layout: {
        layout_type:
            'Automatic layout mode: \n 1. NONE, no automatic arrangement of child Nodes \n 2. HORIZONTAL, automatic horizontal arrangement of child Nodes \n 3. VERTICAL, automatic vertical arrangement of child Nodes\n 4. GRID, automatic grid arrangement of child Nodes',
        resize_mode:
            'Automatic resize mode: \n 1. NONE, no resize of both child Nodes and container. \n 2. CONTAINER, resize container Node. \n 3. CHILDREN, resize child Nodes.',
        padding_left: 'Use a padding between left sides of the Node',
        padding_right: 'Use a padding between right sides of the Node',
        padding_top: 'Use a padding between top sides of the Node',
        padding_bottom: 'Use a padding between bottom sides of the Node',
        space_x: 'The horizontal distance between adjacent child Nodes',
        space_y: 'The vertical distance between adjacent child Nodes',
        vertical_direction: 'Vertically align in the direction of the child Nodes: \n 1. TOP_TO_BOTTOM, \n 2. BOTTOM_TO_TOP',
        horizontal_direction: 'Horizontally align in the direction of the child Nodes: \n 1. LEFT_TO_RIGHT \n 2. RIGHT_TO_LEFT',
        cell_size: 'In Grid layout, the size of each child element.',
        start_axis: 'In Grid layout, the arrangement direction of children elements.',
    },
    particle: {
        export_title: 'Export custom particle data to plist file.',
        export: 'Export',
        export_error: 'This resource does not support exports outside of the project',
        sync: 'Sync',
        sync_tips: 'Synchronize the parameters in the File to Custom',
    },
    editbox: {
        string: 'The initial input text of EditBox.',
        backgroundImage: 'The background image of EditBox.',
        returnType: 'The keyboard return type of EditBox. This is useful for keyboard of mobile device.',
        input_flag: 'Specify the input flag: password or capitalize word. ',
        input_mode: 'Specify the input mode: multiline or single line.',
        font_size: 'The font size of input label.',
        line_height: 'The line height of input label.',
        stay_on_top: 'Set to true and the input is always visible and be on top of the game view',
        tab_index: 'Set the tabIndex of the DOM input element, only useful on Web.',
        font_color: 'The font color of input label.',
        placeholder: 'The content string of placeholder.',
        placeholder_font_size: 'The font size of placeholder label.',
        placeholder_font_color: 'The font color of placeholder label.',
        max_length: 'The maximize input characters.',
    },
    videoplayer: {
        resourceType: 'The resource type of video player, REMOTE for remote url and LOCAL for local file path.',
        remoteURL: 'The remote URL of video.',
        clip: 'The local video clip',
        playOnAwake: 'Whether the video start playing automatically after loaded?',
        volume: 'The volume of the video.(0.0 ~ 1.0)',
        mute: 'Mutes the VideoPlayer. Mute sets the volume=0, Un-Mute restore the original volume.',
        playbackRate: 'The Video playback rate',
        loop: 'Whether the video should be played again at the end',
        keepAspectRatio: 'Whether keep the aspect ration of the original video.',
        fullScreenOnAwake: 'Whether play video in fullscreen mode?',
        stayOnBottom:
            'Always below the game view (only useful on Web. Note: The specific effects are not guaranteed to be consistent, depending on whether each browser supports or restricts).',
        videoPlayerEvent:
            "The video player's callback, it will be triggered when certain event occurs, like: playing, paused, stopped and completed.",
    },
    webview: {
        url: 'A given URL to be loaded by the Webview, it should have a http or https prefix.',
        webviewEvents: "The Webview's event callback , it will be triggered when certain Webview event occurs.",
    },
    richtext: {
        string: 'Text of the RichText, you could use BBcode in the string',
        horizontal_align: 'Horizontal alignment',
        font_size: 'Font size, in points',
        font: 'Custom TTF font of RichText',
        font_family:'Custom System font of RichText',
        use_system_font: 'Using system font',
        cache_mode: 'The cache mode of label. This mode only supports system fonts.',
        max_width: 'The maximize width of RichText, pass 0 means not limit the maximize width.',
        line_height: 'Line height, in points',
        image_atlas:
            'The image atlas for the img tag. For each src value in the img tag, there should be a valid spriteFrame in the image atlas.',
        handleTouchEvent:
            'Once checked, the RichText will block all input events (mouse and touch) within the bounding box of the node, preventing the input from penetrating into the underlying node.',
    },
    skeleton: {
        skeleton_data: 'The skeleton data contains the skeleton information, drag the json file exported from Spine to get started.',
        default_skin: 'Choose the default skin.',
        animation: 'The name of current playing animation.',
        loop: 'Whether loop current animation',
        time_scale: 'The time scale of animations of this skeleton',
        debug_slots: 'Indicates whether show debug slots.',
        debug_bones: 'Indicates whether show debug bones.',
        premultipliedAlpha: 'Indicates whether to enable premultiplied alpha.',
    },
    dragon_bones: {
        dragon_bones_asset:
            'The json data contains the DragonBones information, drag the json file exported from DragonBones to get started.',
        dragon_bones_atlas_asset:
            'The json data contains the Texture information, drag the json file exported from DragonBones to get started.',
        armature_name: 'The name of current armature.',
        animation_name: 'The name of current playing animation.',
        time_scale: 'The time scale of this armature.',
        play_times:
            'The play times of the default animation.\n-1 means using the value of config file\n0 means repeat for ever\n>0 means repeat times',
        debug_bones: 'Indicates whether open debug bones',
    },
    motionStreak: {
        fadeTime: 'Trail fragment fade time, in seconds',
        minSeg: 'The minimum distance between of the trail',
        stroke: 'The width of the trail',
        texture: 'The texture of the trail',
        color: 'The color of the trail',
        fastMode: 'Whether to enable fast mode',
    },
    missing_scirpt: {
        error_compiled:
            'Error on executing script, or the script reference is missing. Please check error log carefully and correct/recover your script. The component will be restored once scripting error is gone. If you no long need the missing script, please remove this component manually.',
        error_not_compiled:
            'Error on compiling script. Please check error log carefully and correct your script. This component will be restored once compiling error is gone.',
    },
    collider: {
        editing: 'Edit this collider component',
        category: 'Collider component category',
        mask: 'The collider mask can collide with this collider',
    },
    particle_system: {
        preview: 'Play particle in edit mode',
        custom: 'If set custom to true, then use custom properties insteadof read particle file',
        file: 'The plist file',
        spriteFrame: 'SpriteFrame of Particle System',
        texture: 'Texture of Particle System, readonly, please use spriteFrame to setup new texture',
        particleCount: 'Current quantity of particles that are being simulated',
        srcBlendFactor: 'Specify the source Blend Factor',
        dstBlendFactor: 'Specify the destination Blend Factor',
        playOnLoad: 'If set to true, the particle system will automatically start playing on onLoad',
        autoRemoveOnFinish: 'Indicate whether the owner node will be auto-removed when it has no particles left',
        duration: 'How many seconds the emitter wil run. -1 means forever',
        emissionRate: 'Emission rate of the particles',
        life: 'Life and variation of each particle setter',
        totalParticles: 'Maximum particles of the system',
        startColor: 'Start color of each particle',
        startColorVar: 'Variation of the start color',
        endColor: 'Ending color of each particle',
        endColorVar: 'Variation of the end color',
        angle: 'Angle and variation of each particle setter',
        startSize: 'Start size and variation in pixels of each particle',
        endSize: 'End size and variation in pixels of each particle',
        startSpin: 'Start angle and variation of each particle',
        endSpin: 'End angle and variation of each particle',
        sourcePos: 'Source position of the emitter',
        posVar: 'Variation of source position',
        positionType: 'Particles movement type',
        emitterMode: 'Particles emitter modes',
        gravity: 'Gravity of the emitter',
        speed: 'Speed and variation of the emitter',
        tangentialAccel: 'Tangential acceleration and variation of each particle. Only available in Gravity mode ',
        radialAccel: 'Acceleration and variation of each particle. Only available in Gravity mode',
        rotationIsDir: 'Indicate whether the rotation of each particle equals to its direction. Only available in Gravity mode',
        startRadius: 'Starting radius and variation of the particles. Only available in Radius mode',
        endRadius: 'Ending radius and variation of the particles. Only available in Radius mode',
        rotatePerS: 'Number of degress to rotate a particle around the source pos per second and variation. Only available in Radius mode',
    },
    mask: {
        type: 'The mask type',
        spriteFrame: 'The mask image',
        inverted: 'The Reverse mask (Not supported Canvas Mode)',
        alphaThreshold:
            'The alpha threshold，The content is drawn only where the stencil have pixel with alpha greater than the alphaThreshold (Not supported Canvas Mode)',
        segements: 'The segements for ellipse mask',
    },
    physics: {
        rigidbody: {
            enabledContactListener:
                'Should enabled contact listener. When a collision is trigger, the collision callback will only be called when enabled contact listener.',
            bullet: 'Is this a fast moving body that should be prevented from tunneling through other moving bodies?',
            type: 'Rigidbody type : Static, Kinematic, Dynamic or Animated.',
            allowSleep: 'Set this flag to false if this body should never fall asleep. Note that this increases CPU usage.',
            gravityScale: 'Scale the gravity applied to this body.',
            linearDamping:
                'Linear damping is use to reduce the linear velocity. The damping parameter can be larger than 1, but the damping effect becomes sensitive to the time step when the damping parameter is large.',
            angularDamping:
                'Angular damping is use to reduce the angular velocity. The damping parameter can be larger than 1 but the damping effect becomes sensitive to the time step when the damping parameter is large.',
            linearVelocity: "The linear velocity of the body's origin in world co-ordinates",
            angularVelocity: 'The angular velocity of the body.',
            fixedRotation: 'Should this body be prevented from rotating?',
            awake: 'Is this body initially awake or sleeping?',
        },
        physics_collider: {
            density: 'The density',
            sensor: 'A sensor collider collects contact information but never generates a collision response',
            friction: 'The friction coefficient, usually in the range [0,1].',
            restitution: 'The restitution (elasticity) usually in the range [0,1].',
            anchor: 'The anchor of the rigidbody.',
            connectedAnchor: 'The anchor of the connected rigidbody.',
            connectedBody: 'The rigidbody to which the other end of the joint is attached.',
            collideConnected: 'Should the two rigid bodies connected with this joint collide with each other?',
            distance: 'The distance separating the two ends of the joint.',
            frequency: 'The spring frequency.',
            dampingRatio: 'The damping ratio.',
            linearOffset: 'The linear offset from connected rigidbody to rigidbody.',
            angularOffset: 'The angular offset from connected rigidbody to rigidbody.',
            maxForce: 'The maximum force can be applied to rigidbody.',
            maxTorque: 'The maximum torque can be applied to rigidbody.',
            correctionFactor: 'The position correction factor in the range [0,1].',
            mouseRegion: "The node used to register touch evnet. If this is null, it will be the joint's node.",
            target: 'The target point. The mouse joint will move choosed rigidbody to target point.',
            localAxisA: 'The local joint axis relative to rigidbody.',
            enableLimit: 'Enable joint distance limit?',
            enableMotor: 'Enable joint motor?',
            lowerLimit: 'The lower joint limit.',
            upperLimit: 'The upper joint limit.',
            maxMotorForce: 'The maxium force can be applied to rigidbody to rearch the target motor speed.',
            motorSpeed: 'The expected motor speed.',
            referenceAngle: 'The reference angle. An angle between bodies considered to be zero for the joint angle.',
            lowerAngle: 'The lower angle.',
            upperAngle: 'The upper angle.',
            maxMotorTorque: 'The maxium torque can be applied to rigidbody to rearch the target motor speed.',
            maxLength: 'The max length.',
            offset: 'Position offset',
            size: 'Box size',
            radius: 'Circle radius',
            tag: 'Tag. If a node has several collider components, you can judge which type of collider is collided according to the tag.',
            points: 'Polygon points',
        },
    },
    block_input_events: {
        brief_help:
            'This component will block all input events, preventing the input from penetrating to other nodes below the screen, typically for the background of the top-level UI of the screen.',
    },
    tiledtile: {
        row: 'Specify the TiledTile horizontal coordinate，use map tile as the unit.',
        column: 'Specify the TiledTile vertical coordinate，use map tile as the unit.',
        gid: 'Specify the TiledTile gid.',
        layer: 'Specify which TiledLayer the TiledTile belong to.',
    },
    INSPECTOR: {
        component: {
            script: 'Custom Script',
        },
    },
    features: {
        categories: {
            '2d': {
                label: '2D',
                description: '2D',
            },
            '3d': {
                label: '3D',
                description: '3D',
            },
        },
        core: {
            label: "Core",
            description: "Cocos Creator core functionalities.",
        },
        graphics: {
            label: "Graphics Backend",
            description: "Select graphics back end used for rendering.",
        },
        gfx_webgl: {
            label: "WebGL",
            description: "Include support for WebGL 1.0 graphics API.",
        },
        gfx_webgl2: {
            label: "WebGL 2.0",
            description: "Include support for WebGL 2.0 graphics API.\n If WebGL 2.0 is not available on target platform, the one will fallback as WebGL 1.0.",
        },
        ui: {
            label: "User Interface",
            description: "User interface support.",
        },
        base_3d: {
            label: "Basic 3D Features",
            description: "Components and tools that are widely used in general 3D applications.",
        },
        particle: {
            label: "Particle System",
            description: "Particle system support.",
        },
        physics: {
            label: "Physics System",
            description: "Select physics system.",
        },
        physics_builtin: {
            label: "Builtin Physics System",
            description: "Builtin physics system support.",
        },
        physics_cannon: {
            label: "cannon.js Based Physics system",
            description: "Physics system that based on cannon.js.",
        },
        physics_ammo: {
            label: "ammo.js Based Physics System",
            description: "Physics system that based on ammo.js.",
        },
        physics_physx: {
            label: "PhysX Based Physics System",
            description: "Physics system that based on PhysX.",
        },
        primitives: {
            label: "Primitive Geometries",
            description: "Libraries that used to create primitive geometries.",
        },
        base_2d: {
            label: "Basic 2D Features",
            description: "Components and tools that are widely used in general 2D applications.",
        },
        physics_2d: {
            label: "2D Physics System",
            description: "Physics system that applied to 2D application.",
        },
        physics_2d_builtin: {
            label: "Builtin 2D Physics System",
            description: "Builtin 2D physics system support.",
        },
        physics_2d_box2d: {
            label: "Box2D Based 2D Physics System",
            description: "2D Physics system that based on Box2D.",
        },
        intersection_2d: {
            label: "2D Intersection Algorithms",
            description: "Include 2D intersection algorithms.",
        },
        particle_2d: {
            label: "2D Particle System",
            description: "Particle system that applied to 2D application.",
        },
        terrain: {
            label: "Terrain",
            description: "Terrain support.",
        },
        audio: {
            label: "Audio",
            description: "Audio playing support.",
        },
        video: {
            label: "Video",
            description: "Video playing support.",
        },
        webview: {
            label: "Web View",
            description: "Support displaying Web contents.",
        },
        tween: {
            label: "Tween",
            description: "Tween system.",
        },
        profiler: {
            label: "Running Stats",
            description: "Include various components and tools used to audit and display rendering stats.",
        },
        tiled_map: {
            label: "Tiled Map",
            description: "Tiled map support.",
        },
        spine: {
            label: "Spine Animation",
            description: "Spine Animation support.",
        },
        dragon_bones: {
            label: "DragonBones",
            description: "DragonBones support.",
        },
    },
    renderable_2d: {
        srcBlendFactor: 'Specifies the source blend mode, it will clone a new material object.',
        dstBlendFactor: 'Specifies the destination blend mode.',
        color: 'Main color for rendering, it normally multiplies with texture color.',
    },
    ui_transform: {
        content_size:'Size of the UI node.',
        anchor_point:'Anchor point of the UI node.',
        priority:'Priority of rendering ordering.',
    },
    graphics: {
        lineJoin: 'Determines how two connecting segments (of lines, arcs or curves) with non-zero lengths in a shape are joined together.',
        lineCap: 'Determines how the end points of every line are drawn.',
        strokeColor: 'Brush stroke color.',
        fillColor: 'Fill paint color.',
        miterLimit: 'Set the miter limit ratio.',
    },
};
