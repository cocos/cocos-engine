
precision highp float;
#include <common/math/transform>
#include <builtin/internal/particle-common>
#include <builtin/uniforms/cc-local>

in vec3 a_position;  // mesh position
in vec3 a_texCoord;  // mesh uv

#if CC_RENDER_MODE == RENDER_MODE_MESH
in vec3 a_normal;     // mesh normal
in vec4 a_color;     // mesh color
#endif

vec4 lpvs_main () {
  ParticleInput particleInput;
  setupParticleInput(particleInput);
  vec4 pos = vec4(particleInput.position.xyz, 1);
  vec3 rotation = particleInput.rotation;
  vec3 compScale = scale.xyz * particleInput.size;
  vec4 velocity = vec4(particleInput.velocity.xyz, 0.);

  #if !CC_USE_WORLD_SPACE
    // simulate in world space. apply cc_matWorld matrix on CPU side.
    pos = cc_matWorld * pos;
    #if CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
      velocity = cc_matWorld * velocity;
    #endif
  #endif

  #pragma define INDENTIFY_NEG_QUAT 10.0

  #if ROTATION_OVER_TIME_MODULE_ENABLE
    vec3 rotTmp = rotation;
    float mulFactor = 1.0;
    if (rotTmp.x > INDENTIFY_NEG_QUAT * 0.5) {
        rotTmp.x -= INDENTIFY_NEG_QUAT;
        mulFactor = -1.0;
    }
    vec4 rot = vec4(rotTmp, 0.0);
    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));
  #endif
  #if !ROTATION_OVER_TIME_MODULE_ENABLE
    #if CC_RENDER_MODE != RENDER_MODE_MESH
      #if CC_RENDER_MODE == RENDER_MODE_BILLBOARD
        vec3 rotEuler = rotation;
      #elif CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
        vec3 rotEuler = vec3(0.);
      #endif
      #if CC_RENDER_MODE != RENDER_MODE_BILLBOARD && CC_RENDER_MODE != RENDER_MODE_STRETCHED_BILLBOARD
        vec3 rotEuler = vec3(0., 0., rotation.z);
      #endif
      vec4 rot = quaternionFromEuler(rotEuler);
    #endif
    #if CC_RENDER_MODE == RENDER_MODE_MESH
      vec4 rot = quaternionFromEuler(rotation);
    #endif
  #endif

  #if CC_RENDER_MODE != RENDER_MODE_MESH
    vec2 cornerOffset = vec2(a_position.xy - 0.5);

    #if CC_RENDER_MODE == RENDER_MODE_BILLBOARD || CC_RENDER_MODE == RENDER_MODE_VERTICAL_BILLBOARD
      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);
    #elif CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_position.x);
    #elif RENDER_MODE_HORIZONTAL_BILLBOARD
      computeVertPos(pos, cornerOffset, rot, compScale);
    #endif

    color = particleInput.color;
  #endif
  #if CC_RENDER_MODE == RENDER_MODE_MESH
    mat3 rotMat = quatToMat3(rot);
    mat3 nodeMat = quatToMat3(nodeRotation);
    rotMat = nodeMat * rotMat;
    rot = mat3ToQuat(rotMat);

    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);
    mat4 xform = matFromRTS(rot, pos.xyz, compScale);
    pos = xform * vec4(a_position, 1);
    vec4 normal = xformNoScale * vec4(a_normal, 0);
    color = particleInput.color * a_color;
  #endif

  uv = computeUV(particleInput.frameIndex, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;
  pos = cc_matViewProj * pos;

  return pos;
}
