#pragma define-meta CC_VFX_RENDERER_TYPE range([0, 2])
#pragma define CC_VFX_RENDERER_TYPE_SPRITE 0
#pragma define CC_VFX_RENDERER_TYPE_MESH 1
#pragma define CC_VFX_RENDERER_TYPE_RIBBON 2

#pragma define-meta CC_VFX_SPRITE_FACING_MODE range([0, 3])
#pragma define CC_VFX_SPRITE_FACING_MODE_CAMERA 0
#pragma define CC_VFX_SPRITE_FACING_MODE_HORIZONTAL 1
#pragma define CC_VFX_SPRITE_FACING_MODE_VERTICAL 2
#pragma define CC_VFX_SPRITE_FACING_MODE_CUSTOM 3

#pragma define-meta CC_VFX_SPRITE_ALIGNMENT_MODE range([0, 2])
#pragma define CC_VFX_SPRITE_ALIGNMENT_MODE_NONE 0
#pragma define CC_VFX_SPRITE_ALIGNMENT_MODE_VELOCITY 1
#pragma define CC_VFX_SPRITE_ALIGNMENT_MODE_CUSTOM 2

uniform Constants {
  vec4 mainTiling_Offset;
  vec4 frameTile_velLenScale;
  vec4 scale;
  vec4 nodeRotation;
};

#include <builtin/uniforms/cc-global>
#include <builtin/uniforms/cc-local>
#include <common/math/transform>

precision highp float;


#if CC_VFX_P_POSITION
in vec3 a_vfx_p_position;
#endif
#if CC_VFX_P_MESH_ORIENTATION
in vec3 a_vfx_p_mesh_orientation;  // mesh orientation
#endif
#if CC_VFX_P_SPRITE_ROTATION
in float a_vfx_p_sprite_rotation;  // sprite rotation
#endif
#if CC_VFX_P_SCALE
in vec3 a_vfx_p_scale;  // scale
#endif
#if CC_VFX_P_SPRITE_SIZE
in vec2 a_vfx_p_sprite_size;  // sprite size
#endif
#if CC_VFX_P_COLOR
in vec4 a_vfx_p_color;
#endif
#if CC_VFX_P_SUB_UV_INDEX
in float a_vfx_p_sub_uv_index;
#endif
#if CC_VFX_P_VELOCITY
in vec3 a_vfx_p_velocity; // velocity.x, velocity.y, velocity.z
#endif

out mediump vec2 uv;
out mediump vec4 color;

void computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s
#if CC_RENDER_MODE == RENDER_MODE_BILLBOARD || CC_RENDER_MODE == RENDER_MODE_VERTICAL_BILLBOARD
  , mat4 viewInv
#endif
#if CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
  , vec3 eye
  , vec4 velocity
  , float velocityScale
  , float lengthScale
  , float xIndex
#endif
) {
#if CC_RENDER_MODE == RENDER_MODE_BILLBOARD
  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);
  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));
  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));
  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));
  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);
#elif CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;
  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;
  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;
#elif CC_RENDER_MODE == RENDER_MODE_HORIZONTAL_BILLBOARD
  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);
  vec3 camX = vec3(1, 0, 0);
  vec3 camY = vec3(0, 0, -1);
  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);
#elif CC_RENDER_MODE == RENDER_MODE_VERTICAL_BILLBOARD
  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);
  rotateVecFromQuat(viewSpaceVert, q);
  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));
  vec3 camY = vec3(0, 1, 0);
  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;
  pos.xyz += offset;
#else
  pos.x += vertOffset.x;
  pos.y += vertOffset.y;
#endif
}

vec2 computeUV (float subUVIndex, vec2 vertIndex, vec2 frameTile){
  vec2 aniUV = vec2(0, floor(subUVIndex * frameTile.y));
  aniUV.x = floor(subUVIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);
#if CC_RENDER_MODE != RENDER_MODE_MESH
  vertIndex.y = 1. - vertIndex.y; // if using billboard ,y must be flipped.but mesh does not,why?
#endif
  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);
}

struct ParticleInput {
  vec3 position;
  vec3 meshOrientation;
  float spriteRotation;
  vec3 scale;
  vec2 spriteSize;
  vec4 color;
  float subUVIndex;
  vec3 velocity;
};

void setupParticleInput (out ParticleInput particleInput) {
  #if CC_VFX_P_POSITION
  particleInput.position = a_vfx_p_position;
  #else
  particleInput.position = vec3(0., 0., 0.);
  #endif
  #if CC_VFX_P_MESH_ORIENTATION
  particleInput.meshOrientation = a_vfx_p_mesh_orientation;
  #else 
  particleInput.meshOrientation = vec3(0., 0., 0.);
  #endif
  #if CC_VFX_P_SPRITE_ROTATION
  particleInput.spriteRotation = a_vfx_p_sprite_rotation;
  #else
  particleInput.spriteRotation = 0.;
  #endif
  #if CC_VFX_P_SCALE
  particleInput.scale = a_vfx_p_scale;
  #else
  particleInput.scale = vec3(1.0, 1.0, 1.0);
  #endif
  #if CC_VFX_P_SPRITE_SIZE
  particleInput.spriteSize = a_vfx_p_sprite_size;
  #else
  particleInput.spriteSize = vec3(1.0, 1.0);
  #endif
  #if CC_VFX_P_COLOR
  particleInput.color = a_vfx_p_color;
  #else
  particleInput.color = vec4(1.0, 1.0, 1.0, 1.0);
  #endif
  #if CC_VFX_P_SUB_UV_INDEX
  particleInput.subUVIndex = a_vfx_p_sub_uv_index;
  #else
  particleInput.subUVIndex = 0.0;
  #endif
  #if CC_VFX_P_VELOCITY
  particleInput.velocity = a_vfx_p_velocity;
  #else
  particleInput.velocity = vec3(0., 0., 0.);
  #endif
}

in vec3 a_position;  // mesh position
in vec3 a_texCoord;  // mesh uv

#if CC_RENDER_MODE == RENDER_MODE_MESH
in vec3 a_normal;     // mesh normal
in vec4 a_color;     // mesh color
#endif

vec4 vfx_vs_main () {
  ParticleInput particleInput;
  setupParticleInput(particleInput);
  vec4 pos = vec4(particleInput.position.xyz, 1);
  vec3 meshOrientation = particleInput.meshOrientation;
  vec3 compScale = scale.xyz * particleInput.scale;
  vec4 velocity = vec4(particleInput.velocity.xyz, 0.);

  #if !CC_USE_WORLD_SPACE
    // simulate in world space. apply cc_matWorld matrix on CPU side.
    pos = cc_matWorld * pos;
    #if CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
      velocity = cc_matWorld * velocity;
    #endif
  #endif

  #pragma define INDENTIFY_NEG_QUAT 10.0

  #if ROTATION_OVER_TIME_MODULE_ENABLE
    vec3 rotTmp = meshOrientation;
    float mulFactor = 1.0;
    if (rotTmp.x > INDENTIFY_NEG_QUAT * 0.5) {
        rotTmp.x -= INDENTIFY_NEG_QUAT;
        mulFactor = -1.0;
    }
    vec4 rot = vec4(rotTmp, 0.0);
    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));
  #endif
  #if !ROTATION_OVER_TIME_MODULE_ENABLE
    #if CC_RENDER_MODE != RENDER_MODE_MESH
      #if CC_RENDER_MODE == RENDER_MODE_BILLBOARD
        vec3 rotEuler = meshOrientation;
      #elif CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
        vec3 rotEuler = vec3(0.);
      #endif
      #if CC_RENDER_MODE != RENDER_MODE_BILLBOARD && CC_RENDER_MODE != RENDER_MODE_STRETCHED_BILLBOARD
        vec3 rotEuler = vec3(0., 0., meshOrientation.z);
      #endif
      vec4 rot = quaternionFromEuler(rotEuler);
    #endif
    #if CC_RENDER_MODE == RENDER_MODE_MESH
      vec4 rot = quaternionFromEuler(meshOrientation);
    #endif
  #endif

  #if CC_RENDER_MODE != RENDER_MODE_MESH
    vec2 cornerOffset = vec2(a_position.xy - 0.5);

    #if CC_RENDER_MODE == RENDER_MODE_BILLBOARD || CC_RENDER_MODE == RENDER_MODE_VERTICAL_BILLBOARD
      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);
    #elif CC_RENDER_MODE == RENDER_MODE_STRETCHED_BILLBOARD
      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_position.x);
    #elif RENDER_MODE_HORIZONTAL_BILLBOARD
      computeVertPos(pos, cornerOffset, rot, compScale);
    #endif

    color = particleInput.color;
  #endif
  #if CC_RENDER_MODE == RENDER_MODE_MESH
    mat3 rotMat = quatToMat3(rot);
    mat3 nodeMat = quatToMat3(nodeRotation);
    rotMat = nodeMat * rotMat;
    rot = mat3ToQuat(rotMat);

    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);
    mat4 xform = matFromRTS(rot, pos.xyz, compScale);
    pos = xform * vec4(a_position, 1);
    vec4 normal = xformNoScale * vec4(a_normal, 0);
    color = particleInput.color * a_color;
  #endif

  uv = computeUV(particleInput.subUVIndex, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;
  pos = cc_matViewProj * pos;

  return pos;
}



