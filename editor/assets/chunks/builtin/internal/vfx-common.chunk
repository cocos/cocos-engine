#pragma define-meta CC_VFX_RENDERER_TYPE range([0, 2])
#pragma define CC_VFX_RENDERER_TYPE_SPRITE 0
#pragma define CC_VFX_RENDERER_TYPE_MESH 1
#pragma define CC_VFX_RENDERER_TYPE_RIBBON 2

#pragma define-meta CC_VFX_SPRITE_FACING_MODE range([0, 3])
#pragma define CC_VFX_SPRITE_FACING_MODE_CAMERA 0
#pragma define CC_VFX_SPRITE_FACING_MODE_HORIZONTAL 1
#pragma define CC_VFX_SPRITE_FACING_MODE_VERTICAL 2
#pragma define CC_VFX_SPRITE_FACING_MODE_CUSTOM 3

#pragma define-meta CC_VFX_SPRITE_ALIGNMENT_MODE range([0, 2])
#pragma define CC_VFX_SPRITE_ALIGNMENT_MODE_NONE 0
#pragma define CC_VFX_SPRITE_ALIGNMENT_MODE_VELOCITY 1
#pragma define CC_VFX_SPRITE_ALIGNMENT_MODE_CUSTOM 2

uniform VFXConstants {
  vec2 u_vfx_sub_image_size;
  vec2 u_vfx_sprite_pivot;
  vec4 nodeRotation;
};

#include <builtin/uniforms/cc-global>
#include <builtin/uniforms/cc-local>
#include <common/math/transform>

#if CC_VFX_P_POSITION
in vec3 a_vfx_p_position;
#endif
#if CC_VFX_P_MESH_ORIENTATION
in vec3 a_vfx_p_mesh_orientation;  // mesh orientation
#endif
#if CC_VFX_P_SPRITE_ROTATION
in float a_vfx_p_sprite_rotation;  // sprite rotation
#endif
#if CC_VFX_P_SCALE
in vec3 a_vfx_p_scale;  // scale
#endif
#if CC_VFX_P_SPRITE_SIZE
in vec2 a_vfx_p_sprite_size;  // sprite size
#endif
#if CC_VFX_P_COLOR
in vec4 a_vfx_p_color;
#endif
#if CC_VFX_P_SUB_UV_INDEX
in float a_vfx_p_sub_uv_index;
#endif
#if CC_VFX_P_VELOCITY
in vec3 a_vfx_p_velocity; // velocity.x, velocity.y, velocity.z
#endif

void computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec2 size
) {
#if CC_VFX_SPRITE_FACING_MODE == CC_VFX_SPRITE_FACING_MODE_CAMERA
  vec3 viewSpaceVert = vec3(vertOffset.x * size.x, vertOffset.y * size.y, 0.);
  vec3 camX = normalize(vec3(cc_matViewInv[0][0], cc_matViewInv[1][0], cc_matViewInv[2][0]));
  vec3 camY = normalize(vec3(cc_matViewInv[0][1], cc_matViewInv[1][1], cc_matViewInv[2][1]));
  vec3 camZ = normalize(vec3(cc_matViewInv[0][2], cc_matViewInv[1][2], cc_matViewInv[2][2]));
  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);
#elif CC_VFX_SPRITE_FACING_MODE == CC_VFX_SPRITE_FACING_MODE_HORIZONTAL
  vec3 viewSpaceVert = vec3(vertOffset.x * size.x, vertOffset.y * size.y, 0.);
  vec3 camX = vec3(1, 0, 0);
  vec3 camY = vec3(0, 0, -1);
  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);
#elif CC_VFX_SPRITE_FACING_MODE == CC_VFX_SPRITE_FACING_MODE_VERTICAL
  vec3 viewSpaceVert = vec3(vertOffset.x * size.x, vertOffset.y * size.y, 0.);
  rotateVecFromQuat(viewSpaceVert, q);
  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));
  vec3 camY = vec3(0, 1, 0);
  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;
  pos.xyz += offset;
#else
  pos.x += vertOffset.x;
  pos.y += vertOffset.y;
#endif
}

struct VFXParticleInput {
  vec3 position;
  #if CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_SPRITE
  vec2 spriteSize;
  vec3 velocity;
  float spriteRotation;
  float subUVIndex;
  #endif
  #if CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_MESH
  vec3 meshOrientation;
  vec3 scale;
  float subUVIndex;
  #endif
  vec4 color;
};

void CCVFXSetupParticleInput (out VFXParticleInput particleInput) {
  #if CC_VFX_P_POSITION
  particleInput.position = a_vfx_p_position;
  #else
  particleInput.position = vec3(0., 0., 0.);
  #endif
  #if CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_SPRITE
  #if CC_VFX_P_VELOCITY
  particleInput.velocity = a_vfx_p_velocity;
  #else
  particleInput.velocity = vec3(0., 0., 0.);
  #endif
  #if CC_VFX_P_SPRITE_ROTATION
  particleInput.spriteRotation = a_vfx_p_sprite_rotation;
  #else
  particleInput.spriteRotation = 0.;
  #endif
  #if CC_VFX_P_SPRITE_SIZE
  particleInput.spriteSize = a_vfx_p_sprite_size;
  #else
  particleInput.spriteSize = vec3(1.0, 1.0);
  #endif
  #if CC_VFX_P_SUB_UV_INDEX
  particleInput.subUVIndex = a_vfx_p_sub_uv_index;
  #else
  particleInput.subUVIndex = 0.0;
  #endif
  #elif CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_MESH
  #if CC_VFX_P_MESH_ORIENTATION
  particleInput.meshOrientation = a_vfx_p_mesh_orientation;
  #else 
  particleInput.meshOrientation = vec3(0., 0., 0.);
  #endif
  #if CC_VFX_P_SCALE
  particleInput.scale = a_vfx_p_scale;
  #else
  particleInput.scale = vec3(1.0, 1.0, 1.0);
  #endif
  #if CC_VFX_P_SUB_UV_INDEX
  particleInput.subUVIndex = a_vfx_p_sub_uv_index;
  #else
  particleInput.subUVIndex = 0.0;
  #endif
  #endif // CC_VFX_RENDERER_TYPE
  #if CC_VFX_P_COLOR
  particleInput.color = a_vfx_p_color;
  #else
  particleInput.color = vec4(1.0, 1.0, 1.0, 1.0);
  #endif
  
}

vec4 CCVFXApplyParticlePosition (VFXParticleInput particleInput, vec3 position) {
  vec4 pos = vec4(particleInput.position.xyz, 1);

  #if CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_SPRITE
    vec4 rot = quaternionFromEuler(vec3(0., 0., particleInput.spriteRotation));
  #elif CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_MESH
    vec4 rot = quaternionFromEuler(particleInput.meshOrientation);
  #endif

  #if CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_SPRITE
    vec2 offset = vec2(position.xy - u_vfx_sprite_pivot);
    computeVertPos(pos, offset, rot, particleInput.spriteSize);
  #elif CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_MESH
    mat3 rotMat = quatToMat3(rot);
    mat3 nodeMat = quatToMat3(nodeRotation);
    rotMat = nodeMat * rotMat;
    rot = mat3ToQuat(rotMat);

    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);
    mat4 xform = matFromRTS(rot, pos.xyz, particleInput.scale);
    pos = xform * vec4(position, 1);
    vec4 normal = xformNoScale * vec4(a_normal, 0);
  #endif
  return pos;
}

vec2 CCVFXApplyParticleTexCoord (VFXParticleInput particleInput, vec2 texCoord) {
  #if CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_SPRITE || CC_VFX_RENDERER_TYPE == CC_VFX_RENDERER_TYPE_MESH
  float frameY = floor(particleInput.subUVIndex * u_vfx_sub_image_size.y);
  float frameX = floor(particleInput.subUVIndex * u_vfx_sub_image_size.x * u_vfx_sub_image_size.y - frameY * u_vfx_sub_image_size.x);
  return (vec2(frameX, frameY) + texCoord) / vec2(u_vfx_sub_image_size.x, u_vfx_sub_image_size.y);
  #else
  return texCoord;
  #endif
}

vec4 CCVFXApplyParticleColor (VFXParticleInput particleInput, vec4 color) {
  return color * particleInput.color;
}
