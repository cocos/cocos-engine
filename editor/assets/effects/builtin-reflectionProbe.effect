// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      properties: &props
        tilingOffset:   { value: [1, 1, 0, 0] }
        mainColor:      { value: [1, 1, 1, 1], linear: true, editor: { type: color } }
        colorScale:     { value: [1, 1, 1], target: colorScaleAndCutoff.xyz }
        alphaThreshold: { value: 0.5, target: colorScaleAndCutoff.w, editor: { parent: USE_ALPHA_TEST } }
        mainTexture:    { value: grey}
        noiseTexture:   { value: white }
        noiseParams:    { value: [1, 1, 0, 0] }
      migrations: &migs
        properties:
          mainColor:    { formerlySerializedAs: color }
  - name: transparent
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      depthStencilState: &d1
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
      migrations: *migs
  - name: add
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      rasterizerState: &r1 { cullMode: none }
      depthStencilState: *d1
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one
          blendSrcAlpha: src_alpha
          blendDstAlpha: one
      properties: *props
      migrations: *migs
  - name: alpha-blend
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      rasterizerState: *r1
      depthStencilState: *d1
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
      migrations: *migs
}%

CCProgram unlit-vs %{
  precision highp float;
  #include <legacy/input>
  #include <builtin/uniforms/cc-global>
  #include <legacy/decode-base>
  #include <legacy/local-batch>
  #include <legacy/input>
  #include <legacy/fog-vs>

  #if USE_VERTEX_COLOR
    in lowp vec4 a_color;
    out lowp vec4 v_color;
  #endif

  out vec2 v_uv;
  uniform TexCoords {
    vec4 tilingOffset;
  };

  out mediump vec4 viewDir;

  out vec4 v_screenPos;

  out vec4 v_position;



  vec4 vert () {
    CCDecode(viewDir);
    vec4 position=vec4(a_position,1.0);
    //CCVertInput(position);

    mat4 matWorld;
    CCGetWorldMatrix(matWorld);

    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;


    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(v_uv);
    #endif

    CC_TRANSFER_FOG(matWorld * position);

    v_position = matWorld * position;

    v_screenPos = cc_matProj * (cc_matView * matWorld) * position;
    return v_screenPos;
  }
}%

CCProgram unlit-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/uniforms/cc-reflection-probe>
  #include <builtin/uniforms/cc-environment>
  #include <common/texture/texture-lod>
  #include <common/data/unpack>
  #include <common/color/gamma>
  #include <legacy/output-standard>
  #include <common/math/coordinates>


  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r, g, b])
  #endif

  in vec2 v_uv;

  in vec4 v_screenPos;

  in vec4 v_position;


  uniform Constant {
    vec4 mainColor;
    vec4 colorScaleAndCutoff;
    vec4 noiseParams;
  };

  #if USE_VERTEX_COLOR
    in lowp vec4 v_color;
  #endif

  in mediump vec4 viewDir;

  uniform sampler2D mainTexture;

  uniform sampler2D noiseTexture;


  vec4 frag () {
    vec4 o = mainColor;
    o.rgb *= colorScaleAndCutoff.xyz;

    #if USE_REFLECTION_PROBE == REFLECTION_PROBE_CUBE
      vec4 c = fragTextureLod(cc_reflectionProbeCubemap, viewDir.xyz, 0.0);
      c.rgb = unpackRGBE(c);
      return c;
      //return vec4(0.0,1.0,0.0,1.0);
    #elif USE_REFLECTION_PROBE == REFLECTION_PROBE_PLANAR
      float reflNoiseScale = noiseParams.x;
      vec2 reflNoiseMove = noiseParams.yz;
      float reflNoiseStrengthen = noiseParams.w;

      vec2 noiseUV = v_position.xz * reflNoiseScale+ reflNoiseMove;
      
      float offset = texture(noiseTexture, noiseUV).r;
      offset = offset*2.0-1.0;
      offset*=reflNoiseStrengthen;

      vec4 worldPos = vec4(v_position.xyz, 1.0);
      vec4 clipPos = cc_matViewProj * worldPos;
  
      vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;
      screenUV = vec2(1.0 - screenUV.x, screenUV.y);
      screenUV += offset;

      vec4 color= texture(cc_reflectionProbePlanarMap, screenUV);
      color.rgb = unpackRGBE(color);
      #if CC_USE_RGBE_OUTPUT
        return vec4(1.0,0.0,0.0,1.0);
      #endif      
        return color*0.3;
    #else
      vec4 c = fragTextureLod(cc_environment, viewDir.xyz, 0.0);
      return c;
    #endif
   
  }
}%
