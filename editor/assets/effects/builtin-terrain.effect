// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: terrain-vs
      frag: terrain-fs
      properties: &props
        UVScale:      { value: [1, 1, 1, 1] }
        metallic:     { value: [0, 0, 0, 0] }
        roughness:    { value: [1, 1, 1, 1] }
        weightMap:    { value: black }
        detailMap0:   { value: grey }
        detailMap1:   { value: grey }
        detailMap2:   { value: grey }
        detailMap3:   { value: grey }
        normalMap0:   { value: normal }
        normalMap1:   { value: normal }
        normalMap2:   { value: normal }
        normalMap3:   { value: normal }
    - vert: terrain-vs
      frag: terrain-fs
      phase: forward-add
      propertyIndex: 0
      embeddedMacros: { CC_FORWARD_ADD: true }
      depthStencilState:
        depthFunc: equal
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: one
          blendDst: one
          blendSrcAlpha: zero
          blendDstAlpha: one
      properties: *props
}%

CCProgram terrain-vs %{
  precision mediump float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/uniforms/cc-local>

  in vec3 a_position;
  in vec3 a_normal;
  in vec2 a_texCoord;

  out highp vec3 v_position;
  out mediump vec3 v_normal;
  out mediump vec2 uvw;
  out mediump vec2 uv0;
  out mediump vec2 uv1;
  out mediump vec2 uv2;
  out mediump vec2 uv3;
  out mediump vec3 luv;
  out mediump vec3 diffuse;

  uniform TexCoords {
    vec4 UVScale;
    vec4 lightMapUVParam;
  };

  void main () {
    vec3 worldPos;
    worldPos.x = cc_matWorld[3][0] + a_position.x;
    worldPos.y = cc_matWorld[3][1] + a_position.y;
    worldPos.z = cc_matWorld[3][2] + a_position.z;

    vec4 pos = vec4(worldPos, 1.0);
    pos = cc_matViewProj * pos;

    uvw = a_texCoord;
    uv0 = a_position.xz * UVScale.x;
    uv1 = a_position.xz * UVScale.y;
    uv2 = a_position.xz * UVScale.z;
    uv3 = a_position.xz * UVScale.w;
    #if CC_USE_LIGHTMAP
      luv.xy = cc_lightingMapUVParam.xy + a_texCoord * cc_lightingMapUVParam.z;
      luv.z = cc_lightingMapUVParam.w;
    #endif

    v_position = worldPos;
    v_normal = a_normal;
    gl_Position = pos;
  }
}%

CCProgram terrain-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #pragma define-meta LAYERS range([0, 4])

  in highp vec3 v_position;
  in mediump vec3 v_normal;

  in mediump vec2 uvw;
  in mediump vec2 uv0;
  in mediump vec2 uv1;
  in mediump vec2 uv2;
  in mediump vec2 uv3;
  in mediump vec3 diffuse;
  in mediump vec3 luv;

  uniform PbrParams {
    vec4 metallic;
    vec4 roughness;
  };

  uniform sampler2D weightMap;
  uniform sampler2D detailMap0;
  uniform sampler2D detailMap1;
  uniform sampler2D detailMap2;
  uniform sampler2D detailMap3;
  uniform sampler2D normalMap0;
  uniform sampler2D normalMap1;
  uniform sampler2D normalMap2;
  uniform sampler2D normalMap3;


layout(location = 0) out vec4 fragColorX;
  void main () {
    fragColorX = vec4(1.0);
  }
}%
