// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.

CCEffect %{
  techniques:
  - passes:
    - vert: blur-vs
      frag: prefilter-fs
      pass: blur-prefilter
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: equal
        stencilRef: 0x78 # [0~255],use 120
    # Supports up to MAX_BLUR_FILTER_PASS_NUM upsampling/downsampling passes
    - vert: blur-vs
      frag: downsampling-fs
      pass: blur-downsampling0
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: downsampling-fs
      pass: blur-downsampling1
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: downsampling-fs
      pass: blur-downsampling2
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: downsampling-fs
      pass: blur-downsampling3
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: downsampling-fs
      pass: blur-downsampling4
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: downsampling-fs
      pass: blur-downsampling5
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: upsampling-fs
      pass: blur-upsampling0
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: upsampling-fs
      pass: blur-upsampling1
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: upsampling-fs
      pass: blur-upsampling2
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: upsampling-fs
      pass: blur-upsampling3
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: upsampling-fs
      pass: blur-upsampling4
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: upsampling-fs
      pass: blur-upsampling5
      depthStencilState:
        depthTest: false
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: always
        stencilPassOpFront: replace
        stencilFailOpFront: keep
        stencilRef: 0x78 # [0~255],use 120
    - vert: blur-vs
      frag: combine-fs
      pass: blur-combine
      depthStencilState:
        depthTest: false
        depthWrite: false
}%

CCProgram blur-vs %{
  precision highp float;
  #include <legacy/input-standard>
  #include <builtin/uniforms/cc-global>
  #include <common/common-define>

  out vec2 v_uv;

  void main () {
    StandardVertInput In;
    CCVertInput(In);
    CC_HANDLE_GET_CLIP_FLIP(In.position.xy);
    gl_Position = In.position;
    gl_Position.y = gl_Position.y;
    v_uv = a_texCoord;
  }
}%

CCProgram prefilter-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <common/color/gamma>

  in vec2 v_uv;

  uniform blurUBO {
    mediump vec4 texSize;
  };
  #pragma rate outputResultMap pass
  uniform sampler2D outputResultMap;
  #pragma rate outputResultDSMap pass
  uniform sampler2D outputResultDSMap;

  layout(location = 0) out vec4 fragColor;

  float luminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
  }

  void main() {
    // vec3 color = texture(outputResultMap, v_uv).xyz;
    vec3 color = texture(outputResultDSMap, v_uv).xyz;

    // if (luminance(SRGBToLinear(color)) > texSize.z) {
    //   fragColor = vec4(color, 1.0);
    // } else {
    //   fragColor = vec4(0.0, 0.0, 0.0, 1.0);
    // }
    //vec3 linearColor = SRGBToLinear(color);
    //linearColor.x += 0.5;
    // fragColor = vec4(linearColor, 1.0);
    fragColor = vec4(color, 1.0);
  }
}%

CCProgram downsampling-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>

  in vec2 v_uv;

  uniform blurUBO {
    mediump vec4 texSize;
  };
  #pragma rate blurTexture pass
  uniform sampler2D blurTexture;

  layout(location = 0) out vec4 fragColor;

#pragma define SAM(uv) texture(blurTexture, uv).xyz

  vec3 downsampling(vec2 uv, vec2 halfpixel) {
    vec3 sum = SAM(uv) * 4.0;
    sum += SAM(uv - halfpixel.xy);
    sum += SAM(uv + halfpixel.xy);

    halfpixel.y = -halfpixel.y;
    sum += SAM(uv - halfpixel.xy);
    sum += SAM(uv + halfpixel.xy);
    return sum / 8.0;
  }

  vec3 downsampling4taps(vec2 uv, vec2 halfpixel) {
    vec3 sum = SAM(uv + vec2(-halfpixel.x, halfpixel.y));
        sum += SAM(uv + vec2(halfpixel.x, halfpixel.y));
        sum += SAM(uv + vec2(halfpixel.x, -halfpixel.y));
        sum += SAM(uv + vec2(-halfpixel.x, -halfpixel.y));
    return sum / 4.0;
  }

  void main()
  {
    vec3 result = downsampling4taps(v_uv, 1.0 / texSize.xy).rgb;

    fragColor = vec4(result, 1.0);
  }
}%

CCProgram upsampling-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>

  in vec2 v_uv;

  uniform blurUBO {
    mediump vec4 texSize;
  };
  #pragma rate blurTexture pass
  uniform sampler2D blurTexture;

  layout(location = 0) out vec4 fragColor;

#pragma define SAM(uv) texture(blurTexture, uv).xyz

  vec3 upsampling(vec2 uv, vec2 halfpixel) {
    vec3 sum = SAM(uv + vec2(-halfpixel.x * 2.0, 0.0));
        sum += SAM(uv + vec2(-halfpixel.x, halfpixel.y)) * 2.0;
        sum += SAM(uv + vec2(0.0, halfpixel.y * 2.0));
        sum += SAM(uv + vec2(halfpixel.x, halfpixel.y)) * 2.0;
        sum += SAM(uv + vec2(halfpixel.x * 2.0, 0.0));
        sum += SAM(uv + vec2(halfpixel.x, -halfpixel.y)) * 2.0;
        sum += SAM(uv + vec2(0.0, -halfpixel.y * 2.0));
        sum += SAM(uv + vec2(-halfpixel.x, -halfpixel.y)) * 2.0;
        return sum / 12.0;
  }

  vec3 upsampling4taps(vec2 uv, vec2 halfpixel) {
    vec3 sum = SAM(uv + vec2(-halfpixel.x, halfpixel.y));
        sum += SAM(uv + vec2(halfpixel.x, halfpixel.y));
        sum += SAM(uv + vec2(halfpixel.x, -halfpixel.y));
        sum += SAM(uv + vec2(-halfpixel.x, -halfpixel.y));
    return sum / 4.0;
  }

  void main() {
    vec3 result = upsampling4taps(v_uv, 0.5 / texSize.xy).rgb;

    fragColor = vec4(result, 1.0);
  }
}%

CCProgram combine-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>

  in vec2 v_uv;

  uniform blurUBO {
    mediump vec4 texSize;
  };
  #pragma rate outputResultMap pass
  uniform sampler2D outputResultMap;
  #pragma rate blurTexture pass
  uniform sampler2D blurTexture;

  layout(location = 0) out vec4 fragColor;

  void main() {
    vec4 hdrColor = texture(outputResultMap, v_uv);
    vec4 blurColor = texture(blurTexture, v_uv);
    vec3 result = hdrColor.rgb + blurColor.rgb * texSize.w * hdrColor.a;

    fragColor = vec4(result, blurColor.a);
  }
}%