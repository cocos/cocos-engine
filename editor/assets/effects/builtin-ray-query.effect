// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.

CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: ray-query-vs
      frag: ray-query-fs
      properties: &props
        tilingOffset:         { value: [1.0, 1.0, 0.0, 0.0] }
        mainColor:            { value: [1.0, 1.0, 1.0, 1.0], target: albedo, linear: true, editor: { displayName: Albedo, type: color } }
        albedoScale:          { value: [1.0, 1.0, 1.0], target: albedoScaleAndCutoff.xyz }
        alphaThreshold:       { value: 0.5, target: albedoScaleAndCutoff.w, editor: { parent: USE_ALPHA_TEST, slide: true, range: [0, 1.0], step: 0.001 } }
        occlusion:            { value: 1.0, target: pbrParams.x, editor: { slide: true, range: [0, 1.0], step: 0.001 } }
        roughness:            { value: 0.8, target: pbrParams.y, editor: { slide: true, range: [0, 1.0], step: 0.001 } }
        metallic:             { value: 0.6, target: pbrParams.z, editor: { slide: true, range: [0, 1.0], step: 0.001 } }
        specularIntensity:    { value: 0.5, target: pbrParams.w, editor: { slide: true, range: [0.0, 1.0], step: 0.001 } }
        emissive:             { value: [0.0, 0.0, 0.0, 1.0], linear: true, editor: { type: color } }
        emissiveScale:        { value: [1.0, 1.0, 1.0], target: emissiveScaleParam.xyz }
        normalStrength:       { value: 1.0, target: emissiveScaleParam.w, editor: { parent: USE_NORMAL_MAP, slide: true, range: [0, 5.0], step: 0.001 } }
        mainTexture:          { value: grey, target: albedoMap, editor: { displayName: AlbedoMap } }
        normalMap:            { value: normal }
        pbrMap:               { value: grey }
        metallicRoughnessMap: { value: grey }
        occlusionMap:         { value: white }
        emissiveMap:          { value: grey }
    - &forward-add
      vert: ray-query-vs
      frag: ray-query-fs
      phase: forward-add
      propertyIndex: 0
      embeddedMacros: { CC_FORWARD_ADD: true }
      depthStencilState:
        depthFunc: equal
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: one
          blendDst: one
          blendSrcAlpha: zero
          blendDstAlpha: one
    - &shadow-caster
      vert: shadow-caster-vs:vert
      frag: shadow-caster-fs:frag
      phase: shadow-caster
      propertyIndex: 0
      rasterizerState:
        cullMode: front
      properties:
        tilingOffset:   { value: [1.0, 1.0, 0.0, 0.0] }
        mainColor:      { value: [1.0, 1.0, 1.0, 1.0], target: albedo, editor: { displayName: Albedo, type: color } }
        albedoScale:    { value: [1.0, 1.0, 1.0], target: albedoScaleAndCutoff.xyz }
        alphaThreshold: { value: 0.5, target: albedoScaleAndCutoff.w, editor: { parent: USE_ALPHA_TEST } }
        mainTexture:    { value: grey, target: albedoMap, editor: { displayName: AlbedoMap } }
  - name: transparent
    passes:
    - vert: ray-query-vs
      frag: ray-query-fs
      embeddedMacros: { CC_FORCE_FORWARD_SHADING: true }
      depthStencilState:
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
    - *forward-add
    - *shadow-caster
}%

CCProgram shared-ubos %{
  uniform Constants {
    vec4 tilingOffset;
    vec4 albedo;
    vec4 albedoScaleAndCutoff;
    vec4 pbrParams;
    vec4 emissive;
    vec4 emissiveScaleParam;
  };
}%

CCProgram ray-query-vs %{
  precision highp float;
  #include <legacy/input-standard>
  #include <builtin/uniforms/cc-global>
  #include <legacy/decode-base>
  #include <legacy/local-batch>
  #include <shared-ubos>
  #include <legacy/fog-vs>
  #include <legacy/shadow-map-vs>

  #if USE_VERTEX_COLOR
    in vec4 a_color;
    out lowp vec4 v_color;
  #endif

  out vec3 v_position;
  out mediump vec3 v_normal;
  out vec2 v_uv;
  #if HAS_SECOND_UV
    out mediump vec2 v_uv1;
  #endif

  #if CC_RECEIVE_SHADOW
    out mediump vec2 v_shadowBias;
  #endif

  #if USE_NORMAL_MAP
    out mediump vec4 v_tangent;
  #endif

  #if HAS_SECOND_UV || CC_USE_LIGHTMAP
    in vec2 a_texCoord1;
  #endif

  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD
    #include <legacy/lightingmap-vs>
  #endif

  void main () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    vec4 pos = matWorld * In.position;

    v_position = pos.xyz;
    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);

    #if CC_RECEIVE_SHADOW
      v_shadowBias = CCGetShadowBias();
    #endif

    #if USE_TWOSIDE
      vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);
      v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;
    #endif

    #if USE_NORMAL_MAP
      v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
      v_tangent.w = In.tangent.w;
    #endif

    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(v_uv);
    #endif
    #if HAS_SECOND_UV
      v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;
      #if SAMPLE_FROM_RT
        CC_HANDLE_RT_SAMPLE_FLIP(v_uv1);
      #endif
    #endif

    #if USE_VERTEX_COLOR
      v_color = a_color;
    #endif

    CC_TRANSFER_FOG(pos);
    CC_TRANSFER_SHADOW(pos);

    #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD
      CCLightingMapCaclUV();
    #endif

    gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;
  }
}%

CCProgram ray-query-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <shared-ubos>
  #include <legacy/fog-fs>
  #include <legacy/standard-surface-entry>
  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD
    #include <legacy/lightingmap-fs>
  #endif

  layout(set = 0,binding = 5) uniform samplerCube cc_environment;

  #if __VERSION__ >= 460
    #include <builtin/uniforms/cc-acceleration-structure>
  #endif

  in vec3 v_position;
  in vec2 v_uv;
  #if HAS_SECOND_UV 
    in mediump vec2 v_uv1;
  #endif
  in mediump vec3 v_normal;

  #if CC_RECEIVE_SHADOW
    in mediump vec2 v_shadowBias;
  #endif

  #if USE_VERTEX_COLOR
    in lowp vec4 v_color;
  #endif

  #if USE_ALBEDO_MAP
    uniform sampler2D albedoMap;
    #pragma define-meta ALBEDO_UV options([v_uv, v_uv1])
  #endif
  #if USE_NORMAL_MAP
    in mediump vec4 v_tangent;
    uniform sampler2D normalMap;
    #pragma define-meta NORMAL_UV options([v_uv, v_uv1])
  #endif
  #pragma define-meta PBR_UV options([v_uv, v_uv1])
  #if USE_PBR_MAP
    uniform sampler2D pbrMap;
  #endif
  #if USE_METALLIC_ROUGHNESS_MAP
    uniform sampler2D metallicRoughnessMap;
  #endif
  #if USE_OCCLUSION_MAP
    uniform sampler2D occlusionMap;
  #endif
  #if USE_EMISSIVE_MAP
    uniform sampler2D emissiveMap;
    #pragma define-meta EMISSIVE_UV options([v_uv, v_uv1])
  #endif

  #pragma define OCCLUSION_CHANNEL          r
  #pragma define ROUGHNESS_CHANNEL          g
  #pragma define METALLIC_CHANNEL           b
  #pragma define SPECULAR_INTENSITY_CHANNEL a

  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r])
  #endif

 #if __VERSION__ >= 460
  uint baseHash( uvec2 p )
  {
    p = 1103515245U*((p >> 1U)^(p.yx));
    uint h32 = 1103515245U*((p.x)^(p.y>>3U));
    return h32^(h32 >> 16);
  }

  float hash1(inout float seed)
  {
    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));
    return float(n)/float(0xffffffffU);
  }

  vec3 random_in_unit_hemisphere(float seed)
  {
    float u = hash1(seed);
    float v = hash1(seed);
    float theta = u*2.0*PI;
    float sinTheta = sin(theta);
    float cosTheta = cos(theta);
    float cosPhi = v;
    float sinPhi = sqrt(1.0 - cosPhi * cosPhi);
    float x = sinPhi*cosTheta;
    float y = sinPhi*sinTheta;
    float z = cosPhi;
    return vec3(x,y,z);
  }

const mat3 CubePositions[12] = {mat3(vec3(0.5,0.5,0.5),vec3(-0.5,0.5,0.5),vec3(0.5,-0.5,0.5)),
                            mat3(vec3(0.5,-0.5,0.5),vec3(-0.5,0.5,0.5),vec3(-0.5,-0.5,0.5)),
                            mat3(vec3(0.5,-0.5,0.5),vec3(0.5,-0.5,-0.5),vec3(0.5,0.5,0.5)),
                            mat3(vec3(0.5,0.5,0.5),vec3(0.5,-0.5,-0.5),vec3(0.5,0.5,-0.5)),
                            mat3(vec3(0.5,-0.5,-0.5),vec3(-0.5,-0.5,-0.5),vec3(0.5,0.5,-0.5)),
                            mat3(vec3(0.5,0.5,-0.5), vec3(-0.5,-0.5,-0.5),vec3(-0.5,0.5,-0.5)),
                            mat3(vec3(-0.5,-0.5,-0.5),  vec3(-0.5,-0.5,0.5),vec3(-0.5,0.5,-0.5)),
                            mat3(vec3(-0.5,0.5,-0.5), vec3(-0.5,-0.5,0.5), vec3(-0.5,0.5,0.5)),
                            mat3(vec3(0.5,-0.5,0.5), vec3(-0.5,-0.5,0.5), vec3(0.5,-0.5,-0.5)),
                            mat3(vec3(0.5,-0.5,-0.5), vec3(-0.5,-0.5,0.5), vec3(-0.5,-0.5,-0.5)),
                            mat3(vec3(0.5,0.5,-0.5), vec3(-0.5,0.5,-0.5), vec3(0.5,0.5,0.5)),
                            mat3(vec3(0.5,0.5,0.5), vec3(-0.5,0.5,-0.5),vec3(-0.5,0.5,0.5))};

const mat3 CubeNormals[12] = {mat3(vec3(0.0,0.0,1.0),vec3(0.0,0.0,1.0),vec3(0.0,0.0,1.0)),
                            mat3(vec3(0.0,0.0,1.0),vec3(0.0,0.0,1.0),vec3(0.0,0.0,1.0)),
                            mat3(vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0)),
                            mat3(vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0),vec3(1.0,0.0,0.0)),
                            mat3(vec3(0.0,0.0,-1.0),vec3(0.0,0.0,-1.0),vec3(0.0,0.0,-1.0)),
                            mat3(vec3(0.0,0.0,-1.0),vec3(0.0,0.0,-1.0),vec3(0.0,0.0,-1.0)),
                            mat3(vec3(-1.0,0.0,0.0),vec3(-1.0,0.0,0.0),vec3(-1.0,0.0,0.0)),
                            mat3(vec3(-1.0,0.0,0.0),vec3(-1.0,0.0,0.0),vec3(-1.0,0.0,0.0)),
                            mat3(vec3(0.0,-1.0,0.0),vec3(0.0,-1.0,0.0),vec3(0.0,-1.0,0.0)),
                            mat3(vec3(0.0,-1.0,0.0),vec3(0.0,-1.0,0.0),vec3(0.0,-1.0,0.0)),
                            mat3(vec3(0.0,1.0,0.0),vec3(0.0,1.0,0.0),vec3(0.0,1.0,0.0)),
                            mat3(vec3(0.0,1.0,0.0),vec3(0.0,1.0,0.0),vec3(0.0,1.0,0.0))};

 #endif

  void surf (out StandardSurface s) {
    vec4 baseColor = albedo;
    #if USE_VERTEX_COLOR
      baseColor.rgb *= SRGBToLinear(v_color.rgb); // use linear
      baseColor.a *= v_color.a;
    #endif
    #if USE_ALBEDO_MAP
      vec4 texColor = texture(albedoMap, ALBEDO_UV);
      texColor.rgb = SRGBToLinear(texColor.rgb);
      baseColor *= texColor;
    #endif
    s.albedo = baseColor;
    s.albedo.rgb *= albedoScaleAndCutoff.xyz;

    #if USE_ALPHA_TEST
      if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
    #endif

    #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD
      vec4 lightColor = texture(cc_lightingMap, v_luv.xy);
      s.lightmap.a = lightColor.a;
      s.lightmap.rgb = lightColor.xyz * v_luv.z;
      s.lightmap_test = v_luv.z; /*lum*/
    #endif

    s.normal = v_normal;

    #if CC_RECEIVE_SHADOW
      s.shadowBias = v_shadowBias;
    #endif

    #if USE_NORMAL_MAP
      vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);
      vec3 bitangent = cross(v_normal, v_tangent.xyz) * v_tangent.w; // note the cross order
      s.normal =
        (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +
        (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +
        nmmp.z * normalize(s.normal);
    #endif

    HIGHP_VALUE_TO_STRUCT_DEFINED(v_position, s.position);

    #if __VERSION__ >= 460
      vec3 light_points[4] = {vec3(1.995,5.443,3.199),vec3(1.179,10.125,0.022),vec3(1.726,11.071,3.873),vec3(7.3,5.89,-0.865)};
      vec3 origin = s.position;
      vec3 viewDirect = normalize(cc_cameraPos.xyz - s.position);
      vec3 direction = -reflect(viewDirect,s.normal);
      if(s.albedo.r<0.1){
        direction = -viewDirect;
      }
      float tMin = 0.01f;
      float tMax = 1000.0f;

      rayQueryEXT rayQuery;
      rayQueryInitializeEXT(rayQuery, cc_topLevelAS,gl_RayFlagsOpaqueEXT, 0xFF, origin, tMin, direction, tMax);

      bool miss = true;

      for(int i = 0;i<5;++i){

            while(rayQueryProceedEXT(rayQuery));

            if(rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
            {
                int instanceId = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery,true);
                int primitiveIdx = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery,true);
                mat3 primitivePosition = CubePositions[primitiveIdx]; 
                mat3 primitiveNormal = CubeNormals[primitiveIdx];
                vec2 bary = rayQueryGetIntersectionBarycentricsEXT(rayQuery,true);
                const vec3 barycentrics = vec3(1.0 - bary.x - bary.y, bary.x, bary.y);
                mat4x3 objToWorld = rayQueryGetIntersectionObjectToWorldEXT(rayQuery,true);
                mat4x3 worldToObj = rayQueryGetIntersectionWorldToObjectEXT(rayQuery,true);
        
                const vec3 hitWorldPos = (objToWorld*vec4(primitivePosition*barycentrics,1.0)).xyz;
                const vec3 hitWorldNormal = (transpose(worldToObj) * (primitiveNormal*barycentrics)).xyz;
                origin = hitWorldPos;
                tMin = 0.01f;

                if(instanceId != 0 && instanceId != 7){
                    if(instanceId == 1){
                      s.albedo.rgb = vec3(0.0,0.0,1.0);
                    }else if(instanceId == 2){
                      s.albedo.rgb = vec3(1.0,0.0,0.0);
                    }else if(instanceId == 3){
                      s.albedo.rgb = vec3(0.0,1.0,0.0);
                    }else if(instanceId == 4){
                      s.albedo.rgb = vec3(1.0,1.0,0.0);
                    }else if(instanceId == 5){
                      s.albedo.rgb = vec3(1.0,1.0,1.0);
                      tMin = 0.1f;
                    }else if(instanceId == 6){
                      s.albedo.rgb = vec3(1.0,1.0,1.0);
                    }
                    float shadowFactor = 0.0;
                    for(int i =0;i<4;++i)
                    {
                        vec3 light_position = light_points[i];
                        vec3 L = light_position-origin; 
                        vec3 direction = normalize(L);
                        tMax = length(L);

                        // Initializes a ray query object but does not start traversal
                        rayQueryEXT rayQuery;
                        rayQueryInitializeEXT(rayQuery, cc_topLevelAS,gl_RayFlagsTerminateOnFirstHitEXT, 0xFF, origin, tMin, direction, tMax);

                        // Start traversal: return false if traversal is complete
                        while(rayQueryProceedEXT(rayQuery));

                        if(rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
                        {
                            shadowFactor += 1.0;
                        }
                    }
                    shadowFactor/= 4.0;
                    s.albedo *= (1.0-shadowFactor);
                    miss = false;
                    break;

                }else if(instanceId == 7){
                    float ior = 1.0;
                    if(dot(direction,hitWorldNormal)>=0){
                      ior = 1.0/ior;
                    }
                    direction = direction;//refract(-direction,hitWorldNormal,ior);
                    rayQueryInitializeEXT(rayQuery, cc_topLevelAS,gl_RayFlagsOpaqueEXT, 0xFF, origin, tMin, direction, tMax);
                }else{//hit walls or floor
                  direction = reflect(direction,hitWorldNormal);
                  rayQueryInitializeEXT(rayQuery, cc_topLevelAS,gl_RayFlagsOpaqueEXT, 0xFF, origin, tMin, direction, tMax);
                }
            }else{
                //miss
                s.albedo.rgb = texture(cc_environment,direction).rgb;
                break;
            }
        }
        //if miss
        if(miss)
            s.albedo.rgb = texture(cc_environment,direction).rgb;
      
    #endif

    vec4 pbr = pbrParams;
    #if USE_PBR_MAP
      vec4 res = texture(pbrMap, PBR_UV);
      pbr.x *= res.OCCLUSION_CHANNEL;
      pbr.y *= res.ROUGHNESS_CHANNEL;
      pbr.z *= res.METALLIC_CHANNEL;
      pbr.w *= res.SPECULAR_INTENSITY_CHANNEL;
    #endif
    #if USE_METALLIC_ROUGHNESS_MAP
      vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);
      pbr.z *= metallicRoughness.METALLIC_CHANNEL;
      pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;
    #endif
    #if USE_OCCLUSION_MAP
      pbr.x *= texture(occlusionMap, PBR_UV).OCCLUSION_CHANNEL;
    #endif
    s.occlusion = pbr.x;
    s.roughness = pbr.y;
    s.specularIntensity = 0.5;
    s.metallic = pbr.z;

    s.emissive = emissive.rgb * emissiveScaleParam.xyz;
    #if USE_EMISSIVE_MAP
      s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);
    #endif
  }

  CC_STANDARD_SURFACE_ENTRY()
}%

CCProgram shadow-caster-vs %{
  precision highp float;
  #include <legacy/input-standard>
  #include <legacy/decode-base>
  #include <legacy/local-batch>
  #include <shared-ubos>
  #include <builtin/uniforms/cc-shadow>

  #if HAS_SECOND_UV || CC_USE_LIGHTMAP
    in vec2 a_texCoord1;
  #endif

  out vec2 v_uv;
  #if HAS_SECOND_UV
    out vec2 v_uv1;
  #endif
  out vec4 v_worldPos;
  out highp vec2 v_clip_depth;

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    v_worldPos = matWorld * In.position;
    vec4 clipPos = cc_matLightViewProj * v_worldPos;

    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    #if HAS_SECOND_UV
      v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;
    #endif

    v_clip_depth = clipPos.zw;

    return clipPos;
  }
}%

CCProgram shadow-caster-fs %{
  precision highp float;
  #include <shared-ubos>
  #include <common/data/packing>
  #include <legacy/shadow-map-base>

  in vec2 v_uv;
  #if HAS_SECOND_UV
    in vec2 v_uv1;
  #endif
  in vec4 v_worldPos;
  in highp vec2 v_clip_depth;

  #if USE_ALBEDO_MAP
    uniform sampler2D albedoMap;
    #pragma define-meta ALBEDO_UV options([v_uv, v_uv1])
  #endif

  #if USE_ALPHA_TEST
    #pragma define-meta ALPHA_TEST_CHANNEL options([a, r])
  #endif

  vec4 frag () {
    vec4 baseColor = albedo;

    #if USE_ALPHA_TEST
      #if USE_ALBEDO_MAP
        baseColor *= texture(albedoMap, ALBEDO_UV);
      #endif
      if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;
    #endif

    highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;
    // spot use linear
    if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {
      // enabled linear depth
      #if CC_SHADOWMAP_USE_LINEAR_DEPTH
        clipDepth = CCGetLinearDepth(v_worldPos.xyz);
      #endif
    }

    #if CC_SHADOWMAP_FORMAT == SHADOWMAP_FORMAT_RGBA8
      return packDepthToRGBA(clipDepth);
    #else
      return vec4(clipDepth, 1.0, 1.0, 1.0);
    #endif
  }
}%
